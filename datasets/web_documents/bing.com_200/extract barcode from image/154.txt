<!doctype html>
<html lang="en">
 <head> 
  <title>MySQL Java tutorial - MySQL programming in Java with JDBC</title> 
  <link rel="stylesheet" href="/cfg/format2.css" type="text/css"> 
  <meta charset="utf-8"> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <meta name="keywords" content="Java, MySQL, JDBC, database, tutorial, learn MySQL Java"> 
  <meta name="description" content="This is MySQL Java tutorial. This tutorial covers the basics
of MySQL programming in Java with JDBC."> 
  <meta name="author" content="Jan Bodnar"> 
  <script src="https://apis.google.com/js/platform.js" async defer></script> 
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5536206-1', 'auto');
  ga('send', 'pageview');

</script> 
 </head> 
 <body> 
  <div class="container"> 
   <div id="wide_ad" class="ltow"> 
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> 
    <!-- 160x600, August 2011 --> 
    <ins class="adsbygoogle" style="display:inline-block;width:160px;height:600px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2484182563"></ins> 
    <script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script> 
   </div> 
   <div class="content"> 
    <header> 
     <nav> 
      <a href="/" title="Home">Home</a> 
      <a class="nav_r" title="Subscribe to ZetCode news" href="http://zetcode.us13.list-manage.com/subscribe?u=9def9ccd4c70dbbaf691f90fc&amp;id=6556210f80">Subscribe</a> 
     </nav> 
    </header> 
    <h1>MySQL Java tutorial</h1> 
    <p> This is a Java tutorial for the MySQL database. It covers the basics of MySQL programming in Java with JDBC. ZetCode has a complete <em>e-book</em> for MySQL Java: <a href="/ebooks/mysqljava/">MySQL Java programming e-book</a>. </p> 
    <div class="social"> 
     <div class="fb-like" data-href="http://zetcode.com/db/mysqljava/" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div> 
     <div class="g-plusone" data-size="medium"></div> 
     <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a> 
     <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id))
{js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 
'twitter-wjs');</script> 
    </div> 
    <p> In this tutorial, we use the <em>MySQL Connector/J</em> driver. It is the official JDBC driver for MySQL. The examples were created and tested on Ubuntu Linux. You might also want to check <a href="/lang/java/">Java tutorial</a>, <a href="/db/postgresqljavatutorial/">PostgreSQL Java tutorial</a>, <a href="/db/apachederbytutorial/">Apache Derby tutorial</a>, <a href="/databases/mysqltutorial/">MySQL tutorial</a>, or <a href="/db/jdbctemplate/">Spring JdbcTemplate tutorial</a> on ZetCode. </p> 
    <div class="big_hor"> 
     <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> 
     <!-- big_horizontal --> 
     <ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2904953388"></ins> 
     <script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script> 
    </div> 
    <h2>JDBC</h2> 
    <p> <em>JDBC</em> is an API for the Java programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. JDBC is oriented towards relational databases. From a technical point of view, the API is as a set of classes in the java.sql package. To use JDBC with a particular database, we need a JDBC driver for that database. </p> 
    <p> JDBC is a cornerstone for database programming in Java. Today, it is considered to be very low-level and prone to errors. Solutions such as MyBatis or JdbcTemplate were created to ease the burden of JDBC programming. However, under the hood, these solutions still use JDBC. JDBC is part of the Java Standard Edition platform. </p> 
    <p> JDBC manages these three main programming activities: </p> 
    <ul> 
     <li>connecting to a database;</li> 
     <li>sending queries and update statements to the database;</li> 
     <li>retrieving and processing the results received from the database in answer to the query.</li> 
    </ul> 
    <h2>MySQL Connector/J</h2> 
    <p> To connect to MySQL in Java, MySQL provides MySQL Connector/J, a driver that implements the JDBC API. MySQL Connector/J is a JDBC Type 4 driver. The Type 4 designation means that the driver is a pure Java implementation of the MySQL protocol and does not rely on the MySQL client libraries. In this tutorial, we use MySQL Connector/J 5.1.41, which is a maintenance release of the 5.1 production branch. </p> 
    <h2>Connection string</h2> 
    <p> A database connection is defined with a connection string. It contains information such as database type, database name, server name, and port number. It also may contain additional key/value pairs for configuration. Each database has its own connection string format. </p> 
    <p> The following is a syntax of a MySQL connection string: </p> 
    <pre>
jdbc:mysql://[host1][:port1][,[host2][:port2]]...[/[database]] 
    [?propertyName1=propertyValue1[&amp;propertyName2=propertyValue2]...]
</pre> 
    <p> It is possible to specify multiple hosts for a server failover setup. The items in square brackets are optional. If no host is specified, the host name defaults to localhost. If the port for a host is not specified, it defaults to 3306, the default port number for MySQL servers. </p> 
    <pre>
jdbc:mysql://localhost:3306/testdb?useSSL=false
</pre> 
    <p> This is an example of a MySQL connection string. The <code>jdbc:mysql://</code> is known as a sub-protocol and is constant for MySQL. We connect to the <code>localhost</code> on MySQL standard port 3306. The database name is <code>testdb</code>. The additional key/value pairs follow the question mark character (?). The <code>useSSL=false</code> tells MySQL that there will be no secure connection. </p> 
    <h2>About MySQL database</h2> 
    <p> MySQL is a leading open source database management system. It is a multi user, multithreaded database management system. MySQL is especially popular on the web. It is one part of the very popular <em>LAMP</em> platform consisting of Linux, Apache, MySQL, and PHP. Currently MySQL is owned by Oracle. MySQL database is available on most important OS platforms. It runs on BSD Unix, Linux, Windows, or Mac OS. Wikipedia and YouTube use MySQL. These sites manage millions of queries each day. MySQL comes in two versions: MySQL server system and MySQL embedded system. </p> 
    <h2>Before we start</h2> 
    <p> For this tutorial, we need to have several libraries installed. We need to install mysql-server and mysql-client packages. The first package has the MySQL server and the second one contains, among others, the mysql monitor tool. We need to install the <em>JDK</em>, Java Development Kit, for compiling and running Java programs. Finally, we need the <em>MySQL Connector/J</em> driver. In NetBeans, we go to the Projects tab and right-click on the Libraries node, and select Add JAR/Folder. We locate the MySQL Connector/J JAR and add it to the project libraries. </p> 
    <figure> 
     <img src="/img/db/mysqljava/projects.png" alt="NetBeans project libs"> 
     <figcaption>
      Figure: NetBeans project libs
     </figcaption> 
    </figure> 
    <p> The MySQL Connector/J can be downloaded from <a href="http://dev.mysql.com/downloads/connector/j/">http://dev.mysql.com/downloads/connector/j/</a>. </p> 
    <p> If we do not already have MySQL installed, we must install it. </p> 
    <pre>
$ sudo apt-get install mysql-server
</pre> 
    <p> This command installs the MySQL server and various other packages. While installing the package, we are prompted to enter a password for the MySQL root account. </p> 
    <p> Next, we are going to create a new database user and a new database. We use the <code>mysql</code> client. </p> 
    <pre>
$ sudo service mysql status
mysql start/running, process 5129
</pre> 
    <p> We check if the MySQL server is running. If not, we need to start the server. On Ubuntu Linux, this can be done with the <code>sudo service mysql start</code> command. </p> 
    <pre>
$ mysql -u root -p
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 30
Server version: 5.0.67-0ubuntu6 (Ubuntu)

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql&gt; SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema | 
| mysql              | 
+--------------------+
2 rows in set (0.00 sec)
</pre> 
    <p> We use the <em>mysql monitor</em> client application to connect to the server. We connect to the database using the root account. We show all available databases with the <code>SHOW DATABASES</code> statement. </p> 
    <pre>
mysql&gt; CREATE DATABASE testdb;
Query OK, 1 row affected (0.02 sec)
</pre> 
    <p> We create a new <code>testdb</code> database. We will use this database throughout the tutorial. </p> 
    <pre>
mysql&gt; CREATE USER 'testuser'@'localhost' IDENTIFIED BY 'test623';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; USE testdb;
Database changed

mysql&gt; GRANT ALL ON testdb.* TO 'testuser'@'localhost';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; quit;
Bye
</pre> 
    <p> We create a new database user. We grant all privileges to this user for all tables of the testdb database. </p> 
    <h2>Maven file</h2> 
    <p> It is more convenient to create our applications with Maven. </p> 
    <div class="codehead">
     pom.xml
    </div> 
    <pre class="code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                             http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.zetcode&lt;/groupId&gt;
    &lt;artifactId&gt;Version&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.41&lt;/version&gt;
        &lt;/dependency&gt;    
    &lt;/dependencies&gt;

&lt;/project&gt;
</pre> 
    <p> The POM file has a dependency for the MySQL driver. </p> 
    <h2>MySQL version</h2> 
    <p> If the following program runs OK, then we have everything installed OK. We check the version of the MySQL server. </p> 
    <div class="codehead">
     Version.java
    </div> 
    <pre class="code">
package com.zetcode.version;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Version {

    public static void main(String[] args) {

        Connection con = null;
        Statement st = null;
        ResultSet rs = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {
            
            con = DriverManager.getConnection(url, user, password);
            st = con.createStatement();
            rs = st.executeQuery("SELECT VERSION()");

            if (rs.next()) {
                
                System.out.println(rs.getString(1));
            }

        } catch (SQLException ex) {
        
            Logger lgr = Logger.getLogger(Version.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {
            
            try {
                
                if (rs != null) {
                    rs.close();
                }
                
                if (st != null) {
                    st.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(Version.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> We connect to the database and get some info about the MySQL server. </p> 
    <pre class="explanation">
String url = "jdbc:mysql://localhost:3306/testdb";
</pre> 
    <p> This is the connection URL for the MySQL database. Each driver has a different syntax for the URL. In our case, we provide a host, a port, and a database name. </p> 
    <pre class="explanation">
con = DriverManager.getConnection(url, user, password);
</pre> 
    <p> We establish a connection to the database, using the connection URL, user name, and password. The connection is established with the <code>getConnection()</code> method. </p> 
    <pre class="explanation">
st = con.createStatement();
</pre> 
    <p> The <code>createStatement()</code> method of the connection object creates a <code>Statement</code> object for sending SQL statements to the database. </p> 
    <pre class="explanation">
rs = st.executeQuery("SELECT VERSION()");
</pre> 
    <p> The <code>executeQuery()</code> method of the connection object executes the given SQL statement, which returns a single <code>ResultSet</code> object. The <code>ResultSet</code> is a table of data returned by a specific SQL statement. </p> 
    <pre class="explanation">
if (result.next()) {

    System.out.println(result.getString(1));
}
</pre> 
    <p> A <code>ResultSet</code> object maintains a cursor pointing to its current row of data. Initially the cursor is positioned before the first row. The <code>next()</code> method moves the cursor to the next row. If there are no rows left, the method returns <code>false</code>. The <code>getString()</code> method retrieves the value of a specified column. The first column has index 1. </p> 
    <pre class="explanation">
} catch (SQLException ex) {

    Logger lgr = Logger.getLogger(Version.class.getName());
    lgr.log(Level.SEVERE, ex.getMessage(), ex);

}
</pre> 
    <p> In case of an exception, we log the error message. For this console example, the message is displayed in the terminal. </p> 
    <pre class="explanation">
try {

    if (rs != null) {
        rs.close();
    }
    
    if (st != null) {
        st.close();
    }
    
    if (con != null) {
        con.close();
    }
...
</pre> 
    <p> Inside the finally block, we close the database resources. We also check if the objects are not equal to <code>null</code>. This is to prevent null pointer exceptions. Otherwise we might get a <code>NullPointerException</code>, which would terminate the application and leave the resources not cleaned up. </p> 
    <pre class="explanation">
} catch (SQLException ex) {

    Logger lgr = Logger.getLogger(Version.class.getName());
    lgr.log(Level.WARNING, ex.getMessage(), ex);
}
</pre> 
    <p> We log an error message, when the resources could not be closed. </p> 
    <pre>
$ javac -d bin src/com/zetcode/version/Version.java
</pre> 
    <p> We compile the example. The <code>-d</code> option tells where the compiled program will be located. </p> 
    <pre>
$ tree
.
??? bin
?   ??? com
?       ??? zetcode
?           ??? version
?               ??? Version.class
??? lib
?   ??? mysql-connector-java-5.1.41-bin.jar
??? src
    ??? com
        ??? zetcode
            ??? version
                ??? Version.java

8 directories, 3 files
</pre> 
    <p> The directory structures look like this. </p> 
    <pre>
$ java -cp bin:lib/mysql-connector-java-5.1.41-bin.jar com.zetcode.version.Version 
5.5.49-0ubuntu0.14.04.1
</pre> 
    <p> We run the program from the command line. </p> 
    <h2>Creating and populating tables</h2> 
    <p> Next we are going to create database tables and fill them with data. These tables will be used throughout this tutorial. </p> 
    <div class="codehead">
     tables.sql
    </div> 
    <pre class="code">
USE testdb;

DROP TABLE IF EXISTS Books, Authors, Testing, Images;

CREATE TABLE Authors(Id BIGINT PRIMARY KEY AUTO_INCREMENT, Name VARCHAR(100));
CREATE TABLE Books(Id BIGINT PRIMARY KEY AUTO_INCREMENT, AuthorId BIGINT, 
    Title VARCHAR(100), FOREIGN KEY(AuthorId) REFERENCES Authors(Id) ON DELETE CASCADE);
CREATE TABLE Testing(Id INT);
CREATE TABLE Images(Id INT PRIMARY KEY AUTO_INCREMENT, Data MEDIUMBLOB);

INSERT INTO Authors(Id, Name) VALUES(1, 'Jack London');
INSERT INTO Authors(Id, Name) VALUES(2, 'Honore de Balzac');
INSERT INTO Authors(Id, Name) VALUES(3, 'Lion Feuchtwanger');
INSERT INTO Authors(Id, Name) VALUES(4, 'Emile Zola');
INSERT INTO Authors(Id, Name) VALUES(5, 'Truman Capote');

INSERT INTO Books(Id, AuthorId, Title) VALUES(1, 1, 'Call of the Wild');
INSERT INTO Books(Id, AuthorId, Title) VALUES(2, 1, 'Martin Eden');
INSERT INTO Books(Id, AuthorId, Title) VALUES(3, 2, 'Old Goriot');
INSERT INTO Books(Id, AuthorId, Title) VALUES(4, 2, 'Cousin Bette');
INSERT INTO Books(Id, AuthorId, Title) VALUES(5, 3, 'Jew Suess');
INSERT INTO Books(Id, AuthorId, Title) VALUES(6, 4, 'Nana');
INSERT INTO Books(Id, AuthorId, Title) VALUES(7, 4, 'The Belly of Paris');
INSERT INTO Books(Id, AuthorId, Title) VALUES(8, 5, 'In Cold blood');
INSERT INTO Books(Id, AuthorId, Title) VALUES(9, 5, 'Breakfast at Tiffany');
</pre> 
    <p> The SQL commands create four database tables: <code>Authors</code>, <code>Books</code>, <code>Testing</code>, and <code>Images</code>. The tables are of InnoDB type. InnoDB databases support foreign key constraints and transactions. We place a foreign key constraint on the <code>AuthorId</code> column of the <code>Books</code> table. We fill the <code>Authors</code> and <code>Books</code> tables with initial data. </p> 
    <pre>
mysql&gt; source tables.sql
Query OK, 0 rows affected (0.07 sec)
Query OK, 0 rows affected (0.12 sec)
Query OK, 1 row affected (0.04 sec)
...
</pre> 
    <p> We use the <code>source</code> command to execute the <code>tables.sql</code> script. </p> 
    <h2>Prepared statements</h2> 
    <p> Now we will concern ourselves with prepared statements. When we write prepared statements, we use placeholders instead of directly writing the values into the statements. Prepared statements increase security and performance. </p> 
    <p> In Java a <code>PreparedStatement</code> is an object which represents a precompiled SQL statement. </p> 
    <div class="codehead">
     Prepared.java
    </div> 
    <pre class="code">
package com.zetcode.prepared;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Prepared {

    public static void main(String[] args) {

        Connection con = null;
        PreparedStatement pst = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            String author = "Trygve Gulbranssen";
            con = DriverManager.getConnection(url, user, password);

            pst = con.prepareStatement("INSERT INTO Authors(Name) VALUES(?)");
            pst.setString(1, author);
            pst.executeUpdate();

        } catch (SQLException ex) {
            
            Logger lgr = Logger.getLogger(Prepared.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
                
                if (pst != null) {
                    pst.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(Prepared.class.getName());
                lgr.log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> We add a new author to the <code>Authors</code> table. </p> 
    <pre class="explanation">
pst = con.prepareStatement("INSERT INTO Authors(Name) VALUES(?)");
</pre> 
    <p> Here we create a prepared statement. When we write prepared statements, we use placeholders instead of directly writing the values into the statements. Prepared statements are faster and guard against SQL injection attacks. The <code>?</code> is a placeholder which is going to be filled later. </p> 
    <pre class="explanation">
pst.setString(1, author);
</pre> 
    <p> A value is bound to the placeholder. </p> 
    <pre class="explanation">
pst.executeUpdate();
</pre> 
    <p> The prepared statement is executed. We use the <code>executeUpdate()</code> method of the statement object when we don't expect any data to be returned. This is when we create databases or execute <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> statements. </p> 
    <pre>
$ javac -d bin src/com/zetcode/prepared/Prepared.java
$ java -cp bin:lib/* com.zetcode.prepared.Prepared 
mysql&gt; select * from Authors;
+----+--------------------+
| Id | Name               |
+----+--------------------+
|  1 | Jack London        |
|  2 | Honore de Balzac   |
|  3 | Lion Feuchtwanger  |
|  4 | Emile Zola         |
|  5 | Truman Capote      |
|  6 | Trygve Gulbranssen |
+----+--------------------+
6 rows in set (0.00 sec)
</pre> 
    <p> We have a new author inserted into the table. </p> 
    <p> For the following two examples, we will use the Testing table. We will execute a normal statement and a prepared statement 1000 times. We check if there is some difference in execution time. </p> 
    <div class="codehead">
     NotPrepared.java
    </div> 
    <pre class="code">
package com.zetcode.notprepared;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class NotPrepared {

    public static void main(String[] args) {

        Connection con = null;
        Statement st = null;

        String cs = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(cs, user, password);

            st = con.createStatement();

            for (int i=1; i&lt;=1000; i++) {
            
                String query = "INSERT INTO Testing(Id) VALUES(" + 2*i + ")";
                st.executeUpdate(query);
            }

        } catch (SQLException ex) {
        
            Logger lgr = Logger.getLogger(NotPrepared.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
            
                if (st != null) {
                    st.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
            
                Logger lgr = Logger.getLogger(NotPrepared.class.getName());
                lgr.log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> The first example uses the normal <code>Statement</code> object. </p> 
    <pre class="explanation">
for (int i=1; i&lt;=1000; i++) {

    String query = "INSERT INTO Testing(Id) VALUES(" + 2*i + ")";
    st.executeUpdate(query);
}
</pre> 
    <p> We build the query and execute it 1000 times. </p> 
    <pre>
$ /usr/bin/time java -cp bin:lib/* com.zetcode.notprepared.NotPrepared 
1.03user 0.13system 0:40.72elapsed 2%CPU (0avgtext+0avgdata 42548maxresident)k
0inputs+88outputs (0major+16368minor)pagefaults 0swaps
</pre> 
    <p> We use the <code>time</code> command to measure the time which the program ran. Note that we use a standard Linux command, not the built-in bash time command. It took 40 seconds to insert 1000 rows into the table using the <code>Statement</code> object. </p> 
    <div class="codehead">
     Prepared2.java
    </div> 
    <pre class="code">
package com.zetcode.prepared2;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Prepared2 {

    public static void main(String[] args) {

        Connection con = null;
        PreparedStatement pst = null;
        
        String cs = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(cs, user, password);

            pst = con.prepareStatement("INSERT INTO Testing(Id) VALUES(?)");

            for (int i = 1; i &lt;= 1000; i++) {
                
                pst.setInt(1, i * 2);
                pst.executeUpdate();
            }

        } catch (SQLException ex) {
            
            Logger lgr = Logger.getLogger(Prepared2.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
                
                if (pst != null) {
                    pst.close();
                }
                
                if (con != null) {
                    con.close();
                }
                
            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(Prepared2.class.getName());
                lgr.log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> Now we use the <code>PreparedStatement</code> to do the same task. </p> 
    <pre class="explanation">
pst = con.prepareStatement("INSERT INTO Testing(Id) VALUES(?)");
</pre> 
    <p> We create the prepared statement using the <code>prepareStatement()</code> method. </p> 
    <pre class="explanation">
for (int i = 1; i &lt;= 1000; i++) {

    pst.setInt(1, i * 2);
    pst.executeUpdate();
}
</pre> 
    <p> We bind a value to the prepared statement, execute it in a loop thousand times. </p> 
    <pre>
$ /usr/bin/time java -cp bin:lib/* com.zetcode.prepared2.Prepared2 
1.05user 0.09system 0:35.80elapsed 3%CPU (0avgtext+0avgdata 42084maxresident)k
8inputs+88outputs (0major+16330minor)pagefaults 0swaps
</pre> 
    <p> Now it took 35 seconds to insert 1000 rows. We have saved 5 seconds. </p> 
    <h2>Retrieving data</h2> 
    <p> Next we will show how to retrieve data from a database table. We get all data from the <code>Authors</code> table. We build the project with Ant. </p> 
    <div class="codehead">
     build.xml
    </div> 
    <pre class="code">
&lt;?xml version="1.0"?&gt;
&lt;project name="RetrieveAll" default="archive"&gt;

  &lt;target name="init"&gt;
    &lt;mkdir dir="build/classes" /&gt;
    &lt;mkdir dir="dist" /&gt;
  &lt;/target&gt;

  &lt;target name="compile" depends="init"&gt;
    &lt;javac includeantruntime="false" srcdir="src" destdir="build/classes" /&gt;
  &lt;/target&gt;

  &lt;target name="archive" depends="compile"&gt;
    &lt;jar destfile="dist/retrieve_all.jar" basedir="build/classes"&gt;
       &lt;manifest&gt;
         &lt;attribute name="Main-Class" value="com.zetcode.retrieveall.RetrieveAll" /&gt;
       &lt;/manifest&gt;
       &lt;zipgroupfileset dir="lib" includes="*.jar"/&gt;
    &lt;/jar&gt;
  &lt;/target&gt;

  &lt;target name="clean"&gt;
    &lt;delete dir="build" /&gt;
    &lt;delete dir="dist" /&gt;
  &lt;/target&gt;  
  
&lt;/project&gt; 
</pre> 
    <p> This is the Ant build file. </p> 
    <pre>
$ tree
.
??? build.xml
??? lib
?   ??? mysql-connector-java-5.1.39-bin.jar
??? src
    ??? com
        ??? zetcode
            ??? retrieveall
                ??? RetrieveAll.java

5 directories, 3 files
</pre> 
    <p> This is the project directory structure. </p> 
    <div class="codehead">
     RetrieveAll.java
    </div> 
    <pre class="code">
package com.zetcode.retrieve;

import java.sql.PreparedStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;

public class RetrieveAll {
    
    public static void main(String[] args) {

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {
            
            con = DriverManager.getConnection(url, user, password);
            pst = con.prepareStatement("SELECT * FROM Authors");
            rs = pst.executeQuery();

            while (rs.next()) {
                
                System.out.print(rs.getInt(1));
                System.out.print(": ");
                System.out.println(rs.getString(2));
            }

        } catch (SQLException ex) {
            
                Logger lgr = Logger.getLogger(RetrieveAll.class.getName());
                lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
            
                if (rs != null) {
                    rs.close();
                }
                
                if (pst != null) {
                    pst.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(RetrieveAll.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> We get all authors from the <code>Authors</code> table and print them to the console. </p> 
    <pre class="explanation">
pst = con.prepareStatement("SELECT * FROM Authors");
rs = pst.executeQuery();
</pre> 
    <p> We execute a query that selects all columns from the <code>Authors</code> table. We use the <code>executeQuery()</code> method. The method executes the given SQL statement, which returns a single <code>ResultSet</code> object. The <code>ResultSet</code> is the data table returned by the SQL query. </p> 
    <pre class="explanation">
while (rs.next()) {

      System.out.print(rs.getInt(1));
      System.out.print(": ");
      System.out.println(rs.getString(2));
}
</pre> 
    <p> The <code>next()</code> method advances the cursor to the next record. It returns <code>false</code> when there are no more rows in the result set. The <code>getInt()</code> and <code>getString()</code> methods retrieve the value of the designated column in the current row of this <code>ResultSet</code> object as an <code>int</code> and <code>String</code> of the Java programming language. </p> 
    <pre>
$ ant
Buildfile: /home/janbodnar/prog/mysqljava/retrieve_all/build.xml

init:
    [mkdir] Created dir: /home/janbodnar/prog/mysqljava/retrieve_all/build/classes
    [mkdir] Created dir: /home/janbodnar/prog/mysqljava/retrieve_all/dist

compile:
    [javac] Compiling 1 source file to /home/janbodnar/prog/mysqljava/retrieve_all/build/classes

archive:
      [jar] Building jar: /home/janbodnar/prog/mysqljava/retrieve_all/dist/retrieve_all.jar

BUILD SUCCESSFUL
Total time: 1 second
</pre> 
    <p> We build the project with Ant. </p> 
    <pre>
$ java -jar dist/retrieve_all.jar 
1: Jack London
2: Honore de Balzac
3: Lion Feuchtwanger
4: Emile Zola
5: Truman Capote
6: Trygve Gulbranssen
</pre> 
    <p> We execute the program; we have IDs and names of authors printed to the console. </p> 
    <h2>Properties</h2> 
    <p> It is a common practice to put the configuration data outside the program in a separate file. This way the programmers are more flexible. We can change the user, a password or a connection url without needing to recompile the program. It is especially useful in a dynamic environment, where is a need for a lot of testing, debugging, securing data etc. </p> 
    <p> In Java, the <code>Properties</code> is a class used often for this. The class is used for easy reading and saving of key/value properties. </p> 
    <div class="codehead">
     db.properties
    </div> 
    <pre class="code">
db.url=jdbc:mysql://localhost:3306/testdb
db.user=testuser
db.passwd=test623
</pre> 
    <p> We have a <code>db.properties</code> file in which we have three key/value pairs. These are dynamically loaded during the execution of the program. </p> 
    <div class="codehead">
     RetreiveAll2.java
    </div> 
    <pre class="code">
package com.zetcode.retrieve2;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

public class RetreiveAll2 {

    public static void main(String[] args) {

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        Properties props = new Properties();
        FileInputStream in = null;

        try {
            in = new FileInputStream("src/main/resources/db.properties");
            props.load(in);

        } catch (FileNotFoundException ex) {

            Logger lgr = Logger.getLogger(RetrieveAll2.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } catch (IOException ex) {

            Logger lgr = Logger.getLogger(RetrieveAll2.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {
            
            try {
                 if (in != null) {
                     in.close();
                 }
            } catch (IOException ex) {
                Logger lgr = Logger.getLogger(RetrieveAll2.class.getName());
                lgr.log(Level.SEVERE, ex.getMessage(), ex);
            }
        }

        String url = props.getProperty("db.url");
        String user = props.getProperty("db.user");
        String passwd = props.getProperty("db.passwd");

        try {

            con = DriverManager.getConnection(url, user, passwd);
            pst = con.prepareStatement("SELECT * FROM Authors");
            rs = pst.executeQuery();

            while (rs.next()) {
                
                System.out.print(rs.getInt(1));
                System.out.print(": ");
                System.out.println(rs.getString(2));
            }

        } catch (Exception ex) {
            
            Logger lgr = Logger.getLogger(RetrieveAll2.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
                
                if (rs != null) {
                    rs.close();
                }
                
                if (pst != null) {
                    pst.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(RetrieveAll2.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> We connect to the testdb database and print the contents of the <code>Authors</code> table to the console. This time, we load the connection properties from a file. They are not hard coded in the proram. </p> 
    <pre class="explanation">
Properties props = new Properties();
FileInputStream in = null;

try {
    in = new FileInputStream("src/main/resources/db.properties");
    props.load(in);
...
</pre> 
    <p> The <code>Properties</code> class is created. The data is loaded from the file called database.properties, where we have our configuration data. </p> 
    <pre class="explanation">
String url = props.getProperty("db.url");
String user = props.getProperty("db.user");
String passwd = props.getProperty("db.passwd");
</pre> 
    <p> The values are retrieved with the <code>getProperty()</code> method. </p> 
    <h2>Datasource</h2> 
    <p> In this example, we connect to the database using a data source. The usage of a data source improves application's performance and scalability. Using a datasource has several advantages over the <code>DriverManager</code>: increased portability, connection pooling, and distributed transactions. </p> 
    <p> The <code>MysqlDataSource</code> is a class for creating datasources. </p> 
    <div class="codehead">
     db.properties
    </div> 
    <pre class="code">
# mysql properties
mysql.driver=com.mysql.jdbc.Driver
mysql.url=jdbc:mysql://localhost:3306/testdb
mysql.username=testuser
mysql.password=test623
</pre> 
    <p> The are the properties for the MySQL database. </p> 
    <div class="codehead">
     DataSourceEx.java
    </div> 
    <pre class="code">
package com.zetcode.datasourceex;

import com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource;
import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.Properties;

public class DataSourceEx {

    public static MysqlDataSource getMySQLDataSource() throws
            FileNotFoundException, IOException {

        Properties props = new Properties();
        FileInputStream fis = null;
        MysqlDataSource ds = null;

        fis = new FileInputStream("src/main/resources/db.properties");
        props.load(fis);

        ds = new MysqlConnectionPoolDataSource();
        ds.setURL(props.getProperty("mysql.url"));
        ds.setUser(props.getProperty("mysql.username"));
        ds.setPassword(props.getProperty("mysql.password"));

        return ds;
    }

    public static void main(String[] args) throws IOException, SQLException {

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        MysqlDataSource ds = getMySQLDataSource();

        try {

            con = ds.getConnection();
            pst = con.prepareStatement("SELECT * FROM Authors");
            rs = pst.executeQuery();

            while (rs.next()) {

                System.out.print(rs.getInt(1));
                System.out.print(": ");
                System.out.println(rs.getString(2));
            }

        } finally {

            if (rs != null) {
                rs.close();
            }

            if (pst != null) {
                pst.close();
            }

            if (con != null) {
                con.close();
            }
        }
    }
}
</pre> 
    <p> In this example, we connect to the database using a datasource. </p> 
    <pre class="explanation">
fis = new FileInputStream("src/main/resources/db.properties");
props.load(fis);
</pre> 
    <p> The database properties are read from the <code>db.properties</code> file. </p> 
    <pre class="explanation">
ds = new MysqlConnectionPoolDataSource();
ds.setURL(props.getProperty("mysql.url"));
ds.setUser(props.getProperty("mysql.username"));
ds.setPassword(props.getProperty("mysql.password"));
</pre> 
    <p> A <code>MysqlConnectionPoolDataSource</code> is created and the datasource properties are set. </p> 
    <pre class="explanation">
con = ds.getConnection();
</pre> 
    <p> A connection object is created from the datasource. </p> 
    <h2>Multiple statements</h2> 
    <p> It is possible to execute multiple SQL statements in one query. The <code>allowMultiQueries</code> must be set to enable multiple statements in MySQL. </p> 
    <div class="codehead">
     MultipleStatements.java
    </div> 
    <pre class="code">
package com.zetcode.multiplestatements;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class MultipleStatements {

    public static void main(String[] args) throws SQLException {

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        String cs = "jdbc:mysql://localhost:3306/testdb?allowMultiQueries=true";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(cs, user, password);

            String query = "SELECT Id, Name FROM Authors WHERE Id=1;"
                    + "SELECT Id, Name FROM Authors WHERE Id=2;"
                    + "SELECT Id, Name FROM Authors WHERE Id=3";

            pst = con.prepareStatement(query);
            boolean isResult = pst.execute();

            do {
                rs = pst.getResultSet();

                while (rs.next()) {

                    System.out.print(rs.getInt(1));
                    System.out.print(": ");
                    System.out.println(rs.getString(2));
                }

                isResult = pst.getMoreResults();

            } while (isResult);

        } finally {

            if (rs != null) {
                rs.close();
            }

            if (pst != null) {
                pst.close();
            }

            if (con != null) {
                con.close();
            }

        }
    }
}
</pre> 
    <p> In the code example, we retrieve three rows from the <code>Authors</code> table. We use three <code>SELECT</code> statements to get three rows. </p> 
    <pre class="explanation">
String cs = "jdbc:mysql://localhost:3306/testdb?allowMultiQueries=true";
</pre> 
    <p> We enable multiple statements queries in the database URL by setting the <code>allowMultiQueries</code> parameter to true. </p> 
    <pre class="explanation">
String query = "SELECT Id, Name FROM Authors WHERE Id=1;"
        + "SELECT Id, Name FROM Authors WHERE Id=2;"
        + "SELECT Id, Name FROM Authors WHERE Id=3";
</pre> 
    <p> Here we have a query with multiple statements. The statements are separated by a semicolon. </p> 
    <pre class="explanation">
boolean isResult = pst.execute();
</pre> 
    <p> We call the <code>execute()</code> method of the prepared statement object. The method returns a boolean value indicating if the first result is a <code>ResultSet</code> object. Subsequent results are called using the <code>getMoreResults()</code> method. </p> 
    <pre class="explanation">
do {
    rs = pst.getResultSet();

    while (rs.next()) {
        System.out.print(rs.getInt(1));
        System.out.print(": ");
        System.out.println(rs.getString(2));
    }

    isResult = pst.getMoreResults();
    
} while (isResult);
</pre> 
    <p> The processing of the results is done inside the <code>do while</code> loop. The <code>ResultSet</code> is retrieved with the <code>getResultSet()</code> method call. To find out if there are other results, we call the <code>getMoreResults()</code> method. </p> 
    <pre>
$ java -cp bin:lib/* com.zetcode.multiplestatements.MultipleStatements 
1: Jack London
2: Honore de Balzac
3: Lion Feuchtwanger
</pre> 
    <p> This is the output of the example. The first three rows were retrieved from the <code>Authors</code> table. </p> 
    <h2>Column headers</h2> 
    <p> The following example shows how to print column headers with the data from the database table. We refer to column names as MetaData. MetaData is data about the core data in the database. </p> 
    <div class="codehead">
     ColumnHeaders.java
    </div> 
    <pre class="code">
package com.zetcode.columnheaders;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.Formatter;

public class ColumnHeaders {

    public static void main(String[] args) throws SQLException {

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        String cs = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(cs, user, password);
            String query = "SELECT Name, Title From Authors, "
                    + "Books WHERE Authors.Id=Books.AuthorId";
            pst = con.prepareStatement(query);

            rs = pst.executeQuery();

            ResultSetMetaData meta = rs.getMetaData();

            String colname1 = meta.getColumnName(1);
            String colname2 = meta.getColumnName(2);

            Formatter fmt1 = new Formatter();
            fmt1.format("%-21s%s", colname1, colname2);
            System.out.println(fmt1);

            while (rs.next()) {

                Formatter fmt2 = new Formatter();
                fmt2.format("%-21s", rs.getString(1));
                System.out.print(fmt2);
                System.out.println(rs.getString(2));
            }

        } finally {

            if (rs != null) {
                rs.close();
            }
            
            if (pst != null) {
                pst.close();
            }
            
            if (con != null) {
                con.close();
            }

        }
    }
}
</pre> 
    <p> In this program, we select authors from the <code>Authors</code> table and their books from the <code>Books</code> table. We print the names of the columns returned in the result set. We format the output. </p> 
    <pre class="explanation">
String query = "SELECT Name, Title From Authors, " +
    "Books WHERE Authors.Id=Books.AuthorId";
</pre> 
    <p> This is the SQL statement which joins authors with their books. </p> 
    <pre class="explanation">
ResultSetMetaData meta = rs.getMetaData();
</pre> 
    <p> To get the column names we need to get the <code>ResultSetMetaData</code>. It is an object that can be used to get information about the types and properties of the columns in a <code>ResultSet</code> object. </p> 
    <pre class="explanation">
String colname1 = meta.getColumnName(1);
String colname2 = meta.getColumnName(2);
</pre> 
    <p> From the obtained metadata, we get the column names. </p> 
    <pre class="explanation">
Formatter fmt1 = new Formatter();
fmt1.format("%-21s%s", colname1, colname2);
System.out.println(fmt1)
</pre> 
    <p> We print the column names to the console. We use the <code>Formatter</code> object to format the data. </p> 
    <pre class="explanation">
while (rs.next()) {

    Formatter fmt2 = new Formatter();
    fmt2.format("%-21s", rs.getString(1));
    System.out.print(fmt2);
    System.out.println(rs.getString(2));
}
</pre> 
    <p> We print the data to the console. We again use the <code>Formatter</code> object to format the data. The first column is 21 characters wide and is aligned to the left. </p> 
    <pre>
$ java -cp bin:lib/* com.zetcode.columnheaders.ColumnHeaders 
Name                 Title
Jack London          Call of the Wild
Jack London          Martin Eden
Honore de Balzac     Old Goriot
Honore de Balzac     Cousin Bette
Lion Feuchtwanger    Jew Suess
Emile Zola           Nana
Emile Zola           The Belly of Paris
Truman Capote        In Cold blood
Truman Capote        Breakfast at Tiffany
</pre> 
    <p> This is the output of the program. </p> 
    <h2>Auto-generated keys</h2> 
    <p> MySQL's <code>AUTO_INCREMENT</code> attribute generates a unique ID for new rows. The following example shows how we can use JDBC to retrieve an auto-generated key value. </p> 
    <div class="codehead">
     JdbcAutoGenKey.java
    </div> 
    <pre class="code">
package com.zetcode;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class JdbcAutoGenKey {

    public static void main(String[] args) throws SQLException {

        Connection con = null;
        PreparedStatement pst = null;

        String url = "jdbc:mysql://localhost:3306/testdb?useSSL=false";
        String user = "testuser";
        String password = "test623";

        try {

            String author = "Oscar Wilde";
            con = DriverManager.getConnection(url, user, password);
            
            String sql = "INSERT INTO Authors(Name) VALUES(?)";

            pst = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            pst.setString(1, author);
            pst.executeUpdate();
            
            ResultSet rs = pst.getGeneratedKeys();
            
            if (rs.first()) {
                
                System.out.printf("The ID of new author: %d", rs.getLong(1));
            }

        } catch (SQLException ex) {
            
            Logger lgr = Logger.getLogger(JdbcAutoGenKey.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
                
                if (pst != null) {
                    pst.close();
                }
                
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                
                Logger lgr = Logger.getLogger(JdbcAutoGenKey.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> In the example, we add a new author to a table that has its primary key auto-incremented by MySQL. We retrieve the generated ID. </p> 
    <pre class="explanation">
pst = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
</pre> 
    <p> As the first step, we have to pass the <code>Statement.RETURN_GENERATED_KEYS</code> to the <code>prepareStatement()</code> method. </p> 
    <pre class="explanation">
ResultSet rs = pst.getGeneratedKeys();
</pre> 
    <p> Then we retrieve the generated key(s) with the <code>getGeneratedKeys()</code> method. </p> 
    <pre class="explanation">
if (rs.first()) {
    
    System.out.printf("The ID of new author: %d", rs.getLong(1));
}
</pre> 
    <p> Since we have only one insert statement, we use <code>first()</code> to navigate to the value. </p> 
    <h2>Writing images</h2> 
    <p> Some people prefer to put their images into the database, some prefer to keep them on the file system for their applications. Technical difficulties arise when we work with lots of images. Images are binary data. MySQL database has a special data type to store binary data called <code>BLOB</code> (Binary Large Object). </p> 
    <p> For this example, we use the <code>Images</code> table. </p> 
    <div class="codehead">
     WriteImage.java
    </div> 
    <pre class="code">
package com.zetcode.writeimage;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class WriteImage {

    public static void main(String[] args) throws FileNotFoundException,
            SQLException, IOException {

        Connection con = null;
        PreparedStatement pst = null;
        FileInputStream fin = null;

        String cs = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            File img = new File("woman.jpg");
            fin = new FileInputStream(img);

            con = DriverManager.getConnection(cs, user, password);

            pst = con.prepareStatement("INSERT INTO Images(Data) VALUES(?)");
            pst.setBinaryStream(1, fin, (int) img.length());
            pst.executeUpdate();

        } finally {

            if (pst != null) {
                pst.close();
            }
            
            if (con != null) {
                con.close();
            }
            
            if (fin != null) {
                fin.close();
            }
        }
    }
}
</pre> 
    <p> In the preceding example, we read a JPG image from the current working directory and insert in into the <code>Images</code> table. </p> 
    <pre class="explanation">
pst = con.prepareStatement("INSERT INTO Images(Data) VALUES(?)");
</pre> 
    <p> This is the SQL to insert an image. </p> 
    <pre class="explanation">
File img = new File("woman.jpg");
fin = new FileInputStream(img);
</pre> 
    <p> We create a <code>File</code> object for the image file. To read bytes from this file, we create a <code>FileInputStream</code> object. </p> 
    <pre class="explanation">
pst.setBinaryStream(1, fin, (int) img.length());
</pre> 
    <p> The binary stream is set to the prepared statement. The parameters of the <code>setBinaryStream()</code> method are the parameter index to bind, the input stream, and the number of bytes in the stream. </p> 
    <pre class="explanation">
pst.executeUpdate();
</pre> 
    <p> We execute the statement. </p> 
    <h2>Reading images</h2> 
    <p> In the previous example, we have inserted an image into the database table. Now we are going to read the image back from the table. </p> 
    <div class="codehead">
     ReadImage.java
    </div> 
    <pre class="code">
package com.zetcode.readimage;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.sql.Blob;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class ReadImage {

    public static void main(String[] args) throws SQLException,
            FileNotFoundException, IOException {

        Connection con = null;
        PreparedStatement pst = null;
        FileOutputStream fos = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(url, user, password);

            String query = "SELECT Data FROM Images LIMIT 1";
            pst = con.prepareStatement(query);

            ResultSet result = pst.executeQuery();
            result.next();

            fos = new FileOutputStream("woman2.jpg");

            Blob blob = result.getBlob("Data");
            int len = (int) blob.length();

            byte[] buf = blob.getBytes(1, len);

            fos.write(buf, 0, len);

        } finally {

            if (pst != null) {
                pst.close();
            }
            
            if (con != null) {
                con.close();
            }
            
            if (fos != null) {
                fos.close();
            }
        }
    }
}
</pre> 
    <p> We read one image from the Images table. </p> 
    <pre class="explanation">
String query = "SELECT Data FROM Images LIMIT 1";
</pre> 
    <p> We select one record from the table. </p> 
    <pre class="explanation">
fos = new FileOutputStream("woman2.jpg");
</pre> 
    <p> The <code>FileOutputStream</code> object is created to write to a file. It is meant for writing streams of raw bytes such as image data. </p> 
    <pre class="explanation">
Blob blob = result.getBlob("Data");
</pre> 
    <p> We get the image data from the <code>Data</code> column by calling the <code>getBlob()</code> method. </p> 
    <pre class="explanation">
int len = (int) blob.length();
</pre> 
    <p> We figure out the length of the blob data. In other words, we get the number of bytes. </p> 
    <pre class="explanation">
byte[] buf = blob.getBytes(1, len);
</pre> 
    <p> The <code>getBytes()</code> method retrieves all bytes of the Blob object, as an array of bytes. </p> 
    <pre class="explanation">
fos.write(buf, 0, len);
</pre> 
    <p> The bytes are written to the output stream. The image is created on the filesystem. </p> 
    <h2>Transaction support</h2> 
    <p> A <dfn>transaction</dfn> is an atomic unit of database operations against the data in one or more databases. The effects of all the SQL statements in a transaction can be either all committed to the database or all rolled back. </p> 
    <p> The MySQL database has different types of storage engines. The most common are the MyISAM and the InnoDB engines. There is a trade-off between data security and database speed. The MyISAM tables are faster to process and they do not support transactions. On the other hand, the InnoDB tables are more safe against the data loss. They support transactions and are slower to process. </p> 
    <div class="codehead">
     Transaction.java
    </div> 
    <pre class="code">
package com.zetcode.transaction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Transaction {

    public static void main(String[] args) {

        Connection con = null;
        Statement st = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(url, user, password);
            st = con.createStatement();

            con.setAutoCommit(false);

            st.executeUpdate("UPDATE Authors SET Name = 'Leo Tolstoy' "
                    + "WHERE Id = 1");
            st.executeUpdate("UPDATE Books SET Title = 'War and Peace' "
                    + "WHERE Id = 1");
            st.executeUpdate("UPDATE Books SET Titl = 'Anna Karenina' "
                    + "WHERE Id = 2");

            con.commit();

        } catch (SQLException ex) {

            if (con != null) {
                
                try {
                    
                    con.rollback();
                } catch (SQLException ex1) {
                    
                    Logger lgr = Logger.getLogger(Transaction.class.getName());
                    lgr.log(Level.WARNING, ex1.getMessage(), ex1);
                }
            }

            Logger lgr = Logger.getLogger(Transaction.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);
            
        } finally {

            try {
                if (st != null) {
                    st.close();
                }
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {

                Logger lgr = Logger.getLogger(Transaction.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> In this program, we want to change the name of the author on the first row of the <code>Authors</code> table. We must also change the books associated with this author. This is a good example where a transaction is necessary. If we change the author and do not change the author's books, the data is corrupted. </p> 
    <pre class="explanation">
con.setAutoCommit(false);
</pre> 
    <p> To work with transactions, we must set the autocommit mode to false. By default, a database connection is in autocommit mode. In this mode each statement is committed to the database as soon as it is executed. A statement cannot be undone. When the autocommit is turned off, we commit the changes by calling the <code>commit()</code> or roll it back by calling the <code>rollback()</code> method. </p> 
    <pre class="explanation">
st.executeUpdate("UPDATE Books SET Titl = 'Anna Karenina' "
        + "WHERE Id = 2");
</pre> 
    <p> The third SQL statement has an error. There is no Titl column in the table. </p> 
    <pre class="explanation">
con.commit();
</pre> 
    <p> If there is no exception, the transaction is committed. </p> 
    <pre class="explanation">
if (con != null) {
    
    try {
        
        con.rollback();
    } catch (SQLException ex1) {
        
        Logger lgr = Logger.getLogger(Transaction.class.getName());
        lgr.log(Level.WARNING, ex1.getMessage(), ex1);
    }
}
</pre> 
    <p> In case of an exception, the transaction is rolled back. No changes are committed to the database. </p> 
    <pre class="code">
$ java -cp bin:lib/* com.zetcode.transaction.Transaction 
Jun 27, 2016 1:04:38 PM com.zetcode.transaction.Transaction main
SEVERE: Unknown column 'Titl' in 'field list'
com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column 'Titl' in 'field list'
...

mysql&gt; SELECT Name, Title From Authors, Books WHERE Authors.Id=Books.AuthorId;
+-------------------+----------------------+
| Name              | Title                |
+-------------------+----------------------+
| Jack London       | Call of the Wild     |
| Jack London       | Martin Eden          |
| Honore de Balzac  | Old Goriot           |
| Honore de Balzac  | Cousin Bette         |
| Lion Feuchtwanger | Jew Suess            |
| Emile Zola        | Nana                 |
| Emile Zola        | The Belly of Paris   |
| Truman Capote     | In Cold blood        |
| Truman Capote     | Breakfast at Tiffany |
+-------------------+----------------------+
9 rows in set (0.01 sec)
</pre> 
    <p> An exception was thrown. The transaction was rolled back and no changes took place. </p> 
    <p> However, without a transaction, the data is not safe. </p> 
    <div class="codehead">
     NonTransaction.java
    </div> 
    <pre class="code">
package com.zetcode.nontransaction;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class NonTransaction {

    public static void main(String[] args) {

        Connection con = null;
        Statement st = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(url, user, password);
            st = con.createStatement();

            st.executeUpdate("UPDATE Authors SET Name = 'Leo Tolstoy' "
                    + "WHERE Id = 1");
            st.executeUpdate("UPDATE Books SET Title = 'War and Peace' "
                    + "WHERE Id = 1");
            st.executeUpdate("UPDATE Books SET Titl = 'Anna Karenina' "
                    + "WHERE Id = 2");

            con.close();

        } catch (SQLException ex) {

            Logger lgr = Logger.getLogger(NonTransaction.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {
                if (st != null) {
                    st.close();
                }
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {

                Logger lgr = Logger.getLogger(NonTransaction.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> We have the same example. This time, without the transaction support. </p> 
    <pre class="code">
$ java -cp bin:lib/* com.zetcode.nontransaction.NonTransaction 
Jun 27, 2016 1:10:22 PM com.zetcode.nontransaction.NonTransaction main
SEVERE: Unknown column 'Titl' in 'field list'
com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column 'Titl' in 'field list'
...

mysql&gt; SELECT Name, Title From Authors, Books WHERE Authors.Id=Books.AuthorId;
+-------------------+----------------------+
| Name              | Title                |
+-------------------+----------------------+
| Leo Tolstoy       | War and Peace        |
| Leo Tolstoy       | Martin Eden          |
| Honore de Balzac  | Old Goriot           |
| Honore de Balzac  | Cousin Bette         |
| Lion Feuchtwanger | Jew Suess            |
| Emile Zola        | Nana                 |
| Emile Zola        | The Belly of Paris   |
| Truman Capote     | In Cold blood        |
| Truman Capote     | Breakfast at Tiffany |
+-------------------+----------------------+
9 rows in set (0.00 sec)
</pre> 
    <p> An exception is thrown again. Leo Tolstoy did not write Martin Eden; the data is corrupted. </p> 
    <h2>Batch updates</h2> 
    <p> When we need to update data with multiple statements, we can use batch updates. Batch updates are available for <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, statements as well as for <code>CREATE TABLE</code> and <code>DROP TABLE</code> statements. </p> 
    <div class="codehead">
     BatchUpdate.java
    </div> 
    <pre class="code">
package com.zetcode.batchupdate;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import java.util.logging.Logger;

public class BatchUpdate {

    public static void main(String[] args) {

        Connection con = null;
        Statement st = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(url, user, password);

            con.setAutoCommit(false);
            st = con.createStatement();

            st.addBatch("DELETE FROM Authors");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(1, 'Jack London')");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(2, 'Honore de Balzac')");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(3, 'Lion Feuchtwanger')");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(4, 'Emile Zola')");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(5, 'Truman Capote')");
            st.addBatch("INSERT INTO Authors(Id, Name) VALUES(6, 'Umberto Eco')");

            int counts[] = st.executeBatch();

            con.commit();

            System.out.println("Committed " + counts.length + " updates");

        } catch (SQLException ex) {

            if (con != null) {

                try {

                    con.rollback();
                } catch (SQLException ex1) {

                    Logger lgr = Logger.getLogger(BatchUpdate.class.getName());
                    lgr.log(Level.WARNING, ex1.getMessage(), ex1);
                }
            }

            Logger lgr = Logger.getLogger(BatchUpdate.class.getName());
            lgr.log(Level.SEVERE, ex.getMessage(), ex);

        } finally {

            try {

                if (st != null) {
                    st.close();
                }
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {

                Logger lgr = Logger.getLogger(BatchUpdate.class.getName());
                lgr.log(Level.WARNING, ex.getMessage(), ex);
            }
        }
    }
}
</pre> 
    <p> This is an example program for a batch update. We delete all data from the Authors table and insert new data. We add one new author, Umberto Eco to see the changes. </p> 
    <pre class="explanation">
st.addBatch("DELETE FROM Authors");
st.addBatch("INSERT INTO Authors(Id, Name) VALUES(1, 'Jack London')");
st.addBatch("INSERT INTO Authors(Id, Name) VALUES(2, 'Honore de Balzac')");
st.addBatch("INSERT INTO Authors(Id, Name) VALUES(3, 'Lion Feuchtwanger')");
...
</pre> 
    <p> We use teh <code>addBatch()</code> method to add a new command to the statement. </p> 
    <pre class="explanation">
int counts[] = st.executeBatch();
</pre> 
    <p> After adding all commands, we call the <code>executeBatch()</code> to perform a batch update. The method returns an array of committed changes. </p> 
    <pre class="explanation">
con.commit();
</pre> 
    <p> Batch updates are committed in a transaction. </p> 
    <pre>
$ java -cp bin:lib/* com.zetcode.batchupdate.BatchUpdate 
Committed 7 updates

mysql&gt; SELECT * FROM Authors;
+----+-------------------+
| Id | Name              |
+----+-------------------+
|  1 | Jack London       |
|  2 | Honore de Balzac  |
|  3 | Lion Feuchtwanger |
|  4 | Emile Zola        |
|  5 | Truman Capote     |
|  6 | Umberto Eco       |
+----+-------------------+
6 rows in set (0.00 sec)
</pre> 
    <p> We execute the <code>BatchUpdate</code> program. The <code>SELECT</code> statement shows that the <code>Authors</code> table was successfully updated. It has a new author, Umerto Eco. </p> 
    <h2>Exporting data to a CSV file</h2> 
    <p> The next example exports data into a CSV file. </p> 
    <p> We need to have proper file permissions for our <code>testuser</code>; otherwise, we get access denied error message. </p> 
    <pre>
mysql&gt; GRANT FILE ON *.* TO 'testuser'@'localhost';
</pre> 
    <p> We set the <code>FILE</code> permission. </p> 
    <div class="codehead">
     ExportCSV.java
    </div> 
    <pre class="code">
package com.zetcode.exportcsv;

import java.sql.PreparedStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ExportCSV {

    public static void main(String[] args) throws SQLException {

        Connection con = null;
        PreparedStatement pst = null;

        String url = "jdbc:mysql://localhost:3306/testdb";
        String user = "testuser";
        String password = "test623";

        try {

            con = DriverManager.getConnection(url, user, password);
            String query = "SELECT Name, Title INTO OUTFILE '/tmp/authors_books.csv' "
                    + "FIELDS TERMINATED BY ',' FROM Authors, Books WHERE "
                    + "Authors.Id=Books.AuthorId";
            
            pst = con.prepareStatement(query);
            pst.execute();

        } finally {

            if (pst != null) {
                pst.close();
            }

            if (con != null) {
                con.close();
            }

        }
    }
}
</pre> 
    <p> We export the authors and their corresponding books to the <code>/tmp/authors_books.csv</code> file. </p> 
    <pre class="explanation">
String query = "SELECT Name, Title INTO OUTFILE '/tmp/authors_books.csv' "
        + "FIELDS TERMINATED BY ',' FROM Authors, Books WHERE "
        + "Authors.Id=Books.AuthorId";
</pre> 
    <p> To export data into a file, we use the <code>SELECT INTO OUTFILE</code> SQL statement. </p> 
    <pre>
$ cat /tmp/authors_books.csv 
Jack London,Call of the Wild
Jack London,Martin Eden
Honore de Balzac,Old Goriot
Honore de Balzac,Cousin Bette
Lion Feuchtwanger,Jew Suess
Emile Zola,Nana
Emile Zola,The Belly of Paris
Truman Capote,In Cold blood
Truman Capote,Breakfast at Tiffany
</pre> 
    <p> We verify the data. </p> 
    <p> This was the MySQL Java tutorial. You might be also interested in <a href="/db/jdbi/">JDBI tutorial</a>, <a href="/db/postgresqljavatutorial/">PostgreSQL Java tutorial</a>, <a href="/db/mongodbjava/">MongoDB Java tutorial</a>, or <a href="/databases/mysqltutorial/">MySQL tutorial</a>. </p> 
    <div class="big_hor"> 
     <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> 
     <!-- big_horizontal --> 
     <ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-9706709751191532" data-ad-slot="2904953388"></ins> 
     <script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script> 
    </div> 
    <footer> 
     <nav> 
      <a href="/">Home</a> 
      <a href="#">Top of Page</a> 
     </nav> 
     <div class="signature"> 
      <a href="/">ZetCode</a> last modified April 9, 2017 
      <span class="copyright"> 2007 - 2017 Jan Bodnar</span> 
      <span>Follow on <a href="https://www.facebook.com/zetcode7/">Facebook</a></span> 
     </div> 
    </footer> 
   </div> 
   <!-- content --> 
  </div> 
  <!-- container --> 
  <!-- Silktide Cookie --> 
  <script>
    window.cookieconsent_options = {"message":"This website uses cookies to ensure you get the best experience on our website",
    "dismiss":"Got it!","learnMore":"More info","link":null,"theme":"dark-floating"};
</script> 
  <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.9/cookieconsent.min.js"></script> 
  <div id="fb-root"></div> 
  <script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>   
 </body>
</html>