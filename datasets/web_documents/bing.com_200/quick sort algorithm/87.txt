<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
 <head> 
  <script type="text/javascript">var _sf_startpt=(new Date()).getTime()</script> 
  <link rel="icon" type="image/png" href="https://d3b9owkrfo5lcv.cloudfront.net/favicon.ico"> 
  <link type="text/css" rel="stylesheet" href="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Styles/SyntaxHighlighter.css"> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shCoreMods.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushCpp.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushCSharp.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushCss.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushDelphi.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushJava.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushJScript.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushPhp.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushPython.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushRuby.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushSql.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushVb.js"></script> 
  <script type="text/javascript" src="https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/shBrushXml.js"></script> 
  <script type="text/javascript">dp.SyntaxHighlighter.ClipboardSwf = 'https://s3.amazonaws.com/file.codecodex.com/js/syntaxhighlighter/Scripts/clipboard.swf';</script> 
  <meta name="verify-v1" content="mqCKG4/RMa40CfRqt6TMpAAQzrC+JPrRIMiY6McWVPk="> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
  <meta name="generator" content="MediaWiki 1.23alpha"> 
  <link rel="alternate" type="application/x-wiki" title="Edit" href="/wiki/index.php?title=Quicksort&amp;action=edit"> 
  <link rel="edit" title="Edit" href="/wiki/index.php?title=Quicksort&amp;action=edit"> 
  <link rel="shortcut icon" href="/favicon.ico"> 
  <link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="CodeCodex (en)"> 
  <link rel="EditURI" type="application/rsd+xml" href="http://www.codecodex.com/wiki/api.php?action=rsd"> 
  <link rel="alternate" type="application/atom+xml" title="CodeCodex Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom"> 
  <title>Quicksort</title> 
  <style type="text/css" media="screen,projection">/*<![CDATA[*/ @import "https://s3.amazonaws.com/file.codecodex.com/cavendish/main.css"; /*]]>*/</style> 
  <link rel="stylesheet" type="text/css" media="print" href="/skins/common/commonPrint.css"> 
  <script type="text/javascript" src="/skins/common/wikibits.js"></script> 
  <!-- google analytics --> 
  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-433739-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script> 
 </head> 
 <body onload="dp.SyntaxHighlighter.HighlightAll('code');"> 
  <div id="internal"></div> 
  <div id="container"> 
   <div id="header"> 
    <a name="top" id="contentTop"></a> 
    <h1><a href="/wiki/Main_Page" title="Main Page">Quicksort</a></h1> 
    <ul> 
     <li class="selected"><a href="/wiki/Quicksort">Page</a></li>
     <li class="new"><a href="/wiki/index.php?title=Talk:Quicksort&amp;action=edit&amp;redlink=1">Discussion</a></li>
     <li><a href="/wiki/index.php?title=Quicksort&amp;action=edit">Edit</a></li>
     <li><a href="/wiki/index.php?title=Quicksort&amp;action=history">History</a></li> 
    </ul> 
    <form name="searchform" action="/wiki/Special:Search" id="search"> 
     <div> 
      <label for="q">Search</label> 
      <input id="q" name="search" type="text" accesskey="f" value=""> 
      <input type="submit" name="go" class="searchButton" id="searchGoButton" value="Go">&nbsp;
      <input type="submit" name="fulltext" class="searchButton" value="Search"> 
     </div> 
    </form> 
   </div> 
   <div id="mBody"> 
    <div id="side"> 
     <ul id="nav"> 
      <li><span>Personal tools</span> 
       <ul> 
        <li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Quicksort">Log in</a></li> 
       </ul> </li> 
      <li><span>Navigation</span> 
       <ul> 
        <li id="n-mainpage"><a href="/wiki/Main_Page">Main Page</a></li> 
        <li id="n-portal"><a href="/wiki/CodeCodex:Community_portal">Community portal</a></li> 
        <li id="n-recentchanges"><a href="/wiki/Special:RecentChanges">Recent changes</a></li> 
        <li id="n-randompage"><a href="/wiki/Special:Random">Random page</a></li> 
       </ul> </li> 
      <li><span>Largest Languages</span> 
       <ul> 
        <li id="n-Java"><a href="/wiki/Category:Java">Java</a></li> 
        <li id="n-C"><a href="/wiki/Category:C">C</a></li> 
        <li id="n-OCaml"><a href="/wiki/Category:Objective_Caml">OCaml</a></li> 
        <li id="n-Perl"><a href="/wiki/Category:Perl">Perl</a></li> 
       </ul> </li> 
      <li><span>Tools</span> 
       <ul> 
        <li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Quicksort">What links here</a></li> 
        <li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Quicksort">Related changes</a></li> 
        <li id="t-specialpages"><a href="/wiki/Special:SpecialPages">Special pages</a></li> 
       </ul> </li> 
     </ul> 
     <!--
<ul id="ad">
  <div style="padding: 10px;">
    <span style="color: black; font-weight: bold;">Students:</span>
    <p>Stuck on your homework?  <a href="http://www.liveperson.com/experts/computers-programming/p1-sortby-9/?desid=45&amp;ver=1.00&amp;img=177&amp;kbid=4447&amp;sub=TL&amp;twid=3" onclick="window.location.href='http://www.liveperson.com/experts/computers-programming/p1-sortby-9/?desid=45&amp;ver=1.00&amp;img=177&amp;kbid=4447&amp;sub=TL&amp;twid=3'">Get paid homework assistance and tutoring from LivePerson.com</a>.<br/><br/>
   <button onclick="window.location.href='http://www.liveperson.com/experts/computers-programming/p1-sortby-9/?desid=45&amp;ver=1.00&amp;img=177&amp;kbid=4447&amp;sub=TL&amp;twid=3'" style="float: right;">Get Help Now</button>
    <span style="float: left; font-size: 0.7em; font-weight: normal; color: rgb(102, 102, 102);">(advertisment)</span>
    <div style="clear: both;"> </div>
  </div>
</ul>--> 
    </div>
    <!-- end of SIDE div --> 
    <div id="mainContent"> 
     <h1>Quicksort</h1> 
     <h3 id="siteSub">From CodeCodex</h3> 
     <div id="contentSub"></div> 
     <!-- start content --> 
     <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
      <table style="width: 20em; float:right; border: 1px solid #cfcfbf; clear:right; background-color: #f0f0ff; height:1%; padding: .5em 1em 1em; text-align: left; vertical-align: top; font-size:95%; margin:1px"> 
       <tbody>
        <tr> 
         <td> <b>Related content:</b> </td>
        </tr> 
        <tr> 
         <td> 
          <ul> 
           <li> <a href="/wiki/Bogosort" title="Bogosort">Bogosort</a> </li> 
           <li> <a href="/wiki/Bubble_sort" title="Bubble sort">Bubble sort</a> </li> 
           <li> <a href="/wiki/Heapsort" title="Heapsort">Heapsort</a> </li> 
           <li> <a href="/wiki/Introsort" title="Introsort">Introsort</a> </li> 
           <li> <a href="/wiki/Insertion_sort" title="Insertion sort">Insertion sort</a> </li> 
           <li> <a href="/wiki/Merge_sort" title="Merge sort">Merge sort</a> </li> 
           <li> <strong class="selflink">Quicksort</strong> </li> 
           <li> <a href="/wiki/Selection_sort" title="Selection sort">Selection sort</a> </li> 
           <li> <a href="/wiki/Shell_sort" title="Shell sort">Shell sort</a> </li> 
           <li> <a href="/wiki/Sort_an_array" title="Sort an array">Sort an array</a> </li> 
          </ul> </td>
        </tr>
       </tbody>
      </table> 
      <div id="toc" class="toc">
       <div id="toctitle">
        <h2>Contents</h2>
       </div> 
       <ul> 
        <li class="toclevel-1 tocsection-1"><a href="#Implementations"><span class="tocnumber">1</span> <span class="toctext">Implementations</span></a> 
         <ul> 
          <li class="toclevel-2 tocsection-2"><a href="#Pseudocode"><span class="tocnumber">1.1</span> <span class="toctext">Pseudocode</span></a></li> 
          <li class="toclevel-2 tocsection-3"><a href="#AppleScript"><span class="tocnumber">1.2</span> <span class="toctext">AppleScript</span></a></li> 
          <li class="toclevel-2 tocsection-4"><a href="#AutoIt_v3"><span class="tocnumber">1.3</span> <span class="toctext">AutoIt v3</span></a></li> 
          <li class="toclevel-2 tocsection-5"><a href="#C"><span class="tocnumber">1.4</span> <span class="toctext">C</span></a></li> 
          <li class="toclevel-2 tocsection-6"><a href="#C.2B.2B"><span class="tocnumber">1.5</span> <span class="toctext">C++</span></a></li> 
          <li class="toclevel-2 tocsection-7"><a href="#C.23"><span class="tocnumber">1.6</span> <span class="toctext">C#</span></a></li> 
          <li class="toclevel-2 tocsection-8"><a href="#Common_Lisp"><span class="tocnumber">1.7</span> <span class="toctext">Common Lisp</span></a></li> 
          <li class="toclevel-2 tocsection-9"><a href="#D"><span class="tocnumber">1.8</span> <span class="toctext">D</span></a></li> 
          <li class="toclevel-2 tocsection-10"><a href="#Delphi"><span class="tocnumber">1.9</span> <span class="toctext">Delphi</span></a></li> 
          <li class="toclevel-2 tocsection-11"><a href="#Erlang"><span class="tocnumber">1.10</span> <span class="toctext">Erlang</span></a></li> 
          <li class="toclevel-2 tocsection-12"><a href="#Haskell"><span class="tocnumber">1.11</span> <span class="toctext">Haskell</span></a></li> 
          <li class="toclevel-2 tocsection-13"><a href="#J"><span class="tocnumber">1.12</span> <span class="toctext">J</span></a></li> 
          <li class="toclevel-2 tocsection-14"><a href="#Java"><span class="tocnumber">1.13</span> <span class="toctext">Java</span></a> 
           <ul> 
            <li class="toclevel-3 tocsection-15"><a href="#another"><span class="tocnumber">1.13.1</span> <span class="toctext">another</span></a></li> 
           </ul> </li> 
          <li class="toclevel-2 tocsection-16"><a href="#JavaScript"><span class="tocnumber">1.14</span> <span class="toctext">JavaScript</span></a></li> 
          <li class="toclevel-2 tocsection-17"><a href="#Mathematica"><span class="tocnumber">1.15</span> <span class="toctext">Mathematica</span></a></li> 
          <li class="toclevel-2 tocsection-18"><a href="#MATLAB"><span class="tocnumber">1.16</span> <span class="toctext">MATLAB</span></a></li> 
          <li class="toclevel-2 tocsection-19"><a href="#Miranda"><span class="tocnumber">1.17</span> <span class="toctext">Miranda</span></a></li> 
          <li class="toclevel-2 tocsection-20"><a href="#OCaml"><span class="tocnumber">1.18</span> <span class="toctext">OCaml</span></a></li> 
          <li class="toclevel-2 tocsection-21"><a href="#Perl"><span class="tocnumber">1.19</span> <span class="toctext">Perl</span></a></li> 
          <li class="toclevel-2 tocsection-22"><a href="#Perl_6"><span class="tocnumber">1.20</span> <span class="toctext">Perl 6</span></a></li> 
          <li class="toclevel-2 tocsection-23"><a href="#PHP"><span class="tocnumber">1.21</span> <span class="toctext">PHP</span></a></li> 
          <li class="toclevel-2 tocsection-24"><a href="#Prolog"><span class="tocnumber">1.22</span> <span class="toctext">Prolog</span></a></li> 
          <li class="toclevel-2 tocsection-25"><a href="#Python"><span class="tocnumber">1.23</span> <span class="toctext">Python</span></a></li> 
          <li class="toclevel-2 tocsection-26"><a href="#Ruby"><span class="tocnumber">1.24</span> <span class="toctext">Ruby</span></a></li> 
          <li class="toclevel-2 tocsection-27"><a href="#Scheme"><span class="tocnumber">1.25</span> <span class="toctext">Scheme</span></a></li> 
          <li class="toclevel-2 tocsection-28"><a href="#Seed7"><span class="tocnumber">1.26</span> <span class="toctext">Seed7</span></a></li> 
          <li class="toclevel-2 tocsection-29"><a href="#Standard_ML"><span class="tocnumber">1.27</span> <span class="toctext">Standard ML</span></a></li> 
          <li class="toclevel-2 tocsection-30"><a href="#Tcl"><span class="tocnumber">1.28</span> <span class="toctext">Tcl</span></a></li> 
          <li class="toclevel-2 tocsection-31"><a href="#TorqueScript"><span class="tocnumber">1.29</span> <span class="toctext">TorqueScript</span></a></li> 
          <li class="toclevel-2 tocsection-32"><a href="#Visual_Basic"><span class="tocnumber">1.30</span> <span class="toctext">Visual Basic</span></a></li> 
          <li class="toclevel-2 tocsection-33"><a href="#Visual_Basic_for_Applications"><span class="tocnumber">1.31</span> <span class="toctext">Visual Basic for Applications</span></a></li> 
          <li class="toclevel-2 tocsection-34"><a href="#Zilog_Z80000_Assembly"><span class="tocnumber">1.32</span> <span class="toctext">Zilog Z80000 Assembly</span></a></li> 
         </ul> </li> 
       </ul> 
      </div> 
      <h2><span class="mw-headline" id="Implementations">Implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=1" title="Edit section: Implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h2> 
      <h3><span class="mw-headline" id="Pseudocode">Pseudocode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=2" title="Edit section: Pseudocode">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre>function quicksort(array)
    var list less, equal, greater
    if length(array) ? 1  
        return array  
    select a pivot value pivot from array
    for each x in array
        if x &lt; pivot then append x to less
        if x = pivot then append x to equal
        if x &gt; pivot then append x to greater
    return concatenate(quicksort(less), equal, quicksort(greater))
</pre> 
      <p>It's about time somoene wrote about this. </p> 
      <h3><span class="mw-headline" id="AppleScript"><a href="http://en.wikipedia.org/wiki/AppleScript" class="extiw" title="wikipedia:AppleScript">AppleScript</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=3" title="Edit section: AppleScript">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This is a straightforward implementation. It is certainly possible to come up with a more efficient one, but it will probably not be as clear as this one: </p> 
      <code><pre>
 on sort( array, left, right )
     set i to left
     set j to right
     set v to item ( ( left + right ) div 2 ) of array -- pivot
     repeat while ( j &gt; i )
         repeat while ( item i of array &lt; v )
             set i to i + 1
         end repeat
         repeat while ( item j of array &gt; v )
             set j to j - 1
         end repeat
         if ( not i &gt; j ) then
             tell array to set { item i, item j } to { item j, item i } -- swap
             set i to i + 1
             set j to j - 1
         end if
     end repeat 
     if ( left  &lt; j ) then sort( array, left, j  )
     if ( right &gt; i ) then sort( array, i, right )
 end sort
</pre></code> 
      <p>Hey, you're the goto exerpt. Thanks for hanging out here. </p> 
      <h3><span class="mw-headline" id="AutoIt_v3"><a href="http://en.wikipedia.org/wiki/AutoIt" class="extiw" title="wikipedia:AutoIt">AutoIt</a> v3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=4" title="Edit section: AutoIt v3">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This is a straightforward implementation based on the AppleScript example. It is certainly possible to come up with a more efficient one, but it will probably not be as clear as this one: </p> 
      <code><pre>
  Func sort( ByRef $array, $left, $right )
    $i = $left
    $j = $right
    $v = $array[Int( ( $left + $right ) / 2)]
    While ( $j &gt; $i )
        While ($array[$i] &lt; $v )
            $i = $i + 1
        WEnd
        While ( $array[$j] &gt; $v )
            $j = $j - 1
        WEnd
        If ( NOT ($i &gt; $j) ) then
            swap($array[$i], $array[$j])
            $i = $i + 1
            $j = $j - 1
        EndIf
    WEnd
    if ( $left  &lt; $j ) then sort( $array, $left, $j  )
    if ( $right &gt; $i ) then sort( $array, $i, $right )
  EndFunc
</pre></code> 
      <h3><span class="mw-headline" id="C"><a href="http://en.wikipedia.org/wiki/C_programming_language" class="extiw" title="wikipedia:C programming language">C</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=5" title="Edit section: C">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The function <code>qsort()</code> in the C standard library can be used to sort arrays of any data type. Its use should be preferred in real code. The following implementations serve as an academic exercise. </p>
      <p>The following implementation works with any data type, given its size and a function that compares it. This is similar to what ISO/POSIX compliant C standard libraries provide: </p> 
      <code><pre class="c">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

static void swap(void *x, void *y, size_t l) {
   char *a = x, *b = y, c;
   while(l--) {
      c = *a;
      *a++ = *b;
      *b++ = c;
   }
}

static void sort(char *array, size_t size, int (*cmp)(void*,void*), int begin, int end) {
   if (end &gt; begin) {
      void *pivot = array + begin;
      int l = begin + size;
      int r = end;
      while(l &lt; r) {
         if (cmp(array+l,pivot) &lt;= 0) {
            l += size;
         } else {
            r -= size;
            swap(array+l, array+r, size);
         }
      }
      l -= size;
      swap(array+begin, array+l, size);
      sort(array, size, cmp, begin, l);
      sort(array, size, cmp, r, end);
   }
}

void qsort(void *array, size_t nitems, size_t size, int (*cmp)(void*,void*)) {
   sort(array, size, cmp, 0, (nitems-1)*size);
}

typedef int type;

int type_cmp(void *a, void *b){ return (*(type*)a)-(*(type*)b); }

main(){ /* simple test case for type=int */
  int num_list[]={5,4,3,2,1};
  int len=sizeof(num_list)/sizeof(type);
  char *sep="";
  int i;
  qsort(num_list,len,sizeof(type),type_cmp);
  printf("sorted_num_list={");
  for(i=0; i&lt;len; i++){
    printf("%s%d",sep,num_list[i]);
    sep=", ";
  }
  printf("};\n");
}
</pre></code> 
      <p>Result: </p> 
      <pre>sorted_num_list={2, 3, 4, 5, 1};
</pre> 
      <p>Here's yet another version with various other improvements: </p> 
      <code><pre class="c">
/*****   macros create functional code   *****/
#define pivot_index() (begin+(end-begin)/2)
#define swap(a,b,t) ((t)=(a),(a)=(b),(b)=(t))

void sort(int array[], int begin, int end) {
   /*** Use of static here will reduce memory footprint, but will make it thread-unsafe ***/
   static int pivot;
   static int t;     /* temporary variable for swap */
   if (end &gt; begin) {
      int l = begin + 1;
      int r = end;
      swap(array[begin], array[pivot_index()], t); /*** choose arbitrary pivot ***/
      pivot = array[begin];
      while(l &lt; r) {
         if (array[l] &lt;= pivot) {
            l++;
         } else {
            while(l &lt; --r &amp;&amp; array[r] &gt;= pivot) /*** skip superfluous swaps ***/
              &nbsp;;
            swap(array[l], array[r], t); 
         }
      }
      l--;
      swap(array[begin], array[l], t);
      sort(array, begin, l);
      sort(array, r, end);
   }
}

#undef swap
#undef pivot_index
</pre></code> 
      <p>An alternate simple C quicksort. The first C implementation above does not sort the list properly if the initial input is a reverse sorted list, or any time in which the pivot turns out be the largest element in the list. Here is another sample quick sort implementation that does address these issues. Note that the swaps are done inline in this implementation. They may be replaced with a swap function as in the above examples. </p> 
      <code><pre class="c">
void qsort(int arr[], int beg, int end) 
{
   int temp;
   if (end &gt; beg) 
   {
      int piv = arr[beg], l = beg + 1, r = end;
      while (l &lt; r) 
      {
         if (arr[l] &lt;= piv) 
            l++;
	 else if(arr[r] &gt;= piv)
	    r--;
         else 
         {
	    temp = arr[l];
	    arr[l] = arr[r];
  	    arr[r] = temp;
	 }
      }
      if(arr[l] &lt; piv)
      {
         temp = arr[l];
	 arr[l] = arr[beg];
	 arr[beg] = temp;
	 l--;
      } 
      else
      {
         l--;
	 temp = arr[l];
	 arr[l] = arr[beg];
	 arr[beg] = temp;
      }
      qsort(arr, beg, l);
      qsort(arr, r, end);
   }
}
</pre></code> 
      <p>This sorts an array of integers using quicksort with in-place partition. </p> 
      <code><pre class="c">
 void quicksort(int x[], int first, int last) {
     int pivIndex = 0;
     if(first &lt; last) {
         pivIndex = partition(x,first, last);
         quicksort(x,first,(pivIndex-1));
         quicksort(x,(pivIndex+1),last);
     }
 }

 int partition(int y[], int f, int l) {
     int up,down,temp;
     int piv = y[f];
     up = f;
     down = l;
     goto partLS;
     do { 
         temp = y[up];
         y[up] = y[down];
         y[down] = temp;
     partLS:
         while (y[up] &lt;= piv &amp;&amp; up &lt; l) {
             up++;
         }
         while (y[down] &gt; piv  &amp;&amp; down &gt; f ) {
             down--;
         }
     } while (down &gt; up);
     y[f] = y[down];
     y[down] = piv;
     return down;
 }
</pre></code> 
      <p><br> The following sample of C code can be compiled to sort a vector of strings (defined as char *list[ ]), integers, doubles, etc. This piece of code implements a mixed iterative-recursive strategy that avoids out of stack risks even in worst case. It runs faster than the standard C lib function qsort(), expecially when used with partially sorted arrays (compiled with free Borland bcc32 and tested with 1 million strings vector). </p> 
      <code><pre class="c">
/********** QuickSort(): sorts the vector 'list[]' **********/

/**** Compile QuickSort for strings ****/
#define QS_TYPE char*
#define QS_COMPARE(a,b) (strcmp((a),(b)))

/**** Compile QuickSort for integers ****/
//#define QS_TYPE int
//#define QS_COMPARE(a,b) ((a)-(b))

/**** Compile QuickSort for doubles, sort list in inverted order ****/
//#define QS_TYPE double
//#define QS_COMPARE(a,b) ((b)-(a))

void QuickSort(QS_TYPE list[], int beg, int end)
{
    QS_TYPE piv; QS_TYPE tmp;
    
    int  l,r,p;

    while (beg&lt;end)    // This while loop will avoid the second recursive call
    {
        l = beg; p = (beg+end)/2; r = end;

        piv = list[p];

        while (1)
        {
            while ( (l&lt;=r) &amp;&amp; ( QS_COMPARE(list[l],piv) &lt;= 0 ) ) l++;
            while ( (l&lt;=r) &amp;&amp; ( QS_COMPARE(list[r],piv)  &gt; 0 ) ) r--;

            if (l&gt;r) break;

            tmp=list[l]; list[l]=list[r]; list[r]=tmp;

            if (p==r) p=l;
            
            l++; r--;
        }

        list[p]=list[r]; list[r]=piv;
        r--;

        // Recursion on the shorter side &amp; loop (with new indexes) on the longer
        if ((r-beg)&lt;(end-l))   
        {
            QuickSort(list, beg, r);
            beg=l;
        }
        else
        {
            QuickSort(list, l, end);
            end=r;
        }
    }   
}
</pre></code> 
      <h3><span class="mw-headline" id="C.2B.2B"><a href="http://en.wikipedia.org/wiki/C_plus_plus" class="extiw" title="wikipedia:C plus plus">C++</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=6" title="Edit section: C++">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This is a generic, STL-based version of quicksort. </p> 
      <pre><i>#include &lt;functional&gt;</i>
<i>#include &lt;algorithm&gt;</i>
<i>#include &lt;iterator&gt;</i>

<b>template</b>&lt; typename BidirectionalIterator, typename Compare &gt;
<b>void</b> quick_sort( BidirectionalIterator first, BidirectionalIterator last, Compare cmp ) {
  <b>if</b>( first&nbsp;!= last ) {
    BidirectionalIterator left  = first;
    BidirectionalIterator right = last;
    BidirectionalIterator pivot = left++;

    <b>while</b>( left&nbsp;!= right ) {
      <b>if</b>( cmp( *left, *pivot ) ) {
         ++left;
      } <b>else</b> {
         <b>while</b>( (left&nbsp;!= right) &amp;&amp; cmp( *pivot, *right ) )
           --right;
         std::iter_swap( left, right );
      }
    }

    --left;
    std::iter_swap( first, left );

    quick_sort( first, left, cmp );
    quick_sort( right, last, cmp );
  }
}

<b>template</b>&lt; typename BidirectionalIterator &gt;
<b>inline</b> <b>void</b> quick_sort( BidirectionalIterator first, BidirectionalIterator last ) {
  quick_sort( first, last,
    std::less_equal&lt; typename std::iterator_traits&lt; BidirectionalIterator &gt;::value_type &gt;()
  );
}
</pre> 
      <p>Here's a shorter version than the one in the core implementations section which takes advantage of the standard library's partition() function: </p> 
      <code><pre class="c++">
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;

template &lt;typename T&gt;
void sort(T begin, T end) {
    if (begin&nbsp;!= end) {
        T middle = partition (begin, end, bind2nd(
                less&lt;iterator_traits&lt;T&gt;::value_type&gt;(), *begin));
        sort (begin, middle);
        sort (max(begin + 1, middle), end);
    }
}
</pre></code> 
      <h3><span class="mw-headline" id="C.23"><a href="http://en.wikipedia.org/wiki/C_Sharp" class="extiw" title="wikipedia:C Sharp">C#</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=7" title="Edit section: C#">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The following C# implementation uses a random pivot and is limited to integer arrays; for other value types, replace all instances of int[] with the appropriate type (for example, decimal[]). For object[] comparison, create a delegate to your custom object compare function and pass it as an added parameter to both methods: </p> 
      <code><pre class="c#">
class Quicksort {
	private void swap(int[] Array, int Left, int Right) {
                int temp = Array[Right];
                Array[Right] = Array[Left];
                Array[Left] = temp;
        }

	public void sort(int[] Array, int Left, int Right) {
		int LHold = Left;
		int RHold = Right;
		Random ObjRan = new Random();
		int    Pivot  = ObjRan.Next(Left,Right);
		swap(Array,Pivot,Left);
		Pivot = Left;
		Left++;

		while (Right &gt;= Left) {
			if (Array[Left] &gt;= Array[Pivot]
			    &amp;&amp; Array[Right] &lt; Array[Pivot])
				swap(Array, Left, Right);
			else if (Array[Left] &gt;= Array[Pivot])
				Right--;
			else if (Array[Right] &lt; Array[Pivot])
				Left++;
			else {
				Right--;
				Left++;
		}	}	
		swap(Array, Pivot, Right);
		Pivot = Right;	
		if (Pivot &gt; LHold)
			sort(Array, LHold,   Pivot);
		if (RHold &gt; Pivot+1)
			sort(Array, Pivot+1, RHold);
}	}
</pre></code> 
      <p>Example of QuickSort using delegates. Pass the array of objects in the constructor of the class. For comparing other type of objects rewrite your own compare function instead of CompareInt. </p> 
      <code><pre class="c#">
class QuickSort {
	private delegate int CmpOp(object Left, object Right);
	private void swap(object[] Array, int Left, int Right, CmpOp Cmp) {
			object tempObj = Array[Left];
			Array[Left]    = Array[Right];
			Array[Right]   = tempObj;
	}
	private int CmpInt(object Left, object Right) {
		if ((int) Left &lt; (int) Right)
			return -1;
		else 
			return -2;
	}
	public QuickSort(object[] Array) {
		CmpOp Cmp = new CmpOp(CmpInt);
		Sort(Array, 0, Array.Length-1, Cmp);			
	}
	private void Sort(object[] Array, int Left, int Right, CmpOp Cmp) {
		int LHold = Left;
		int RHold = Right;
		Random ObjRan = new Random();
		int Pivot = ObjRan.Next(Left,Right);
		swap(Array, Pivot, Left, Cmp);
		Pivot = Left;
		Left++;

		while (Right &gt;= Left) {
			if (Cmp(Array[Left], Array[Pivot])!= -1
			    &amp;&amp; Cmp(Array[Right], ArrObj[Pivot])== -1)
				swap(Array, Left, Right, Cmp);
			else if (Cmp(Array[Left], Array[Pivot])&nbsp;!= -1)
				Right--;
			else if (Cmp(Array[Right],Array[Pivot]) == -1)
				Left++;
			else {
				Right--;
				Left++;
		}       }	
		swap(Array, Pivot, Right, Cmp);
		Pivot = Right;

		if (Pivot &gt; LHold)
			Sort(Array, LHold,  Pivot, Cmp);
		if (RHold &gt; Pivot+1)
			Sort(Array, Pivot+1,RHold, Cmp);
}	}
</pre></code> 
      <p>The following is an example of using QuickSort to sort an array of strings. </p> 
      <code><pre class="c#">
class Quicksort {
	private void quickSwap(string[] Array, int Left, int Right) 
	{
		string Temp = Array[Right];
		Array[Right] = Array[Left];
		Array[Left] = Temp;
	}

	public void quickSort(string[] Array, int Left, int Right) 
	{
		int LHold = Left;
		int RHold = Right;
		Random ObjRan = new Random();
		int Pivot = ObjRan.Next(Left, Right);
		quickSwap(Array, Pivot, Left);
		Pivot = Left;
		Left++;

		while (Right &gt;= Left) 
		{
			int cmpLeftVal = Array[Left].CompareTo(Array[Pivot]);
			int cmpRightVal = Array[Right].CompareTo(Array[Pivot]);

			if ((cmpLeftVal &gt;= 0) &amp;&amp; (cmpRightVal &lt; 0))
			{
				quickSwap(Array, Left, Right);
			}
			else 
			{
				if (cmpLeftVal &gt;= 0)
				{
					Right--;
				}
				else 
				{
					if (cmpRightVal &lt; 0)
					{
						Left++;
					}
					else 
					{
						Right--;
						Left++;
					}
				}
			}
		}       
		quickSwap(Array, Pivot, Right);
		Pivot = Right;  
		if (Pivot &gt; LHold)
		{
			quickSort(Array, LHold, Pivot);
		}
		if (RHold &gt; Pivot + 1)
		{
			quickSort(Array, Pivot + 1, RHold);
		}
	}
}
</pre></code> 
      <h3><span class="mw-headline" id="Common_Lisp"><a href="http://en.wikipedia.org/wiki/Common_Lisp" class="extiw" title="wikipedia:Common Lisp">Common Lisp</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=8" title="Edit section: Common Lisp">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre>
(defun quicksort (list)
  (if (&lt;= (length list) 1)   list
      (let ((pivot (first list)))
	(append	(quicksort (remove-if-not #'(lambda (x) (&lt; x pivot)) list))
			   (remove-if-not #'(lambda (x) (= x pivot)) list)
		(quicksort (remove-if-not #'(lambda (x) (&gt; x pivot)) list))))))</pre> 
      <h3><span class="mw-headline" id="D"><a href="http://en.wikipedia.org/wiki/D_(programming_language)" class="extiw" title="wikipedia:D (programming language)">D</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=9" title="Edit section: D">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre>
void sort(T)(T arr) {
    if (arr.length &gt; 1) {
        quickSort(arr.ptr, arr.ptr + (arr.length - 1));
    }
}

void quickSort(T)(T *left, T *right) {
    if (right &gt; left) {
        T pivot = left[(right - left) / 2];
        T* r = right, l = left;
        do {
            while (*l &lt; pivot) l++;
            while (*r &gt; pivot) r--;
            if (l &lt;= r) swap(*l++, *r--);
        } while (l &lt;= r);
        quickSort(left, r);
        quickSort(l, right);
    }
}
</pre></code> 
      <h3><span class="mw-headline" id="Delphi"><a href="http://en.wikipedia.org/wiki/Delphi_programming_language" class="extiw" title="wikipedia:Delphi programming language">Delphi</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=10" title="Edit section: Delphi">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This example sorts strings using quicksort. </p>
      <p><b>Note:</b> This can be considered bad code, as it is very slow. </p> 
      <code><pre>
procedure QuickSort(const AList: TStrings; const AStart, AEnd: Integer);
  procedure Swap(const AIdx1, AIdx2: Integer);
  var
    Tmp: string;
  begin
    Tmp&nbsp;:= AList[AIdx1];
    AList[AIdx1]&nbsp;:= AList[AIdx2];
    AList[AIdx2]&nbsp;:= Tmp;
  end;

var
  Left: Integer;
  Pivot: string;
  Right: Integer;
begin
  if AStart &gt;= AEnd then
    Exit;
  Pivot&nbsp;:= AList[AStart];
  Left&nbsp;:= AStart + 1;
  Right&nbsp;:= AEnd;
  while Left &lt; Right do
    begin
      if AList[Left] &lt; Pivot then
        Inc(Left)
      else
        begin
          Swap(Left, Right);
          Dec(Right);
        end;
    end;
  Dec(Left);
  Swap(Left, AStart);
  Dec(Left);
  QuickSort(AList, AStart, Left);
  QuickSort(AList, Right, AEnd);
end;
</pre></code> 
      <p>This implementation sorts an array of integers. </p> 
      <code><pre>
procedure QSort(var A: array of Integer);
  procedure QuickSort(var A: array of Integer; iLo, iHi: Integer);
  var Lo, Hi, Mid, T: Integer;
  begin
    Lo&nbsp;:= iLo;
    Hi&nbsp;:= iHi;
    Mid&nbsp;:= A[(Lo + Hi) div 2];
    repeat
      while A[Lo] &lt; Mid do
        Inc(Lo);
      while A[Hi] &gt; Mid do
        Dec(Hi);
      if Lo &lt;= Hi then begin
        T&nbsp;:= A[Lo];
        A[Lo]&nbsp;:= A[Hi];
        A[Hi]&nbsp;:= T;
        Inc(Lo);
        Dec(Hi);
      end;
    until Lo &gt; Hi;
    if Hi &gt; iLo then
      QuickSort(A, iLo, Hi);
    if Lo &lt; iHi then
      QuickSort(A, Lo, iHi);
  end;
begin
  QuickSort(A, Low(A), High(A));
end;
</pre></code> 
      <p>This slightly modified implementation sorts an array of records. This is approximately 8x quicker than the previous one. <b>Note:</b> this is QuickSort only, more speedup can be gain with handling trivial case (comparing two values), or implementing Bubble or Shell sort on small ranges. </p> 
      <code><pre>
type
  TCustomRecord = record
    Key: WideString;
    foo1:Int64;
    foo2:TDatetime;
    foo3:Extended;
  end;
  TCustomArray = array of TCustomRecord;

procedure QuickSort(var A: TCustomArray; L, R: Integer; var tmp: TCustomRecord);
var
  OrigL,
  OrigR: Integer;
  Pivot: WideString;
  GoodPivot,
  SortPartitions: Boolean;
begin
  if L&lt;R then begin
    Pivot:=A[L+Random(R-L)].Key;
    OrigL:=L; //saving original bounds
    OrigR:=R;
    repeat
      L:=OrigL; //restoring original bounds if we
      R:=OrigR; //have chosen a bad pivot value
      while L&lt;R do begin
        while (L&lt;R) and (A[L].Key&lt;Pivot) do Inc(L);
        while (L&lt;R) and (A[R].Key&gt;=Pivot) do Dec(R);
        if (L&lt;R) then begin
          tmp:=A[L];
          A[L]:=A[R];
          A[R]:=tmp;
          Dec(R);
          Inc(L);
        end;
      end;
      if A[L].Key&gt;=Pivot then Dec(L);                            //has we managed to choose
      GoodPivot:=L&gt;=OrigL;                                       //a good pivot value?
      SortPartitions:=True;                                      //if so, then sort on
      if not GoodPivot then begin                                //bad luck, the pivot is the smallest one in our range
        GoodPivot:=True;                                         //let's presume that all the values are equal to pivot
        SortPartitions:=False;                                   //then no need to sort it
        for R&nbsp;:= OrigL to OrigR do if A[R].Key&lt;&gt;Pivot then begin //we have at least one different value than our pivot
          Pivot:=A[R].Key;                                       //so this will be our new pivot
          GoodPivot:=False;                                      //we have to start again sorting this range
          Break;
        end;
      end;
    until GoodPivot;
    if SortPartitions then begin
      QuickSort(A, OrigL, L, tmp);
      QuickSort(A, L+1, OrigR, tmp);
    end;
  end;
end;
</pre></code> 
      <h3><span class="mw-headline" id="Erlang"><a href="http://en.wikipedia.org/wiki/Erlang_programming_language" class="extiw" title="wikipedia:Erlang programming language">Erlang</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=11" title="Edit section: Erlang">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The following Erlang code sorts lists of items of <i>any type</i>. </p> 
      <code><pre>
qsort([]) -&gt; [];
qsort([Pivot|Rest]) -&gt;
    qsort([ X || X &lt;- Rest, X &lt; Pivot]) ++ [Pivot] ++ qsort([ Y || Y &lt;- Rest, Y &gt;= Pivot]).
</pre></code> 
      <h3><span class="mw-headline" id="Haskell"><a href="http://en.wikipedia.org/wiki/Haskell" class="extiw" title="wikipedia:Haskell">Haskell</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=12" title="Edit section: Haskell">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The Haskell code in the core implementations section is almost self explanatory but can suffer from inefficiencies because it crawls through the list "rest" twice, once for each list comprehension. A smart implementation can perform optimizations to prevent this inefficiency, but these are not required by the language. The following implementation does not have the aforementioned inefficiency, as it uses a partition function that ensures that we only traverse `xs' once: </p> 
      <code><pre>
partition:: (Ord a) =&gt; [a] -&gt; a -&gt; ([a],[a]) -&gt; ([a],[a])

partition [] _ part = part -- base case

partition (x:xs) pivot (lesseq,greater) = 
  if x&lt;= pivot then partition xs pivot (x:lesseq,greater)
               else partition xs pivot (lesseq,x:greater)

sort:: (Ord a) =&gt; [a] -&gt; [a]
sort [] = []
sort (x:xs) = sort lesseq ++ [x] ++ sort greater where
  (lesseq,greater) = partition xs x ([],[])
</pre></code> 
      <p>Another version: </p> 
      <pre>quicksort&nbsp;:: Ord a =&gt; [a] -&gt; [a]
quicksort []           = []
quicksort (pivot:tail) = quicksort less ++ [pivot] ++ quicksort greater
   where less    = [y | y &lt;- tail, y &lt; pivot]
         greater = [y | y &lt;- tail, y &gt;= pivot]
</pre> 
      <p>An even shorter version: </p> 
      <pre>qsort []     = []
qsort (x:xs) = qsort (filter (&lt; x) xs) ++ [x] ++ qsort (filter (&gt;= x) xs)
</pre> 
      <h3><span class="mw-headline" id="J"><a href="http://en.wikipedia.org/wiki/J_programming_language" class="extiw" title="wikipedia:J programming language">J</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=13" title="Edit section: J">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The J example in the core implementations section is extremely terse and difficult to understand. This implementation, from the J Dictionary, is less obtuse: </p> 
      <pre>sel=: adverb def 'x. # ['

quicksort=: verb define
 if. 1 &gt;: #y. do. y.
 else. 
  (quicksort y. &lt;sel e),(y. =sel e),quicksort y. &gt;sel e=.y.{~?#y.
 end.
)
</pre> 
      <h3><span class="mw-headline" id="Java"><a href="http://en.wikipedia.org/wiki/Java_programming_language" class="extiw" title="wikipedia:Java programming language">Java</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=14" title="Edit section: Java">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>With the advent of <a href="/wiki/index.php?title=J2SE&amp;action=edit&amp;redlink=1" class="new" title="J2SE (page does not exist)">J2SE</a> 5.0 you can use <a href="/wiki/index.php?title=Generic_programming&amp;action=edit&amp;redlink=1" class="new" title="Generic programming (page does not exist)">parameterized types</a> to avoid passing the <code>Comparator</code> used above. </p>
      <p>The following implementations use Generics to </p>
      <p>The following Java implementation uses a randomly selected pivot. It sorts objects that implement the <code>Comparator</code> interface using the natural ordering of their <code>compareTo</code> method. </p> 
      <pre class="java">
 import java.util.Arrays;
 import java.util.Random;
 
 public class QuickSort {
     public static final Random RND = new Random();
 
     private static void swap(Object[] array, int i, int j) {
         Object tmp = array[i];
         array[i] = array[j];
         array[j] = tmp;
     }
 
     private static &lt;E extends Comparable&lt;? super E&gt;&gt; int partition(E[] array, int begin, int end) {
         int index = begin + RND.nextInt(end - begin + 1);
         E pivot = array[index];
         swap(array, index, end);
         for (int i = index = begin; i &lt; end; ++i) {
             if (array[i].compareTo(pivot) &lt;= 0) {
                 swap(array, index++, i);
             }
         }
         swap(array, index, end);
         return (index);
     }
 
     private static &lt;E extends Comparable&lt;? super E&gt;&gt; void qsort(E[] array, int begin, int end) {
         if (end &gt; begin) {
             int index = partition(array, begin, end);
             qsort(array, begin, index - 1);
             qsort(array, index + 1, end);
         }
     }
 
     public static &lt;E extends Comparable&lt;? super E&gt;&gt; void sort(E[] array) {
         qsort(array, 0, array.length - 1);
     }
 
     // Example uses
     public static void main(String[] args) {
         Integer[] l1 = { 5, 1024, 1, 88, 0, 1024 };
         System.out.println("l1  start:" + Arrays.toString(l1));
         QuickSort.sort(l1);
         System.out.println("l1 sorted:" + Arrays.toString(l1));
 
         String[] l2 = { "gamma", "beta", "alpha", "zoolander" };
         System.out.println("l2  start:" + Arrays.toString(l2));
         QuickSort.sort(l2);
         System.out.println("l2 sorted:" + Arrays.toString(l2));
     }
 }

Analogously to the Erlang solution above, a user-supplied {{Javadoc:SE|java/util|Comparator}} determines the partial ordering of array elements:

 import java.util.Comparator;
 import java.util.Random;
 
 public class Quicksort {
     public static final Random RND = new Random();	
     private static void swap(Object[] array, int i, int j) {
         Object tmp = array[i];
         array[i] = array[j];
         array[j] = tmp;
     }
     private static &lt;E&gt; int partition(E[] array, int begin, int end, Comparator&lt;? super E&gt; cmp) {
         int index = begin + RND.nextInt(end - begin + 1);
         Object pivot = array[index];
         swap(array, index, end);	
         for (int i = index = begin; i &lt; end; ++ i) {
             if (cmp.compare(array[i], pivot) &lt;= 0) {
                 swap(array, index++, i);
             }
         }
         swap(array, index, end);	
         return (index);
     }
     private static &lt;E&gt; void qsort(E[] array, int begin, int end, Comparator&lt;? super E&gt; cmp) {
         if (end &gt; begin) {
             int index = partition(array, begin, end, cmp);
             qsort(array, begin, index - 1, cmp);
             qsort(array, index + 1,  end,  cmp);
         }
     }
     public static &lt;E&gt; void sort(E[] array, Comparator&lt;? super E&gt; cmp) {
         qsort(array, 0, array.length - 1, cmp);
     }
 }
</pre> 
      <h4><span class="mw-headline" id="another">another</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=15" title="Edit section: another">edit</a><span class="mw-editsection-bracket">]</span></span></h4> 
      <pre class="java">
import java.util.*;
public class QuickSort 
{
    public static final Random RND = new Random();	

    public static void main(String[] args) 
    {
        /* Data to be sorted */
        List&lt;Integer&gt; data = createRandomData();
        
        /* Generate a random permutation of the data.
         * This sometimes improves the performance of QuickSort
         */
        Collections.shuffle(data);
        
        /* Call quick sort */
        List&lt;Integer&gt; sorted = quickSort(data);
        
        /* Print sorted data to the standard output */
        System.out.println(sorted);
    }
    
    /* Add data to be sorted to the list */
    public static List&lt;Integer&gt; createRandomData()
    {
        int max = 1000000;
        int len = 1000;
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        for (int i=0; i&lt;len; i++)
        {
            /* You can add any type that implements
             * the Comparable interface */             
            list.add(new Integer(RND.nextInt(max)));
        }
        return list;
    }
    
    public static &lt;E extends Comparable&lt;? super E&gt;&gt; List&lt;E&gt; quickSort(List&lt;E&gt; data)
    {
        List&lt;E&gt; sorted = new ArrayList&lt;E&gt;();
        rQuickSort(data, sorted);
        return sorted;
    }
    
    /**
     * A recursive implementation of QuickSort. Pivot selection
     * is random. The algorithm is stable.
     */
    public static &lt;E extends Comparable&lt;? super E&gt;&gt; void rQuickSort(List&lt;E&gt; data, List&lt;E&gt; sorted)
    {   
        if (data.size() == 1)
        {
            sorted.add(data.get(0));
            return;
        }
        
        if (data.size() == 0)
        {
            return;
        }
        
        /* choose the pivot randomly */
        int pivot = RND.nextInt(data.size());
        E pivotI = data.get(pivot);
        List&lt;E&gt; fatPivot = new ArrayList&lt;E&gt;();
        List&lt;E&gt; left = new ArrayList&lt;E&gt;();
        List&lt;E&gt; right = new ArrayList&lt;E&gt;();
        
        // partition data
        for (E next&nbsp;: data)
        {
            int compare = pivotI.compareTo(next);
            if (compare &lt; 0)
            {
                right.add(next);
            }
            else if (compare &gt; 0)
            {
                left.add(next);
            }
            else
            {
                fatPivot.add(next);
            }
        }
        rQuickSort(left, sorted);
        sorted.addAll(fatPivot);
        rQuickSort(right, sorted);
    }
}
</pre> 
      <h3><span class="mw-headline" id="JavaScript"><a href="http://en.wikipedia.org/wiki/JavaScript" class="extiw" title="wikipedia:JavaScript">JavaScript</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=16" title="Edit section: JavaScript">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre class="js">
function qsort(a) {
    if (a.length == 0) return [];

    var left = [];
    var right = [];
    var pivot = a[0];
    for (var i = a.length; --i;) {
        if (a[i] &lt; pivot)
            left.push(a[i]);
        else
            right.push(a[i]);
    }

    return qsort(left).concat(pivot, qsort(right));
}
</pre></code> 
      <h3><span class="mw-headline" id="Mathematica"><a href="http://en.wikipedia.org/wiki/Mathematica" class="extiw" title="wikipedia:Mathematica">Mathematica</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=17" title="Edit section: Mathematica">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>Here's a functional-style implementation: </p> 
      <code><pre>
QSort[{}]&nbsp;:= {}
QSort[{h_, t___}]&nbsp;:=
  Join[QSort[Select[{t}, # &lt; h &amp;]], {h}, QSort[Select[{t}, # &gt;= h &amp;]]]
</pre></code> 
      <p>Here's a test driver which should yield <code>True</code>: </p> 
      <code><pre>
OrderedQ[QSort[Table[Random[Integer, {1, 10000}], {i, 1, 10000}]]]
</pre></code> 
      <h3><span class="mw-headline" id="MATLAB"><a href="http://en.wikipedia.org/wiki/MATLAB" class="extiw" title="wikipedia:MATLAB">MATLAB</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=18" title="Edit section: MATLAB">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre>
   function [y]=quicksort(x)
       &nbsp;% Uses quicksort to sort an array. Two dimensional arrays are sorted column-wise.
	[n,m]=size(x);
	if(m&gt;1)
		y=x;
		for j=1:m
			y(:,j)=quicksort(x(:,j));
		end
		return;
        end
	% The trivial cases
	if(n&lt;=1);y=x;return;end;
	if(n==2)
		if(x(1)&gt;x(2))
			x=[x(2); x(1)];
		end
		y=x;
		return;
	end
	% The non-trivial case
	% Find a pivot, and divide the array into two parts.
	% All elements of the first part are less than the
	% pivot, and the elements of the other part are greater 
	% than or equal to the pivot.
	m=fix(n/2);
        pivot=x(m);
	ltIndices=find(x&lt;pivot);&nbsp;% Indices of all elements less than pivot.
	if(isempty(ltIndices))&nbsp;% This happens when pivot is miniumum of all elements.
		ind=find(x&gt;pivot);&nbsp;% Find the indices of elements greater than pivot.
		if(isempty(ind));y= x;return;end;&nbsp;% This happens when all elements are the same.
		pivot=x(ind(1));&nbsp;% Use new pivot.
		ltIndices=find(x&lt;pivot);
	end
       &nbsp;% Now find the indices of all elements not less than pivot.
	% Since the pivot is an element of the array, 
	% geIndices cannot be empty.
	geIndices=find(x&gt;=pivot);
	% Recursively sort the two parts of the array and concatenate 
	% the sorted parts.
	y= [quicksort(x(ltIndices));quicksort(x(geIndices))];

</pre></code> 
      <h3><span class="mw-headline" id="Miranda"><a href="http://en.wikipedia.org/wiki/Miranda_programming_language" class="extiw" title="wikipedia:Miranda programming language">Miranda</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=19" title="Edit section: Miranda">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre>
   sort []           = []  
   sort (pivot:rest) = sort [ y | y &lt;- rest; y &lt;= pivot ]  
                        ++ [pivot] ++
                       sort [ y | y &lt;- rest; y &gt;  pivot ]
</pre></code> 
      <h3><span class="mw-headline" id="OCaml"><a href="http://en.wikipedia.org/wiki/OCaml" class="extiw" title="wikipedia:OCaml">OCaml</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=20" title="Edit section: OCaml">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre>
let rec sort = function
      [] -&gt; []
    | pivot&nbsp;:: rest -&gt;
        let left, right = List.partition (( &gt; ) pivot) rest in
        sort left @ pivot&nbsp;:: sort right
</pre></code> 
      <h3><span class="mw-headline" id="Perl"><a href="http://en.wikipedia.org/wiki/Perl" class="extiw" title="wikipedia:Perl">Perl</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=21" title="Edit section: Perl">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>Readable: </p> 
      <pre class="perl">
sub quicksort {
    my @list = @_;

    if ( scalar @list &lt;= 1 ) {
        return (@list);
    }

    my $pivot   = shift @list;

    my @less    = grep($_ &lt; $pivot, @list);
    my @greater = grep($_ &gt; $pivot, @list);

    return ( quicksort(@less), $pivot, quicksort(@greater));
}
</pre> 
      <p>Laconic: </p> 
      <pre>
sub qsort {
  return () if&nbsp;!@_;
  return (qsort(grep { $_ &lt; $_[0] } (@_)[1..$#_]), $_[0],
          qsort(grep { $_ &gt;= $_[0] } (@_)[1..$#_]));
}
</pre> 
      <p>Or: </p> 
      <pre>
sub qsort {
  @_ or return ();
  my $p = shift;
  (qsort(grep $_ &lt; $p, @_), $p, qsort(grep $_ &gt;= $p, @_));
}
</pre> 
      <h3><span class="mw-headline" id="Perl_6"><a href="http://en.wikipedia.org/wiki/Perl_6" class="extiw" title="wikipedia:Perl 6">Perl 6</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=22" title="Edit section: Perl 6">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre>
multi quicksort () { () }
multi quicksort (*$x, *@xs) {
   my @pre  = @xs.grep:{ $_ &lt;  $x };
   my @post = @xs.grep:{ $_ &gt;= $x };
   (@pre.quicksort, $x, @post.quicksort);
}
</pre> 
      <h3><span class="mw-headline" id="PHP"><a href="http://en.wikipedia.org/wiki/PHP" class="extiw" title="wikipedia:PHP">PHP</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=23" title="Edit section: PHP">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre class="php">
function quicksort($seq)
{
	if(!count($seq)) return $seq;
	
	$k = $seq[0];
	$x = $y = array();
	
	for($i=count($seq); --$i;)
	{
		if($seq[$i] &lt;= $k)
		{
			$x[] = $seq[$i];
		}
		else
		{
			$y[] = $seq[$i];
		}
	}
	
	return array_merge(quicksort($x), array($k), quicksort($y));
}
</pre> 
      <h3><span class="mw-headline" id="Prolog"><a href="http://en.wikipedia.org/wiki/Prolog" class="extiw" title="wikipedia:Prolog">Prolog</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=24" title="Edit section: Prolog">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The version in the core implementations section is concise and, because it uses tail recursion, efficient. Here's another version: </p> 
      <code><pre>
append([], L, L).
append([H | L1], L2, [H | Result])&nbsp;:- append(L1, L2, Result).

partition([], _, [], []).
partition([H | T], X, [H | Left], Right)&nbsp;:- H =&lt; X, partition(T, X, Left, Right).
partition([H | T], X, Left, [H | Right])&nbsp;:- H &gt; X, partition(T, X, Left, Right).

qsort([],[]).
qsort([H | Tail], Sorted)&nbsp;:-
        partition(Tail, H, Left, Right),
        qsort(Left, SortedLeft),
        qsort(Right, SortedRight),
        append(SortedLeft, [X | SortedRight], Sorted).
</pre></code> 
      <p>Another version: </p> 
      <pre><b>quicksort</b>([], []).
<b>quicksort</b>([<i>Pivot</i>|<i>Tail</i>], <i>Sorted</i>)&nbsp;:-
    <b>partition</b>(<i>Pivot</i>, <i>Tail</i>, <i>Smaller</i>, <i>Greater</i>),
    <b>quicksort</b>(<i>Smaller</i>, <i>SmallerSorted</i>),
    <b>quicksort</b>(<i>Greater</i>, <i>GreaterSorted</i>),
    <b>append</b>(<i>SmallerSorted</i>, [<i>Pivot</i>|<i>GreaterSorted</i>], <i>Sorted</i>).
</pre> 
      <pre><b>partition</b>(_, [], [], []).
<b>partition</b>(<i>Pivot</i>, [<i>Head</i>|<i>Tail</i>], [<i>Head</i>|<i>Smaller</i>], <i>Greater</i>)&nbsp;:-
    <i>Pivot</i> &gt; <i>Head</i>,
    <b>partition</b>(<i>Pivot</i>, <i>Tail</i>, <i>Smaller</i>, <i>Greater</i>).
<b>partition</b>(<i>Pivot</i>, [<i>Head</i>|<i>Tail</i>], <i>Smaller</i>, [<i>Head</i>|<i>Greater</i>])&nbsp;:-
    <i>Pivot</i> =&lt; <i>Head</i>,
    <b>partition</b>(<i>Pivot</i>, <i>Tail</i>, <i>Smaller</i>, <i>Greater</i>).
</pre> 
      <h3><span class="mw-headline" id="Python"><a href="http://en.wikipedia.org/wiki/Python_programming_language" class="extiw" title="wikipedia:Python programming language">Python</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=25" title="Edit section: Python">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>Using list comprehensions and conditional espressions: </p> 
      <code><pre class="python">
def qsort(L):
    return ((qsort([x for x in L[1:] if x &lt; L[0]]) + L[0:1] +
             qsort([x for x in L[1:] if x &gt;= L[0]])
            ) if L
            else [])
</pre></code> 
      <p>Using a less functional approach: </p> 
      <code><pre class="python">
def qsort2(L):
    if len(L)&lt;=1:
        return L
    pivot=L[0]
    less=    [x for x in L if x&lt;pivot]
    equal=   [x for x in L if x==pivot]
    greater= [x for x in L if x&gt;pivot]
    return qsort2(less)+equal+qsort2(greater)
</pre></code> 
      <p><br> In-place, O(log n) space and very readable(IMHO) version </p> 
      <pre class="python">  
def qsort3(arr, l, r):
    def swap(arr, s, d):
        if s&nbsp;!= d:
            tmp = arr[s]
            arr[s] = arr[d]
            arr[d] = tmp
    if l &gt;= r:
        return    
    m = l
    for i in range(l, r):
        if arr[i] &lt;= arr[r]:
            swap(arr, i, m)
            m += 1
    swap(arr, m, r)
    qsort3(arr, l, m-1)
    qsort3(arr, m+1, r)
    return arr

</pre> 
      <h3><span class="mw-headline" id="Ruby"><a href="http://en.wikipedia.org/wiki/Ruby_programming_language" class="extiw" title="wikipedia:Ruby programming language">Ruby</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=26" title="Edit section: Ruby">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre class="ruby">
def quicksort(list)
  return list if list.size &lt;= 1
  pivot = list.sample
  left, right = list.partition { |e| e &lt; pivot }
  quicksort(left) + quicksort(right)
end
</pre></code> 
      <h3><span class="mw-headline" id="Scheme"><a href="http://en.wikipedia.org/wiki/Scheme" class="extiw" title="wikipedia:Scheme">Scheme</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=27" title="Edit section: Scheme">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This uses <a rel="nofollow" class="external text" href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI 1</a> and <a rel="nofollow" class="external text" href="http://srfi.schemers.org/srfi-8/srfi-8.html">SRFI 8</a>. It avoids redundantly traversing the list: it partitions it with the pivot in one traversal, not two, and it avoids copying entire lists to append them, by instead only adding elements on the front of the output list's tail. </p> 
      <code><pre>
(define (quicksort list elt&lt;)
  (let qsort ((list list) (tail '()))
    (if (null-list? list)
        tail
        (let ((pivot (car list)))
          (receive (smaller larger)
                   (partition (lambda (x) (elt&lt; x pivot))
                              (cdr list))
            (qsort smaller (cons pivot (qsort larger tail))))))))
</pre></code> 
      <h3><span class="mw-headline" id="Seed7"><a href="http://en.wikipedia.org/wiki/Seed7" class="extiw" title="wikipedia:Seed7">Seed7</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=28" title="Edit section: Seed7">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre>
const proc: quickSort (inout array elemType: arr, in integer: left, in integer: right) is func
  local
    var elemType: compare_elem is elemType.value;
    var integer: less_idx is 0;
    var integer: greater_idx is 0;
    var elemType: help is elemType.value;
  begin
    if right &gt; left then
      compare_elem&nbsp;:= arr[right];
      less_idx&nbsp;:= pred(left);
      greater_idx&nbsp;:= right;
      repeat
        repeat
          incr(less_idx);
        until arr[less_idx] &gt;= compare_elem;
        repeat
          decr(greater_idx);
        until arr[greater_idx] &lt;= compare_elem or greater_idx = left;
        if less_idx &lt; greater_idx then
          help&nbsp;:= arr[less_idx];
          arr[less_idx]&nbsp;:= arr[greater_idx];
          arr[greater_idx]&nbsp;:= help;
        end if;
      until less_idx &gt;= greater_idx;
      arr[right]&nbsp;:= arr[less_idx];
      arr[less_idx]&nbsp;:= compare_elem;
      quickSort(arr, left, pred(less_idx));
      quickSort(arr, succ(less_idx), right);
    end if;
  end func;

const proc: quickSort (inout array elemType: arr) is func
  begin
    quickSort(arr, 1, length(arr));
  end func;
</pre> 
      <p>Original source: <a rel="nofollow" class="external autonumber" href="http://seed7.sourceforge.net/algorith/sorting.htm#quickSort">[1]</a> </p> 
      <h3><span class="mw-headline" id="Standard_ML"><a href="http://en.wikipedia.org/wiki/Standard_ML" class="extiw" title="wikipedia:Standard ML">Standard ML</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=29" title="Edit section: Standard ML">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>The following examplethough less general than the snippet in the core implementations section in that it does not accept a predicate argumentstrives to more closely resemble the implementations in the other functional languages. The use of <code>List.partition</code> in both examples enables the implementation to walk the list only once per call, thereby reducing the constant factor of the algorithm. </p> 
      <code><pre>
fun qsort [] = []
  | qsort (h::t) = let val (left, right) = List.partition (fn x =&gt; x &lt; h) t
                   in qsort left @ h&nbsp;:: qsort right
                   end;
</pre></code> 
      <p>Replacing the predicate is trivial: </p> 
      <code><pre>
fun qsort pred [] = []
  | qsort pred (h::t) = let val (left, right) = List.partition (fn x =&gt; pred (x, h)) t
                        in qsort pred left @ h&nbsp;:: qsort pred right
                        end;
</pre></code> 
      <p>A cleaner version that sacrifices the efficiency of <code>List.partition</code> and resembles the list-comprehension versions in other functional languages: </p> 
      <code><pre>
fun qsort [] = []
  | qsort (h::t) = qsort (List.filter (fn x =&gt; x &lt; h) t) @ h&nbsp;:: qsort (List.filter (fn x =&gt; x &gt;= h) t);
</pre></code> 
      <h3><span class="mw-headline" id="Tcl"><a href="http://en.wikipedia.org/wiki/Tcl" class="extiw" title="wikipedia:Tcl">Tcl</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=30" title="Edit section: Tcl">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <pre class="tcl">
proc qsort list {
 if {[llength $list] &lt;= 1} {return $list}
 set pivot [lindex $list 0]
 set left [set equal [set right[list]]]
 foreach x $list {
        lappend [expr {$x&lt;$pivot&nbsp;? "left"&nbsp;: $x&gt;$pivot&nbsp;? "right"&nbsp;: "equal"}] $x
 }
 return [concat [qsort $left] $equal [qsort $right]]
}
</pre> 
      <h3><span class="mw-headline" id="TorqueScript"><a href="http://en.wikipedia.org/wiki/Torque_Game_Engine" class="extiw" title="wikipedia:Torque Game Engine">TorqueScript</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=31" title="Edit section: TorqueScript">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This is an implementation of Quicksort using script from the Torque game Builder (aka TorqueScript). </p> 
      <code><pre>
// Sorts unordered set&nbsp;%uSet, which must be of the class SimSet.
function Quicksort(%uSet)
{
   &nbsp;%less = new SimSet();
   &nbsp;%pivots = new SimSet();
   &nbsp;%greater = new SimSet();

    if(%uSet.getCount() &lt;= 1)
        return&nbsp;%uSet;

   &nbsp;%pivotVal =&nbsp;%uSet.getObject(getRandom(0,&nbsp;%uSet.getCount()-1)).myValue;
    for(%i = 0;&nbsp;%i &lt;&nbsp;%uSet.getCount();&nbsp;%i ++)
    {
       // A new SimObject must be created in order to store it in a SimSet.
      &nbsp;%valObj = new SimObject(val)
       {
          myValue =&nbsp;%uSet.getObject(%i).myValue;
       };

        if(%pivotVal &gt;&nbsp;%valObj.myValue)
           &nbsp;%less.add(%valObj);
        else if(%pivotVal ==&nbsp;%valObj.myValue)
           &nbsp;%pivots.add(%valObj);
        else //if(%pivotVal &lt;&nbsp;%valObj.myValue)
           &nbsp;%greater.add(%valObj);
    }

    return qConcatenate(Quicksort(%less),&nbsp;%pivots, Quicksort(%greater));
}

function qConcatenate(%less,&nbsp;%equal,&nbsp;%greater)
{
   &nbsp;%all = new SimSet();

    // Concatenate the three arrays, adding them to the SimSet one at a time.
    for(%i = 0;&nbsp;%i &lt;&nbsp;%less.getCount();&nbsp;%i ++)
    {
       &nbsp;%all.add(%less.getObject(%i));
    }
    for(%i = 0;&nbsp;%i &lt;&nbsp;%equal.getCount();&nbsp;%i ++)
    {
       &nbsp;%all.add(%equal.getObject(%i));
    }
    for(%i = 0;&nbsp;%i &lt;&nbsp;%greater.getCount();&nbsp;%i ++)
    {
       &nbsp;%all.add(%greater.getObject(%i));
    }

    return&nbsp;%all;
}
</pre></code> 
      <h3><span class="mw-headline" id="Visual_Basic"><a href="http://en.wikipedia.org/wiki/Visual_Basic" class="extiw" title="wikipedia:Visual Basic">Visual Basic</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=32" title="Edit section: Visual Basic">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <code><pre class="vb">
Option Explicit

' a position, which is *hopefully* never used:
Public Const N_POS = -2147483648#

Public Sub Swap(ByRef Data() As Variant, _
                Index1 As Long, _
                Index2 As Long)
    If Index1 &lt;&gt; Index2 Then
        Dim tmp As Variant
        
        If IsObject(Data(Index1)) Then
            Set tmp = Data(Index1)
        Else
            tmp = Data(Index1)
        End If
        
        If IsObject(Data(Index2)) Then
            Set Data(Index1) = Data(Index2)
        Else
            Data(Index1) = Data(Index2)
        End If
        
        If IsObject(tmp) Then
            Set Data(Index2) = tmp
        Else
            Data(Index2) = tmp
        End If
        
        Set tmp = Nothing
    End If
End Sub

Public Sub QuickSort(ByRef Data() As Variant, _
                     Optional ByVal Lower As Long = N_POS, _
                     Optional ByVal Upper As Long = N_POS)
    If Lower = N_POS Then
        Lower = LBound(Data)
    End If
    
    If Upper = N_POS Then
        Upper = UBound(Data)
    End If
            
    If Lower &lt; Upper Then
        Dim Right As Long
        Dim Left  As Long
    
        Left = Lower + 1
        Right = Upper + 1
        
        Do While Left &lt; Right
            If Data(Left) &lt;= Data(Lower) Then
                Left = Left + 1
            Else
                Right = Right - 1
                Swap Data, Left, Right
            End If
        Loop
        
        Left = Left - 1
        Swap Data, Lower, Left
        QuickSort Data, Lower, Left - 1
        QuickSort Data, Right, Upper
    End If
End Sub
</pre></code> 
      <p>Another implementation: </p> 
      <code><pre class="vb">
Function Quicksort(ByRef aData() As Long) As Long()
    Dim lPivot As Long
    
    Dim aLesser() As Long
    Dim aPivotList() As Long
    Dim aBigger() As Long
    Dim i As Long
    Dim count As Long
    Dim ret() As Long
    
    On Error Resume Next
    
    count = UBound(aData)
    
    If Err Then
        Exit Function
    ElseIf count = 0 Then
        Quicksort = aData
        Exit Function
    End If
    
    On Error GoTo 0
    
    Randomize
    lPivot = aData(Int(Rnd * count))
    
    For i = 0 To count
        If aData(i) &lt; lPivot Then AddTo aData(i), aLesser
        If aData(i) = lPivot Then AddTo aData(i), aPivotList
        If aData(i) &gt; lPivot Then AddTo aData(i), aBigger
    Next

    aLesser = Quicksort(aLesser)
    aPivotList = aPivotList
    aBigger = Quicksort(aBigger)
    
    ret = JoinLists(aLesser, aPivotList, aBigger)
    
    Quicksort = ret
End Function

Sub AddTo(ByVal lData As Long, ByRef aWhere() As Long)
    Dim count As Long
    
    On Error Resume Next
    
    count = UBound(aWhere) + 1
    ReDim Preserve aWhere(count)
    
    aWhere(count) = lData
    On Error GoTo 0
End Sub

Function JoinLists(ByRef Arr1() As Long, ByRef Arr2() As Long, ByRef Arr3() As Long) As Long()
    Dim count1 As Long
    Dim count2 As Long
    Dim count3 As Long
    Dim i As Long
    Dim ret() As Long
    Dim cnt As Long
    
    On Error Resume Next
    
    Err.Clear
    
    count1 = UBound(Arr1)
    If Err Then count1 = -1
    Err.Clear
    
    count2 = UBound(Arr2)
    If Err Then count2 = -1
    Err.Clear
    
    count3 = UBound(Arr3)
    If Err Then count3 = -1
    Err.Clear
    
    On Error GoTo 0
    
    ReDim ret(count1 + (count2 + 1) + (count3 + 1))
    
    For i = 0 To count1
        ret(i) = Arr1(i)
    Next
    
    For i = count1 + 1 To (count2 + 1) + count1
        ret(i) = Arr2(i - count1 - 1)
    Next
    
    For i = count2 + 1 + count1 + 1 To (count3 + 1) + (count2 + 1) + count1
        ret(i) = Arr3(i - count2 - 1 - count1 - 1)
    Next
    
    JoinLists = ret
End Function
</pre></code> 
      <p>To generalize it, simply change types to Variant. </p> 
      <h3><span class="mw-headline" id="Visual_Basic_for_Applications"><a href="http://en.wikipedia.org/wiki/Visual_Basic_for_Applications" class="extiw" title="wikipedia:Visual Basic for Applications">Visual Basic for Applications</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=33" title="Edit section: Visual Basic for Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This is an Excel 2003 VBA implementation based on the Visual Basic implementation. I couldn't make it work with Variant so it is implemented as Date. Change Date to the data type relevant to you. </p> 
      <code><pre>
Sub Swap(ByRef Data() As Date, _
                Index1 As Long, _
                Index2 As Long)
    If Index1 &lt;&gt; Index2 Then
        Dim tmp As Variant
        
        tmp = Data(Index1)
        Data(Index1) = Data(Index2)
        Data(Index2) = tmp
        
        Set tmp = Nothing
    End If
End Sub

Sub QuickSort(ByRef Data() As Date, Lower As Long, Upper As Long)
            
    If Lower &lt; Upper Then
        Dim Right As Long
        Dim Left  As Long
    
        Left = Lower + 1
        Right = Upper + 1
        
        Do While Left &lt; Right
            If Data(Left) &lt;= Data(Lower) Then
                Left = Left + 1
            Else
                Right = Right - 1
                Swap Data, Left, Right
            End If
        Loop
        
        Left = Left - 1
        Swap Data, Lower, Left
        QuickSort Data, Lower, Left - 1
        QuickSort Data, Right, Upper
    End If
End Sub
</pre></code> 
      <h3><span class="mw-headline" id="Zilog_Z80000_Assembly"><a href="http://en.wikipedia.org/wiki/Zilog_Z80000" class="extiw" title="wikipedia:Zilog Z80000">Zilog Z80000</a> <a href="http://en.wikipedia.org/wiki/Assembly_language" class="extiw" title="wikipedia:Assembly language">Assembly</a></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/wiki/index.php?title=Quicksort&amp;action=edit&amp;section=34" title="Edit section: Zilog Z80000 Assembly">edit</a><span class="mw-editsection-bracket">]</span></span></h3> 
      <p>This implementation is in z80 assembly code. The processor is really ancient, and so its basically a register-stack recursion juggling feat. More on it and the author's comments <a rel="nofollow" class="external text" href="http://entelekheia.net">here</a>. It takes the register pairs BC and HL which point to the start and end memory locations to the list of one-byte elements to be sorted. All registers are filled with "garbage" data in the process, so they need to be pushed to the stack to be saved. The script is about 44 bytes long, and doesn't have pivot-optimizing code. </p> 
      <code><pre>
;
; Usage: bc-&gt;first, de-&gt;last,
;        call qsort
; Destroys: abcdefhl
;
qsort   ld      hl,0
        push    hl
qsloop  ld      h,b
        ld      l,c
        or      a
        sbc     hl,de
        jp      c,next1&nbsp;;loop until lo&lt;hi
        pop     bc
        ld      a,b
        or      c
        ret     z      &nbsp;;bottom of stack
        pop     de
        jp      qsloop
next1   push    de     &nbsp;;save hi,lo
        push    bc
        ld      a,(bc) &nbsp;;pivot
        ld      h,a
        dec     bc
        inc     de
fleft   inc     bc     &nbsp;;do i++ while cur&lt;piv
        ld      a,(bc)
        cp      h
        jp      c,fleft
fright  dec     de     &nbsp;;do i-- while cur&gt;piv
        ld      a,(de)
        ld      l,a
        ld      a,h
        cp      l
        jp      c,fright
        push    hl     &nbsp;;save pivot
        ld      h,d    &nbsp;;exit if lo&gt;hi
        ld      l,e
        or      a
        sbc     hl,bc
        jp      c,next2
        ld      a,(bc) &nbsp;;swap (bc),(de)
        ld      h,a
        ld      a,(de)
        ld      (bc),a
        ld      a,h
        ld      (de),a
        pop     hl     &nbsp;;restore pivot
        jp      fleft
next2   pop     hl     &nbsp;;restore pivot
        pop     hl     &nbsp;;pop lo
        push    bc     &nbsp;;stack=left-hi
        ld      b,h
        ld      c,l    &nbsp;;bc=lo,de=right
        jp      qsloop
</pre></code> 
      <ul> 
       <li> Original Source: <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort">Wikibooks</a> </li> 
      </ul> 
      <!-- 
NewPP limit report
CPU time usage: 0.153 seconds
Real time usage: 0.184 seconds
Preprocessor visited node count: 555/1000000
Preprocessor generated node count: 1092/1000000
Post?expand include size: 417/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
--> 
      <!-- Saved in parser cache with key codecodex:pcache:idhash:1815-0!*!0!!en!*!* and timestamp 20170917051336
 --> 
     </div>
     <div class="printfooter">
       Retrieved from "
      <a href="http://www.codecodex.com/wiki/index.php?title=Quicksort&amp;oldid=11478">http://www.codecodex.com/wiki/index.php?title=Quicksort&amp;oldid=11478</a>"
     </div> 
     <div id="catlinks">
      <div id="catlinks" class="catlinks">
       <div id="mw-normal-catlinks" class="mw-normal-catlinks">
        <a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>: 
        <ul>
         <li><a href="/wiki/Category:Sort_algorithms" title="Category:Sort algorithms">Sort algorithms</a></li>
         <li><a href="/wiki/Category:Pseudocode" title="Category:Pseudocode">Pseudocode</a></li>
         <li><a href="/wiki/Category:Recursion" title="Category:Recursion">Recursion</a></li>
         <li><a href="/wiki/Category:AppleScript" title="Category:AppleScript">AppleScript</a></li>
         <li><a href="/wiki/index.php?title=Category:AutoIt&amp;action=edit&amp;redlink=1" class="new" title="Category:AutoIt (page does not exist)">AutoIt</a></li>
         <li><a href="/wiki/Category:C" title="Category:C">C</a></li>
         <li><a href="/wiki/Category:C%2B%2B" title="Category:C++">C++</a></li>
         <li><a href="/wiki/Category:C_sharp" title="Category:C sharp">C sharp</a></li>
         <li><a href="/wiki/Category:Common_Lisp" title="Category:Common Lisp">Common Lisp</a></li>
         <li><a href="/wiki/index.php?title=Category:D&amp;action=edit&amp;redlink=1" class="new" title="Category:D (page does not exist)">D</a></li>
         <li><a href="/wiki/Category:Delphi" title="Category:Delphi">Delphi</a></li>
         <li><a href="/wiki/Category:Erlang" title="Category:Erlang">Erlang</a></li>
         <li><a href="/wiki/Category:Haskell" title="Category:Haskell">Haskell</a></li>
         <li><a href="/wiki/index.php?title=Category:J&amp;action=edit&amp;redlink=1" class="new" title="Category:J (page does not exist)">J</a></li>
         <li><a href="/wiki/Category:Java" title="Category:Java">Java</a></li>
         <li><a href="/wiki/Category:JavaScript" title="Category:JavaScript">JavaScript</a></li>
         <li><a href="/wiki/index.php?title=Category:Mathematica&amp;action=edit&amp;redlink=1" class="new" title="Category:Mathematica (page does not exist)">Mathematica</a></li>
         <li><a href="/wiki/index.php?title=Category:MATLAB&amp;action=edit&amp;redlink=1" class="new" title="Category:MATLAB (page does not exist)">MATLAB</a></li>
         <li><a href="/wiki/Category:Miranda" title="Category:Miranda">Miranda</a></li>
         <li><a href="/wiki/Category:Objective_Caml" title="Category:Objective Caml">Objective Caml</a></li>
         <li><a href="/wiki/Category:Perl" title="Category:Perl">Perl</a></li>
         <li><a href="/wiki/index.php?title=Category:Perl_6&amp;action=edit&amp;redlink=1" class="new" title="Category:Perl 6 (page does not exist)">Perl 6</a></li>
         <li><a href="/wiki/Category:PHP" title="Category:PHP">PHP</a></li>
         <li><a href="/wiki/Category:Prolog" title="Category:Prolog">Prolog</a></li>
         <li><a href="/wiki/Category:Python" title="Category:Python">Python</a></li>
         <li><a href="/wiki/Category:Ruby" title="Category:Ruby">Ruby</a></li>
         <li><a href="/wiki/Category:Scheme" title="Category:Scheme">Scheme</a></li>
         <li><a href="/wiki/Category:Seed7" title="Category:Seed7">Seed7</a></li>
         <li><a href="/wiki/index.php?title=Category:Standard_ML&amp;action=edit&amp;redlink=1" class="new" title="Category:Standard ML (page does not exist)">Standard ML</a></li>
         <li><a href="/wiki/Category:Tcl" title="Category:Tcl">Tcl</a></li>
         <li><a href="/wiki/index.php?title=Category:TorqueScript&amp;action=edit&amp;redlink=1" class="new" title="Category:TorqueScript (page does not exist)">TorqueScript</a></li>
         <li><a href="/wiki/Category:VBA" title="Category:VBA">VBA</a></li>
         <li><a href="/wiki/Category:Visual_Basic" title="Category:Visual Basic">Visual Basic</a></li>
         <li><a href="/wiki/index.php?title=Category:Zilog_Z80000_Assembly&amp;action=edit&amp;redlink=1" class="new" title="Category:Zilog Z80000 Assembly (page does not exist)">Zilog Z80000 Assembly</a></li>
        </ul>
       </div>
      </div>
     </div> 
     <!-- end content --> 
    </div>
    <!-- end of MAINCONTENT div --> 
   </div>
   <!-- end of MBODY div --> 
   <div id="footer">
    <table>
     <tbody>
      <tr>
       <td align="left" width="1%" nowrap> </td>
       <td align="center"> <span id="f-lastmod"> This page was last modified on 15 May 2012, at 15:40.</span> <span id="f-viewcount">This page has been accessed 83,880 times. </span> 
        <ul id="f-list"> 
         <li id="f-about"><a href="/wiki/CodeCodex:About" title="CodeCodex:About">About CodeCodex</a></li> 
         <li id="f-disclaimer"><a href="/wiki/CodeCodex:General_disclaimer" title="CodeCodex:General disclaimer">Disclaimers</a></li> 
        </ul></td>
       <td align="right" width="1%" nowrap>
        <div id="f-poweredbyico">
         <a href="//www.mediawiki.org/"><img src="/skins/common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki"></a>
        </div></td>
      </tr>
     </tbody>
    </table> 
   </div>
   <!-- end of the FOOTER div --> 
  </div>
  <!-- end of the CONTAINER div --> 
  <!-- Served in 0.463 secs. --> 
  <!-- dailycred --> 
  <script type="text/javascript">
(function() {
  var dc, dc_opts, url;
  dc_opts = {
    clientId: "3ec86370-8353-4785-a876-7ec91b07bf3b",
    home: "https://www.dailycred.com",
    personaAudience: "",
    type: "",
    event_title: ""
  };
  dc = document.createElement("script");
  url = dc_opts.home + "/public/js/cred.coffee";
  dc.src = url;
  document.body.appendChild(dc);
  window.dc_opts = dc_opts;
}).call(this);
</script> 
  <!-- end dailycred -->   
 </body>
</html>