<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <title>GUI Programming -  Java Programming Tutorial</title> 
  <link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css"> 
  <script type="text/javascript" src="../scripts/programming_notes_v1.js"></script> 
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
 </head> 
 <body> 
  <div id="wrap-outer"> 
   <!-- header filled by JavaScript --> 
   <div id="header" class="header-footer">
    <p>&nbsp;</p>
   </div> 
   <div id="wrap-inner"> 
    <div id="wrap-toc"> 
     <h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5> 
     <div id="toc"></div> 
     <!-- for showing the "Table of Content" --> 
    </div> 
    <div id="content-header"> 
     <h1>Java Programming Tutorial</h1> 
     <h2>Programming Graphical User Interface (GUI)</h2> 
    </div> 
    <div id="content-main"> 
     <h3>Introduction</h3> 
     <p>So far, we have covered the basic programming constructs (such as variables, types, decision, loop, array and method) and introduced the important concept of Object-Oriented Programming (OOP). As discussed, OOP permits higher level of abstraction than the traditional procedural-oriented languages (such as C and Pascal). You can create high-level abstract data types called <em>classes</em> to mimic real-life things. These classes are self-contained and are <em>reusable</em>.</p> 
     <p>In this article, I shall show you how you can <em>reuse</em> the graphics classes provided in JDK for constructing your own Graphical User Interface (GUI) applications. Writing your own graphics classes (and re-inventing the wheels) is mission impossible! These graphics classes, developed by expert programmers, are highly complex and involve many advanced <em>design patterns</em>.&nbsp; However, re-using them are not so difficult, if you follow the API documentation, samples and templates provided.</p> 
     <p>I shall assume you have a good grasp of OOP, including inheritance and polymorphism; otherwise, read the earlier articles. I will describe another important concept called <em>nested class</em> (or <em>inner class</em>) in this article.</p> 
     <p>There are two sets of Java APIs for graphics programming: AWT (<span class="underline">A</span>bstract <span class="underline">W</span>indowing <span class="underline">T</span>oolkit) and Swing.</p> 
     <ol> 
      <li>AWT API was introduced in JDK 1.0. Most of the AWT components have become obsolete and should be replaced by newer Swing components.</li> 
      <li>Swing API, a much more comprehensive set of graphics libraries that enhances the AWT, was introduced as part of Java Foundation Classes (JFC) after the release of JDK 1.1. JFC consists of Swing, Java2D, Accessibility, Internationalization, and Pluggable Look-and-Feel Support APIs. JFC has been integrated into core Java since JDK 1.2.</li> 
     </ol> 
     <p>Other than AWT/Swing Graphics APIs provided in JDK, others have also provided Graphics APIs that work with Java, such as Eclipse's Standard Widget Toolkit (SWT) (used in Eclipse), Google Web Toolkit (GWT) (used in Android), 3D Graphics API such as Java bindings for OpenGL (JOGL) and Java3D.</p> 
     <p>You need to check the JDK API specification (<a href="http://docs.oracle.com/javase/8/docs/api/index.html">http://docs.oracle.com/javase/8/docs/api/index.html</a>) for the AWT and Swing APIs while reading this chapter. The best online reference for Graphics programming is the "Swing Tutorial" @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>. For advanced 2D graphics programming, read "Java 2D Tutorial" @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>. For 3D graphics, read my 3D articles.</p> 
     <h3>Programming GUI with AWT</h3> 
     <p>I shall start with the AWT before moving into Swing to give you a complete picture of Java Graphics.</p> 
     <h4>AWT Packages</h4> 
     <p>AWT is huge! It consists of 12 packages of 370 classes (Swing is even bigger, with 18 packages of 737 classes as of JDK 1.8). Fortunately, only 2 packages - <code>java.awt</code> and <code>java.awt.event</code> - are commonly-used.</p> 
     <ol> 
      <li>The <code>java.awt</code> package contains the <em>core</em> AWT graphics classes: 
       <ul> 
        <li>GUI Component classes, such as <code>Button</code>, <code>TextField</code>, and <code>Label</code>,</li> 
        <li>GUI Container classes, such as <code>Frame</code> and <code>Panel</code>,</li> 
        <li>Layout managers, such as <code>FlowLayout</code>, <code>BorderLayout</code> and <code>GridLayout</code>,</li> 
        <li>Custom graphics classes, such as <code>Graphics</code>, <code>Color</code> and <code>Font</code>.</li> 
       </ul> </li> 
      <li>The <code>java.awt.event</code> package supports event handling: 
       <ul> 
        <li>Event classes, such as <code>ActionEvent</code>, <code>MouseEvent</code>, <code>KeyEvent</code> and <code>WindowEvent</code>,</li> 
        <li>Event Listener Interfaces, such as <code>ActionListener</code>, <code>MouseListener</code>, <code>KeyListener</code> and <code>WindowListener</code>,</li> 
        <li>Event Listener Adapter classes, such as <code>MouseAdapter</code>, <code>KeyAdapter</code>, and <code>WindowAdapter</code>.</li> 
       </ul> </li> 
     </ol> 
     <p>AWT provides a <em>platform-independent</em> and <em>device-independent</em> interface to develop graphic programs that runs on all platforms, including Windows, Mac OS, and Unixes.</p> 
     <h4>Containers and Components</h4> 
     <img src="images/AWT_ContainerComponent.png" alt="AWT_ContainerComponent.png"> 
     <p>There are two types of GUI elements:</p> 
     <ol> 
      <li><em>Component</em>: Components are elementary GUI entities, such as <code>Button</code>, <code>Label</code>, and <code>TextField</code>.</li> 
      <li><em>Container</em>: Containers, such as <code>Frame</code> and <code>Panel</code>, are used to <em>hold components in a specific layout</em> (such as <code>FlowLayout</code> or <code>GridLayout</code>). A container can also hold sub-containers.</li> 
     </ol> 
     <p>In the above figure, there are three containers: a <code>Frame</code> and two <code>Panel</code>s. A <code>Frame</code> is the <em>top-level container</em> of an AWT program. A <code>Frame</code> has a title bar (containing an icon, a title, and the minimize/maximize/close buttons), an optional menu bar and the content display area. A <code>Panel</code> is a<em> rectangular area</em> used to group related GUI components in a certain layout. In the above figure, the top-level <code>Frame</code> contains two <code>Panel</code>s. There are five components: a <code>Label</code> (providing description), a <code>TextField</code> (for users to enter text), and three <code>Button</code>s (for user to trigger certain programmed actions).</p> 
     <p>In a GUI program, a component must be kept in a container. You need to identify a container to hold the components. Every container has a method called <code>add(Component c)</code>. A <code>container</code> (say <code>c</code>) can invoke <code>c.add(aComponent)</code> to add <code>aComponent</code> into itself. For example,</p> 
     <pre class="color-example">
Panel pnl = new Panel();  <span class="color-comment">        // Panel is a container</span>
Button btn = new Button("Press"); <span class="color-comment">// Button is a component</span>
pnl.add(btn);                     <span class="color-comment">// The Panel container adds a Button component</span></pre> 
     <p>GUI components are also called <em>controls</em> (e.g., Microsoft ActiveX Control), <em>widgets</em> (e.g., Eclipse's Standard Widget Toolkit, Google Web Toolkit), which allow users to interact with (or control) the application.</p> 
     <h4>AWT <span class="font-code">Container</span> Classes</h4> 
     <h5>Top-Level Containers: <span class="font-code">Frame</span>, <span class="font-code">Dialog</span> and <span class="font-code">Applet</span></h5> 
     <p>Each GUI program has a <em>top-level container</em>. The commonly-used top-level containers in AWT are <code>Frame</code>, <code>Dialog</code> and <code>Applet</code>:</p> 
     <ul> 
      <li> <img class="image-float-right" src="images/AWT_Frame.png" alt="AWT_Frame.png"> A <code>Frame</code> provides the "main window" for the GUI application, which has a title bar (containing an icon, a title, the minimize, maximize/restore-down and close buttons), an optional menu bar, and the content display area. To write a GUI program, we typically start with a subclass extending from <code>java.awt.Frame</code> to inherit the main window as follows: <pre class="color-example float-clear">
<span class="color-new">import java.awt.Frame;</span>  <span class="color-comment">// Using Frame class in package java.awt</span>

<span class="color-comment">// A GUI program is written as a subclass of Frame - the top-level container
// This subclass inherits all properties from Frame, e.g., title, icon, buttons, content-pane</span>
public class MyGUIProgram <span class="color-new">extends Frame</span> {

   <span class="color-comment">// private variables</span>
   ......
 
   <span class="color-comment">// Constructor to setup the GUI components</span>
   public MyGUIProgram() { ...... }

   <span class="color-comment">// methods</span>
   ......
   ......

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor (to setup the GUI) by allocating an instance</span>
      new MyGUIProgram();
   }
}</pre> </li> 
      <li> <img class="image-float-right" src="images/AWT_Dialog.gif" alt="AWT_Dialog.gif"> An AWT <code>Dialog</code> is a <em>"pop-up window</em>" used for interacting with the users. A <code>Dialog</code> has a title-bar (containing an icon, a title and a close button) and a content display area, as illustrated. </li> 
      <li>An AWT <code>Applet</code> (in package <code>java.applet</code>) is the top-level container for an applet, which is a Java program running inside a browser. Applet will be discussed in the later chapter.</li> 
     </ul> 
     <h5>Secondary Containers: <span class="font-code">Panel</span> and <span class="font-code">ScrollPane</span></h5> 
     <p>Secondary containers are placed inside a top-level container or another secondary container. AWT also provide these secondary containers:</p> 
     <ul> 
      <li><code>Panel</code>: a rectangular box under a higher-level container, used to <em>layout</em> a set of related GUI components in pattern such as grid or flow.</li> 
      <li><code>ScrollPane</code>: provides automatic horizontal and/or vertical scrolling for a single child component.</li> 
      <li>others.</li> 
     </ul> 
     <h5>Hierarchy of the AWT <span class="font-code">Container</span> Classes</h5> 
     <p>The hierarchy of the AWT <code>Container</code> classes is as follows:</p> 
     <img class="image-center" src="images/AWT_ContainerClassDiagram.png" alt="AWT_ContainerClassDiagram.png"> 
     <p>As illustrated, each <code>Container</code> has a layout.</p> 
     <h4>AWT <span class="font-code">Component</span> Classes</h4> 
     <p>AWT provides many ready-made and reusable GUI components in package <code>java.awt</code>. The frequently-used are: <code>Button</code>, <code>TextField</code>, <code>Label</code>, <code>Checkbox</code>, <code>CheckboxGroup</code> (radio buttons), <code>List</code>, and <code></code><code>Choice</code>, as illustrated below.</p> 
     <img class="image-center" src="images/AWT_Components.png" alt="AWT_Components.png"> 
     <h5>AWT GUI Component: <span class="font-code">java.awt.Label</span></h5> 
     <img class="image-float-right" src="images/AWT_Label.png" alt="AWT_Label.png"> 
     <p>A <code>java.awt.Label</code> provides a descriptive text string. Take note that <code>System.out.println()</code> prints to the system console, NOT to the graphics screen. You could use a <code>Label</code> to label another component (such as text field) or provide a text description.</p> 
     <p> Check the JDK API specification for <code>java.awt.Label</code>.</p> 
     <p class="float-clear"><span class="underline">Constructors</span></p> 
     <pre class="color-syntax">
public Label(String <em>strLabel</em>, int <em>alignment</em>); <span class="color-comment">// Construct a Label with the given text String, of the text alignment</span>
public Label(String <em>strLabel</em>);                <span class="color-comment">// Construct a Label with the given text String</span>
public Label();                               <span class="color-comment">// Construct an initially empty Label</span></pre> 
     <p>The <code>Label</code> class has three constructors:</p> 
     <ol> 
      <li>The first constructor constructs a <code>Label</code> object with the given text string in the given alignment. Note that three <code>static</code> constants <code>Label.LEFT</code>, <code>Label.RIGHT</code>, and <code>Label.CENTER</code> are defined in the class for you to specify the alignment (rather than asking you to memorize arbitrary integer values).</li> 
      <li>The second constructor constructs a <code>Label</code> object with the given text string in default of left-aligned.</li> 
      <li>The third constructor constructs a <code>Label</code> object with an initially empty string. You could set the label text via the <code>setText()</code> method later.</li> 
     </ol> 
     <p><span class="underline">Constants (<code>final static</code> fields)</span></p> 
     <pre class="color-syntax">
public static final LEFT;    <span class="color-comment">// Label.LEFT</span>
public static final RIGHT;   <span class="color-comment">// Label.RIGHT</span>
public static final CENTER;  <span class="color-comment">// Label.CENTER</span></pre> 
     <p>These three constants are defined for specifying the alignment of the <code>Label</code>'s text, as used in the above constructor.</p> 
     <p><span class="underline">Public Methods</span></p> 
     <pre class="color-syntax">
<span class="color-comment">// Examples</span>
public String getText();
public void setText(String <em>strLabel</em>);
public int getAlignment();
public void setAlignment(int <em>alignment</em>);</pre> 
     <p>The <code>getText()</code> and <code>setText()</code> methods can be used to read and modify the <code>Label</code>'s text. Similarly, the <code>getAlignment()</code> and <code>setAlignment()</code> methods can be used to retrieve and modify the alignment of the text.</p> 
     <h5>Constructing a Component and Adding the Component into a Container</h5> 
     <p>Three steps are necessary to create and place a GUI component:</p> 
     <ol> 
      <li>Declare the component with an <em>identifier</em> (<em>name</em>);</li> 
      <li>Construct the component by invoking an appropriate constructor via the <code>new</code> operator;</li> 
      <li>Identify the container (such as <code>Frame</code> or <code>Panel</code>) designed to hold this component. The container can then add this component onto itself via <code><em>aContainer</em>.add(<em>aComponent</em>)</code> method. Every container has a <code>add(Component)</code> method. Take note that it is the container that actively and explicitly adds a component onto itself, NOT the other way.</li> 
     </ol> 
     <p class="underline">Example</p> 
     <pre class="color-example">
Label lblInput;                     <span class="color-comment">// Declare an Label instance called lblInput</span>
lblInput = new Label("Enter ID");   <span class="color-comment">// Construct by invoking a constructor via the new operator</span>
add(lblInput);                      <span class="color-comment">// this.add(lblInput) - "this" is typically a subclass of Frame</span>
lblInput.setText("Enter password"); <span class="color-comment">// Modify the Label's text string</span>
lblInput.getText();                 <span class="color-comment">// Retrieve the Label's text string</span><span class="color-comment"></span></pre> 
     <h5>An Anonymous Instance</h5> 
     <p>You can create a <code>Label</code> without specifying an identifier, called <em>anonymous instance</em>. In the case, the Java compiler will assign an <em>anonymous identifier</em> for the allocated object. You will not be able to reference an anonymous instance in your program after it is created. This is usually alright for a <code>Label</code> instance as there is often no need to reference a <code>Label</code> after it is constructed.</p> 
     <p class="underline">Example</p> 
     <pre class="color-example">
<span class="color-comment">// Allocate an anonymous Label instance.
// "this" container adds the instance.
// You CANNOT reference an anonymous instance to carry out further operations.</span>
add(new Label("Enter Name: ", Label.RIGHT));
 
<span class="color-comment">// Same as</span>
Label xxx = new Label("Enter Name: ", Label.RIGHT)); <span class="color-comment">// xxx assigned by compiler</span>
add(xxx);</pre> 
     <h5>AWT GUI Component: <span class="font-code">java.awt.Button</span></h5> 
     <img class="image-float-right" src="images/AWT_Button.png" alt="AWT_Button.png"> 
     <p>A <code>java.awt.Button</code> is a GUI component that triggers a certain programmed <em>action</em> upon clicking.</p> 
     <p class="float-clear"><span class="underline">Constructors</span></p> 
     <pre class="color-syntax">
public Button(String <em>btnLabel</em>);
   <span class="color-comment">// Construct a Button with the given label</span>
public Button();
   <span class="color-comment">// Construct a Button with empty label</span></pre> 
     <p>The <code>Button</code> class has two constructors. The first constructor creates a <code>Button</code> object with the given label painted over the button. The second constructor creates a <code>Button</code> object with no label.</p> 
     <p><span class="underline">Public Methods</span></p> 
     <pre class="color-syntax">
public String getLabel();
   <span class="color-comment">// Get the label of this Button instance</span>
public void setLabel(String <em>btnLabel</em>);
   <span class="color-comment">// Set the label of this Button instance</span>
public void setEnable(boolean <em>enable</em>);   <span class="color-comment">
   // Enable or disable this Button. Disabled Button cannot be clicked.</span></pre> 
     <p>The <code>getLabel()</code> and <code>setLabel()</code> methods can be used to read the current label and modify the label of a button, respectively.</p> 
     <p>Note: The latest Swing's <code>JButton</code> replaces <code>getLabel()/setLabel()</code> with <code>getText()/setText()</code> to be consistent with all the components. We will describe Swing later.</p> 
     <p><span class="underline">Event</span></p> 
     <p>Clicking a button fires a so-called <code>ActionEvent</code> and triggers a certain programmed action. I will explain event-handling later.</p> 
     <p><span class="underline">Example</span></p> 
     <pre class="color-example">
Button btnColor = new Button("Red"); <span class="color-comment">// Declare and allocate a Button instance called btnColor</span>
add(btnColor);                       <span class="color-comment">// "this" Container adds the Button</span>
...
btnColor.setLabel("Green");          <span class="color-comment">// Change the button's label</span>
btnColor.getLabel();                 <span class="color-comment">// Read the button's label</span>
...
add(Button("Blue"));    <span class="color-comment">// Create an anonymous Button. It CANNOT be referenced later</span>
</pre> 
     <h5>AWT GUI Component: <span class="font-code">java.awt.TextField</span></h5> 
     <img class="image-float-right" src="images/AWT_TextField.png" alt="AWT_TextField.png"> 
     <p>A <code>java.awt.TextField</code> is single-line text box for users to enter texts. (There is a multiple-line text box called <code>TextArea</code>.) Hitting the "ENTER" key on a <code>TextField</code> object fires an <code>ActionEvent</code>.</p> 
     <p class="float-clear"><span class="underline">Constructors</span></p> 
     <pre class="color-syntax">
public TextField(String <em>initialText</em>, int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string with the number of columns.</span>
public TextField(String <em>initialText</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string.</span>
public TextField(int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the number of columns.</span></pre> 
     <p><span class="underline">Public Methods</span></p> 
     <pre class="color-syntax">
public String getText();
   <span class="color-comment">// Get the current text on this TextField instance</span>
public void setText(String <em>strText</em>);
   <span class="color-comment">// Set the display text on this TextField instance</span>
public void setEditable(boolean <em>editable</em>);
   <span class="color-comment">// Set this TextField to editable (read/write) or non-editable (read-only)</span></pre> 
     <p><span class="underline">Event</span></p> 
     <p>Hitting the "ENTER" key on a <code>TextField</code> fires a <code>ActionEvent</code>, and triggers a certain programmed action.</p> 
     <p><span class="underline">Example</span></p> 
     <pre class="color-example">
TextField tfInput = new TextField(30); <span class="color-comment">// Declare and allocate an TextField instance called tfInput</span>
add(tfInput);                          <span class="color-comment">// "this" Container adds the TextField</span>
TextField tfResult = new TextField();  <span class="color-comment">// Declare and allocate an TextField instance called tfResult</span>
tfResult.setEditable(false) ;          <span class="color-comment">// Set to read-only</span>
add(tfResult);                         <span class="color-comment">// "this" Container adds the TextField</span>
......
<span class="color-comment">// Read an int from TextField "tfInput", square it, and display on "tfResult".
// getText() returns a String, need to convert to int</span>
int number = Integer.parseInt(tfInput.getText());
number *= number;
<span class="color-comment">// setText() requires a String, need to convert the int number to String.</span>
tfResult.setText(number + "");
</pre> 
     <p>Take note that <code>getText()/SetText()</code> operates on <code>String</code>. You can convert a <code>String</code> to a primitive, such as <code>int</code> or <code>double</code> via <code>static </code>method <code>Integer.parseInt()</code> or <code>Double.parseDouble()</code>. To convert a primitive to a <code>String</code>, simply concatenate the primitive with an empty <code>String</code>.</p> 
     <h4>Example 1: <span class="font-code">AWTCounter</span></h4> 
     <img class="image-float-right" src="images/AWT_Counter.png" alt="AWT_Counter.png"> 
     <p>Let's assemble a few components together into a simple GUI counter program, as illustrated. It has a top-level container <code>Frame</code>, which contains three components - a <code>Label</code> "Counter", a non-editable <code>TextField</code> to display the current count, and a "Count" <code>Button</code>. The <code>TextField</code> shall display count of <code>0</code> initially. </p> 
     <p>Each time you click the button, the counter's value increases by 1.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre> </td> 
        <td> <pre>
import java.awt.*;       <span class="color-comment"> // Using AWT container and component classes</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT event classes and listener interfaces</span>
 
<span class="color-comment">// An AWT program inherits from the top-level container java.awt.Frame</span>
public class AWTCounter <strong>extends Frame</strong> implements ActionListener {
   private Label lblCount;   <span class="color-comment"> // Declare a Label component</span> 
   private TextField tfCount;<span class="color-comment"> // Declare a TextField component </span>
   private Button btnCount;  <span class="color-comment"> // Declare a Button component</span>
   private int count = 0;    <span class="color-comment"> // Counter's value</span>
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTCounter () {
      setLayout(new FlowLayout());
        <span class="color-comment"> // "super" Frame, which is a Container, sets its layout to FlowLayout to arrange</span>
        <span class="color-comment"> // the components from left-to-right, and flow to next row from top-to-bottom.</span>
 
      lblCount = new Label("Counter"); <span class="color-comment"> // construct the Label component</span>
      add(lblCount);                   <span class="color-comment"> // "super" Frame container adds Label component</span>
 
      tfCount = new TextField("0", 10);<span class="color-comment"> // construct the TextField component</span>
      tfCount.setEditable(false);      <span class="color-comment"> // set to read-only</span>
      add(tfCount);                    <span class="color-comment"> // "super" Frame container adds TextField component</span>
 
      btnCount = new Button("Count");  <span class="color-comment"> // construct the Button component</span>
      add(btnCount);                   <span class="color-comment"> // "super" Frame container adds Button component</span>
 
      btnCount.addActionListener(this);
         <span class="color-comment">// "btnCount" is the source object that fires an ActionEvent when clicked.</span>
         <span class="color-comment">// The source add "this" instance as an ActionEvent listener, which provides</span>
         <span class="color-comment">//   an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Clicking "btnCount" invokes actionPerformed().</span>
<span class="color-comment"></span> 
      setTitle("AWT Counter"); <span class="color-comment"> // "super" Frame sets its title</span>
      setSize(250, 100);       <span class="color-comment"> // "super" Frame sets its initial window size</span>
 
     <span class="color-comment"> // For inspecting the Container/Components objects</span>
     <span class="color-comment"> // System.out.println(this);</span>
     <span class="color-comment"> // System.out.println(lblCount);</span>
     <span class="color-comment"> // System.out.println(tfCount);</span>
     <span class="color-comment"> // System.out.println(btnCount);</span>
 
      setVisible(true);        <span class="color-comment"> // "super" Frame shows</span>
 
     <span class="color-comment"> // System.out.println(this);</span>
     <span class="color-comment"> // System.out.println(lblCount);</span>
     <span class="color-comment"> // System.out.println(tfCount);</span>
     <span class="color-comment"> // System.out.println(btnCount);</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
     <span class="color-comment"> // Invoke the constructor to setup the GUI, by allocating an instance</span>
      AWTCounter app = new AWTCounter();
         <span class="color-comment">// or simply "new AWTCounter();" for an anonymous instance</span>
   }
 
   <span class="color-comment">// ActionEvent handler - Called back upon button-click.</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;<span class="color-comment"> // Increase the counter value</span>
     <span class="color-comment"> // Display the counter value on the TextField tfCount</span>
      tfCount.setText(count + "");<span class="color-comment"> // Convert int to String</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>To exit this program, you have to close the CMD-shell (or press "control-c" on the CMD console); or push the "red-square" close button in Eclipse's Application Console. This is because we have yet to write the handler for the <code>Frame</code>'s close button. We shall do that in the later example.</p> 
     <p class="line-heading">Dissecting the <span class="font-code">AWTCounter.java</span></p> 
     <ul> 
      <li>The <code>import</code> statements (Lines 1-2) are needed, as AWT container and component classes, such as <code>Frame</code>, <code>Button</code>, <code>TextField</code>, and <code>Label,</code> are kept in the <code>java.awt</code> package; while AWT events and event-listener interfaces, such as <code>ActionEvent</code> and <code>ActionListener</code> are kept in the <code>java.awt.event</code> package.</li> 
      <li>A GUI program needs a top-level container, and is often written as a subclass of <code>Frame</code> (Line 5). In other words, this class <code>AWTCounter</code> <em>is a</em> <code>Frame</code>, and inherits all the attributes and behaviors of a <code>Frame</code>, such as the title bar and content pane.</li> 
      <li>Lines 12 to 46 define a constructor, which is used to setup and initialize the GUI components.</li> 
      <li>In Line 13, the <code>setLayout()</code> (inherited from the superclass <code>Frame</code>) is used to set the layout of the container. <code>FlowLayout</code> is used which arranges the components in left-to-right and flows into next row in a top-to-bottom manner.</li> 
      <li>A <code>Label</code>, <code>TextField</code> (non-editable), and <code>Button</code> are constructed. We invoke the <code>add()</code> method (inherited from the superclass <code>Frame</code>) to add these components into container<code></code>.</li> 
      <li>In Line 33-34, we invoke the <code>setSize()</code> and the <code>setTitle()</code> (inherited from the superclass <code>Frame</code>) to set the initial size and the title of the <code>Frame</code>. The <code>setVisible(true)</code> method (Line 42) is then invoked to show the display.</li> 
      <li>The statement <code>btnCount.addActionListener(this)</code> (Line 27) is used to setup the event-handling mechanism, which will be discussed in length later. In brief, whenever the button is clicked, the <code>actionPerformed()</code> will be called. In the <code>actionPerformed()</code> (Lines 57-63), the counter value increases by 1 and displayed on the <code>TextField</code>.</li> 
      <li>In the entry<code> main()</code> method (Lines 51-55), an instance of <code>AWTCounter</code> is constructed. The constructor is executed to initialize the GUI components and setup the event-handling mechanism. The GUI program then waits for the user input.</li> 
     </ul> 
     <h5>Inspecting Container/Components via <span class="font-code">toString()</span></h5> 
     <p>It is interesting to inspect the GUI objects via the <code>toString()</code>, to gain an insight to these classes. (Alternatively, use a graphic debugger in Eclipse/NetBeans or study the JDK source code.) For example, if we insert the following code before and after the <code>setvisible()</code>:</p> 
     <pre class="color-example">
System.out.println(this);
System.out.println(lblCount);
System.out.println(tfCount);
System.out.println(btnCount);
 
setVisible(true);  <span class="color-comment">// "super" Frame shows</span>
 
System.out.println(this);
System.out.println(lblCount);
System.out.println(tfCount);
System.out.println(btnCount);</pre> 
     <p>The output (with my comments) are as follows. You could have an insight of the variables defined in the class.</p> 
     <pre class="output">
<span class="color-comment">// Before setVisible()</span>
AWTCounter[frame0,0,0,250x100,invalid,hidden,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]
      <span class="color-comment">// name (assigned by compiler) is "frame0"; top-left (x,y) at (0,0); width/height is 250x100 (via setSize());</span>
java.awt.Label[label0,0,0,0x0,invalid,align=left,text=Counter]
      <span class="color-comment">// name is "Label0"; align is "Label.LEFT" (default); text is "Counter" (assigned in contructor)</span>
java.awt.TextField[textfield0,0,0,0x0,invalid,text=0,selection=0-0]
      <span class="color-comment">// name is "Textfield0"; text is "0" (assigned in contructor)</span>
java.awt.Button[button0,0,0,0x0,invalid,label=Count]
      <span class="color-comment">// name is "button0"; label text is "Count" (assigned in contructor)</span>
      <span class="color-comment">// Before setVisible(), all components are invalid (top-left (x,y), width/height are invalid) </span>
<span class="color-comment"> 
// After setVisible(), all components are valid</span>
AWTCounter[frame0,0,0,250x100,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]
      <span class="color-comment">// valid and visible (not hidden)</span>
java.awt.Label[label0,20,41,58x23,align=left,text=Counter]
      <span class="color-comment">// Top-left (x,y) at (20,41) relative to the parent Frame; width/height = 58x23</span>
java.awt.TextField[textfield0,83,41,94x23,text=0,selection=0-0]
      <span class="color-comment">// Top-left (x,y) at (83,41) relative to the parent Frame; width/height = 94x23; no text selected (0-0)</span>
java.awt.Button[button0,182,41,47x23,label=Count]
      <span class="color-comment">// Top-left (x,y) at (182,41) relative to the parent Frame; width/height = 47x23</span></pre> 
     <h4>Example 2: <span class="font-code">AWTAccumulator</span></h4> 
     <img class="image-float-right" src="images/AWT_Accumulator.png" alt="AWT_Accumulator.png"> 
     <p>In this example, the top-level container is again the typical <code>java.awt.Frame</code>. It contains 4 components: a <code>Label</code> "Enter an Integer", a <code>TextField</code> for accepting user input, another <code>Label</code> "The Accumulated Sum is", and another non-editable <code>TextField</code> for displaying the sum. The components are arranged in <code>FlowLayout</code>.</p> 
     <p>The program shall accumulate the number entered into the <em>input</em> <code>TextField</code> and display the sum in the <em>output</em> <code>TextField</code>.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td> 
        <td> <pre>
import java.awt.*;       <span class="color-comment"> // Using AWT container and component classes</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT event classes and listener interfaces</span>
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTAccumulator <strong>extends Frame</strong> implements ActionListener {
   private Label lblInput;    <span class="color-comment"> // Declare input Label</span>
   private Label lblOutput;   <span class="color-comment"> // Declare output Label</span>
   private TextField tfInput; <span class="color-comment"> // Declare input TextField</span>
   private TextField tfOutput;<span class="color-comment"> // Declare output TextField</span>
   private int sum = 0;       <span class="color-comment"> // Accumulated sum, init to 0</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTAccumulator() {
      setLayout(new FlowLayout());
        <span class="color-comment"> // "super" Frame (container) sets layout to FlowLayout, which arranges</span>
        <span class="color-comment"> // the components from left-to-right, and flow to next row from top-to-bottom.</span>
 
      lblInput = new Label("Enter an Integer: ");<span class="color-comment"> // Construct Label</span>
      add(lblInput);              <span class="color-comment"> // "super" Frame container adds Label component</span>
 
      tfInput = new TextField(10);<span class="color-comment"> // Construct TextField</span>
      add(tfInput);               <span class="color-comment"> // "super" Frame adds TextField</span>
 
      tfInput.addActionListener(this);
         <span class="color-comment">// "tfInput" is the source object that fires an ActionEvent upon entered.</span>
         <span class="color-comment">// The source add "this" instance as an ActionEvent listener, which provides</span>
         <span class="color-comment">//  an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Hitting "enter" on tfInput invokes actionPerformed().</span>
<span class="color-comment"></span> 
      lblOutput = new Label("The Accumulated Sum is: "); <span class="color-comment"> // allocate Label</span>
      add(lblOutput);              <span class="color-comment"> // "super" Frame adds Label</span>
 
      tfOutput = new TextField(10);<span class="color-comment"> // allocate TextField</span>
      tfOutput.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfOutput);               <span class="color-comment"> // "super" Frame adds TextField</span>
 
      setTitle("AWT Accumulator"); <span class="color-comment"> // "super" Frame sets title</span>
      setSize(350, 120); <span class="color-comment"> // "super" Frame sets initial window size</span>
      setVisible(true);  <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
     <span class="color-comment"> // Invoke the constructor to setup the GUI, by allocating an anonymous instance</span>
      new AWTAccumulator();
   }
 
   <span class="color-comment">// ActionEvent handler - Called back upon hitting "enter" key on TextField</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
     <span class="color-comment"> // Get the String entered into the TextField tfInput, convert to int</span>
      int numberIn = Integer.parseInt(tfInput.getText());
      sum += numberIn;     <span class="color-comment"> // Accumulate numbers entered into sum</span>
      tfInput.setText(""); <span class="color-comment"> // Clear input TextField</span>
      tfOutput.setText(sum + "");<span class="color-comment"> // Display sum on the output TextField</span>
                                 <span class="color-comment"> // convert int to String</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p class="line-heading">Dissecting the <span class="font-code">AWTAccumulator.java</span></p> 
     <ol> 
      <li>An AWT GUI program extends from <code>java.awt.Frame</code> (Line 5) - the top-level window container.</li> 
      <li>In the constructor (Line 13), we constructs 4 components - 2 <code>java.awt.Label</code> and 2 <code>java.awt.TextField</code>s. The <code>Frame</code> adds the components, in <code>FlowLayout</code>.</li> 
      <li><code>tfInput</code> (<code>TextField</code>) is the source object, which fires an <code>ActionEvent</code> upon hitting the Enter key. <code>tfInput</code> adds <code>this</code> instance as an <code>ActionEvent</code> handler (Line 24). The listener class (<code>this</code> or <code>AWTAccumulator</code>) needs to implement <code>ActionListener</code> interface and provides implementation to method <code>actionPerformed()</code>. Whenever an user hits Enter on the <code>tfInput</code> (<code>TextField</code>), the <code>actionPerformed()</code> will be invoked.</li> 
     </ol> 
     <h5>Inspecting Container/Components via <span class="font-code">toString()</span></h5> 
     <p>Printing the <code>toString()</code> after <code>setVisible()</code> produces:</p> 
     <pre class="output">
AWTAccumulator[frame0,0,0,350x120,layout=java.awt.FlowLayout,title=AWT Accumulator,resizable,normal]
java.awt.Label[label0,72,41,107x23,align=left,text=Enter an Integer: ]
java.awt.Label[label1,47,69,157x23,align=left,text=The Accumulated Sum is: ]
java.awt.TextField[textfield0,184,41,94x23,text=,editable,selection=0-0]
java.awt.TextField[textfield1,209,69,94x23,text=,selection=0-0]</pre> 
     <h3 id="awt_event_handling">AWT Event-Handling</h3> 
     <p>Java adopts the so-called "Event-Driven" (or "Event-Delegation") programming model for event-handling, similar to most of the visual programming languages (such as Visual Basic and Delphi). </p> 
     <p>In event-driven programming, a piece of event-handling codes is executed (or called back by the graphics subsystem) when an event was fired in response to an user input (such as clicking a mouse button or hitting the ENTER key). This is unlike the procedural model, where codes are executed in a sequential manner.</p> 
     <p>The AWT's event-handling classes are kept in package <code>java.awt.event</code>.</p> 
     <p>Three objects are involved in the event-handling: a <em>source</em>, <em>listener</em>(s) and an <em>event</em> object.</p> 
     <p>The <em>source</em> object (such as <code>Button</code> and <code>Textfield</code>) interacts with the user. Upon triggered, it creates an <em>event</em> object. This <em>event</em> object will be messaged to all the <em>registered listener</em> object(s), and an appropriate event-handler method of the listener(s) is called-back to provide the response. In other words, <em>triggering a source fires an event to all its listener(s)</em>, <em>and invoke an appropriate handler of the listener(s)</em>.</p> 
     <p> To express interest for a certain source's event, the listener(s) must be registered with the source. In other words, the listener(s) "subscribes" to a source's event, and the source "publishes" the event to all its subscribers upon activation. This is known as <em>subscribe-publish</em> or <em>observable-observer</em> design pattern.</p> 
     <img class="image-center" src="images/AWT_EventHandling.png" alt="AWT_EventHandling.png"> 
     <p>The sequence of steps is illustrated above:</p> 
     <ol> 
      <li><em>The source object registers its listener(s)</em> for a certain type of <em>event</em>. <p>Source object fires event event upon triggered. For example, clicking an <code>Button</code> fires an <code>ActionEvent</code>, mouse-click fires <code>MouseEvent</code>, key-type fires <code>KeyEvent</code>, etc.</p> <p>How the source and listener understand each other? The answer is via an agreed-upon interface. For example, if a source is capable of firing an event called <code>XxxEvent</code> (e.g., <code>MouseEvent</code>) involving various operational modes (e.g., mouse-clicked, mouse-entered, mouse-exited, mouse-pressed, and mouse-released). Firstly, we need to declare an interface called <code>XxxListener</code> (e.g., <code>MouseListener</code>) containing the names of the handler methods. Recall that an <code>interface</code> contains only <code>abstract</code> methods without implementation. For example,</p> <pre class="color-example">
<span class="color-comment">// A MouseListener interface, which declares the signature of the handlers 
//  for the various operational modes.</span>
public <strong>interface MouseListener</strong> {
   public void <strong>mousePressed</strong>(MouseEvent evt);  <span class="color-comment">// Called back upon mouse-button pressed</span>
   public void <strong>mouseReleased</strong>(MouseEvent evt); <span class="color-comment">// Called back upon mouse-button released</span>
   public void <strong>mouseClicked</strong>(MouseEvent evt);  <span class="color-comment">// Called back upon mouse-button clicked (pressed and released)</span>
   public void <strong>mouseEntered</strong>(MouseEvent evt);  <span class="color-comment">// Called back when mouse pointer entered the component</span>
   public void <strong>mouseExited</strong>(MouseEvent evt);   <span class="color-comment">// Called back when mouse pointer exited the component</span>
}</pre> <p>Secondly, all the listeners interested in the <code>XxxEvent</code> must implement the <code>XxxListener</code> interface. That is, the listeners must provide their own implementations (i.e., programmed responses) to all the <code>abstract</code> methods declared in the <code>XxxListener</code> interface. In this way, the listenser(s) can response to these events appropriately. For example,</p> <pre class="color-example">
<span class="color-comment">// An example of MouseListener,  which provides implementation to the handler methods</span>
class MyMouseListener <strong>implement MouseListener</strong> {
   @Override
   public void <strong>mousePressed</strong>(MouseEvent e)  { 
      System.out.println("Mouse-button pressed!"); 
   }
 
   @Override
   public void <strong>mouseReleased</strong>(MouseEvent e) {
      System.out.println("Mouse-button released!"); 
   }
 
   @Override
   public void <strong>mouseClicked</strong>(MouseEvent e)  { 
      System.out.println("Mouse-button clicked (pressed and released)!"); 
   }
 
   @Override
   public void <strong>mouseEntered</strong>(MouseEvent e)  { 
      System.out.println("Mouse-pointer entered the source component!"); 
   }
 
   @Override
   public void <strong>mouseExited</strong>(MouseEvent e)   {
      System.out.println("Mouse exited-pointer the source component!");  
   }
}</pre> <p>Thirdly, in the source, we need to maintain a list of listener object(s), and define two methods: <code>addXxxListener()</code> and <code>removeXxxListener()</code> to add and remove a listener from this list. The signature of the methods are:</p> <pre class="color-syntax">
public void addXxxListener(XxxListener l);
public void removeXxxListener(XxxListener l);</pre> <p>Take note that all the listener(s) interested in the <code>XxxEvent</code> must implement the <code>XxxListener</code> interface. That is, they are sub-type of the <code>XxxListener</code>. Hence, they can be upcasted to <code>XxxListener</code> and passed as the argument of the above methods.</p> <p>In summary, we identify the source, the event-listener interface, and the listener object. The listener must implement the event-listener interface. The source object then registers listener object via the <code>addXxxListener()</code> method:</p> <pre class="color-example">
<em>aSource</em>.addXxxListener(<em>alistener</em>);  <span class="color-comment">// <em>aSource</em> registers <em>aListener</em> for XxxEvent</span>
</pre> </li> 
      <li>The source is triggered by a user.</li> 
      <li>The source create an <code>XxxEvent</code> object, which encapsulates the necessary information about the activation. For example, the <code>(x, y)</code> position of the mouse pointer, the text entered, etc.</li> 
      <li>Finally, for each of the listeners in the listener list, the source invokes the appropriate handler on the listener(s), which provides the programmed response.</li>
     </ol> 
     <p>In summary, <em>triggering a source fires an event to all its registered listeners, and invoke an appropriate handler of the listener</em>.</p> 
     <h4>Revisit Example 1 <span class="font-code">AWTCounter</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4> 
     <p>Clicking a <code>Button</code> (or hitting the "Enter" key on a <code>TextField</code>) fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s). An <code>ActionEvent</code> listener must implement the <code>ActionListener</code> interface, which declares one <code>abstract</code> method <code>actionPerformed()</code> as follow:</p> 
     <pre class="color-syntax">
public interface ActionListener {
   public void <strong>actionPerformed</strong>(ActionEvent evt);
      <span class="color-comment">// Called back upon button-click (on Button), enter-key pressed (on TextField)</span>
}</pre> 
     <p>Here are the event-handling steps:</p> 
     <ul> 
      <li>We identify <code>btnCount</code> (<code>Button</code>) as the <em>source</em> object.</li> 
      <li>Clicking <code>Button</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li> 
      <li>The listener(s) is required to implement <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the response. For simplicity, we choose "<code>this</code>" object (<code>AWTCounter</code>) as the <em>listener</em> for the <code>ActionEvent</code>. Hence, "<code>this</code>" class is required to implement <code>ActionListener</code> interface and provide the programmed response in the <code>actionPerformed()</code>. <pre class="color-example">
public class AWTCounter extends Frame <strong>implements ActionListener</strong> {
      <span class="color-comment">// "this" is chosen as the ActionEvent listener, hence, it is required 
      // to implement ActionListener interface</span>
   ......

   <span class="color-comment">// Implementing ActionListener interface requires this class to provide implementation
   // to the abstract method actionPerformed() declared in the interface.
</span>   @Override
   public void <strong>actionPerformed(ActionEvent evt)</strong> {
      <span class="color-comment">// Programmed response upon activation
      // Increment the count value and display on the TextField</span>
      ++count;
      tfCount.setText(count + "");
   }
}</pre> </li> 
      <li>The source object registers listener via the <code>addActionListener()</code>. In this example, the <em>source</em> <code>btnCount</code> (<code>Button</code>) adds "<code>this</code>" object as a <em>listener</em> via: <pre class="color-example">
btnCount.addActionListener(this);</pre> <p>Note that <code>addActionListener()</code> takes an argument of the type <code>ActionListener</code>. "<code>this</code>", which implements <code>ActionListener</code> interface (i.e., a subclass of <code>ActionListener</code>), is upcasted and passed to the <code>addActionListener()</code> method.</p> </li> 
      <li>Upon button-click, the <code>btnCount</code> creates an <code>ActionEvent</code> object, and calls back the <code>actionPerformed(ActionEvent)</code> method of all its registered listener(s) with the <code>ActionEvent</code> object created: <pre class="color-example">
ActionEvent evt = new ActionEvent( ...... );<em>
listener</em>.actionPerformed(evt);   <span class="color-comment">// for all its listener(s)</span></pre> </li> 
     </ul> 
     <p>The sequence diagram is as follows:</p> 
     <img class="image-center" src="images/AWT_ActionListener.png" alt="AWT_ActionListener.png"> 
     <img class="image-center" src="images/AWT_EventSeqDiagram.png" alt="AWT_EventSeqDiagram.png"> 
     <h4>Revisit Example 2 <span class="font-code">AWTAccumulator</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4> 
     <p>In this example,</p> 
     <ol> 
      <li>We identify the <code>tfInput</code> (<code>TextField</code>) as the source object.</li> 
      <li>Hitting the "Enter" key on a <code>TextField</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li> 
      <li>We choose <code>this</code> object as the <code>ActionEvent</code> listener (for simplicity).</li> 
      <li>The source object <code>tfInput</code> (<code>TextField</code>) registers the listener (<code>this</code> object) via the <code>tfInput.addActionListener(this)</code>.</li> 
      <li>The <code>ActionEvent</code> listener (<code>this</code> class) is required to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the programmed response upon activation.</li> 
     </ol> 
     <h4>Example 3: <span class="font-code">WindowEvent</span> and <span class="font-code">WindowListener</span> Interface</h4> 
     <img class="image-float-right" src="images/AWT_WindowEventDemo.png" alt="AWT_WindowEventDemo.png"> 
     <p>A <code>WindowEvent</code> is fired (to all its <code>WindowEvent</code> listeners) when a window (e.g., <code>Frame</code>) has been opened/closed, activated/deactivated, iconified/deiconified via the 3 buttons at the top-right corner or other means. The source of <code>WindowEvent</code> shall be a top-level window-container such as <code>Frame</code>.</p> 
     <p>A <code>WindowEvent</code> listener must implement <code>WindowListener</code> interface, which declares 7 <code>abstract</code> event-handling methods, as follows. Among them, the <code>windowClosing()</code>, which is called back upon clicking the window-close button, is the most commonly-used.</p> 
     <pre class="color-syntax float-clear">
public void <strong>windowClosing</strong>(WindowEvent evt)
   <span class="color-comment">// Called-back when the user attempts to close the window by clicking the window close button.
   // This is the most-frequently used handler.</span>
public void windowOpened(WindowEvent evt)
   <span class="color-comment">// Called-back the first time a window is made visible.</span>
public void windowClosed(WindowEvent evt)
   <span class="color-comment">// Called-back when a window has been closed as the result of calling dispose on the window.</span>
public void windowActivated(WindowEvent evt)
   <span class="color-comment">// Called-back when the Window is set to be the active Window.</span>
public void windowDeactivated(WindowEvent evt)
   <span class="color-comment">// Called-back when a Window is no longer the active Window.</span>
public void windowIconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a normal to a minimized state.</span>
public void windowDeiconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a minimized to a normal state.</span>
</pre> 
     <p>The following program added support for "close-window button" to <strong>Example 1: <code>AWTCounter</code></strong>.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></td> 
        <td> <pre>
import java.awt.*;       <span class="color-comment"> // Using AWT containers and components</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT events classes and listener interfaces</span>
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>WindowEventDemo</strong> extends Frame
      <span class="color-new">implements</span> ActionListener, <span class="color-new">WindowListener</span> {
     <span class="color-comment"> // This class acts as listener for ActionEvent and WindowEvent</span>
     <span class="color-comment"> // A Java class can extend</span> <span class="color-comment">only one superclass, but it can implement multiple interfaces.</span>
 
   private TextField tfCount;  <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;    <span class="color-comment">// Declare a Button component</span>
   private int count = 0;     <span class="color-comment"> // Counter's value</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemo() {
      setLayout(new FlowLayout());<span class="color-comment"> // "super" Frame sets to FlowLayout</span>
 
      add(new Label("Counter"));  <span class="color-comment"> // "super" Frame adds an anonymous Label</span>
 
      tfCount = new TextField("0", 10);<span class="color-comment"> // Construct the TextField</span>
      tfCount.setEditable(false);      <span class="color-comment"> // read-only</span>
      add(tfCount);                    <span class="color-comment"> // "super" Frame adds TextField</span>
 
      btnCount = new Button("Count"); <span class="color-comment"> // Construct the Button</span>
      add(btnCount);                  <span class="color-comment"> // "super" Frame adds Button</span>
 
      btnCount.addActionListener(this);
       <span class="color-comment"> // btnCount (source object) fires ActionEvent upon clicking</span>
       <span class="color-comment"> // btnCount adds "this" object as an ActionEvent listener</span>
 
      <span class="color-new">addWindowListener(this);</span>
       <span class="color-comment"> // "super" Frame (source object) fires WindowEvent.</span>
       <span class="color-comment"> // "super" Frame adds "this" object as a WindowEvent listener.</span>
 
      setTitle("WindowEvent Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(250, 100);           <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);            <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new WindowEventDemo(); <span class="color-comment"> // Let the construct do the job</span>
   }
 
   <span class="color-comment">/* ActionEvent handler */</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + "");
   }
 
   <span class="color-comment">/* WindowEvent handlers */</span>
  <span class="color-comment"> // Called back upon clicking close-window button</span>
   <span class="color-new">@Override
   public void windowClosing(WindowEvent evt) {
      System.exit(0); <span class="color-comment"> // Terminate the program</span>
   }
 
  <span class="color-comment"> // Not Used, but need to provide an empty body to compile.</span>
   @Override public void windowOpened(WindowEvent evt) { }
   @Override public void windowClosed(WindowEvent evt) { }
   @Override public void windowIconified(WindowEvent evt) { }
   @Override public void windowDeiconified(WindowEvent evt) { }
   @Override public void windowActivated(WindowEvent evt) { }
   @Override public void windowDeactivated(WindowEvent evt) { }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>In this example, we shall modify the earlier <code>AWTCounter</code> example to handle the <code>WindowEvent</code>. Recall that pushing the "close-window" button on the <code>AWTCounter</code> has no effect, as it did not handle the <code>WindowEvent</code> of <code>windowClosing()</code>. We included the <code>WindowEvent</code> handling codes in this example.</p> 
     <ol> 
      <li>We identify the <code>super</code> <code>Frame</code> as the source object.</li> 
      <li>The <code>Frame</code> fires the <code>WindowEvent</code> to all its registered <code>WindowEvent</code> listener(s).</li> 
      <li>We select <code>this</code> object as the <code>WindowEvent</code> listener.</li> 
      <li>We register <code>this</code> object as the <code>WindowEvent</code> listener to the source <code>Frame</code> via method <code>addWindowListener(this)</code>.</li> 
      <li>The <code>WindowEvent</code> listener (<code>this</code> class) is required to implement the <code>WindowListener</code> interface, which declares 7 abstract methods: <code>windowOpened()</code>, <code>windowClosed()</code>, <code>windowClosing()</code>, <code>windowActivated()</code>, <code>windowDeactivated()</code>, <code>windowIconified()</code> and <code>windowDeiconified()</code>.</li> 
      <li>We override the <code>windowClosing()</code> handler to terminate the program using <code>System.exit(0)</code>. We ignore the other 6 handlers, but required to provide an empty body for compilation.</li> 
     </ol> 
     <p>The sequence diagram is as follow:</p> 
     <img class="image-center" src="images/AWT_WindowEventSeqDiagram.png" alt="AWT_WindowEventSeqDiagram.png"> 
     <h4 id="MouseEventDemo">Example 4: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseListener</span> Interface</h4> 
     <p>A <code>MouseEvent</code> is fired when you press, release, or click (press followed by release) a mouse-button (left or right button) at the source object; or position the mouse-pointer at (enter) and away (exit) from the source object.</p> 
     <p>A <code>MouseEvent</code> listener must implement the <code>MouseListener</code> interface, which declares the following five <code>abstract</code> methods:</p> 
     <pre class="color-syntax">
public void <strong>mouseClicked</strong>(MouseEvent evt)
   <span class="color-comment">// Called-back when the mouse-button has been clicked (pressed followed by released) on the source.</span>
public void <strong>mousePressed</strong>(MouseEvent evt)
public void <strong>mouseReleased</strong>(MouseEvent evt)
   <span class="color-comment">// Called-back when a mouse-button has been pressed/released on the source.
   // A mouse-click invokes mousePressed(), mouseReleased() and mouseClicked().</span>
public void <strong>mouseEntered</strong>(MouseEvent evt)
public void <strong>mouseExited</strong>(MouseEvent evt) 
   <span class="color-comment">// Called-back when the mouse-pointer has entered/exited the source.</span></pre> 
     <img class="image-center" src="images/AWT_MouseEventDemo.png" alt="AWT_MouseEventDemo.png"> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
public class <strong>MouseEventDemo</strong> extends Frame <span class="color-new">implements MouseListener</span> {
   private TextField tfMouseX;<span class="color-comment"> // to display mouse-click-x</span>
   private TextField tfMouseY;<span class="color-comment"> // to display mouse-click-y</span>
 
  <span class="color-comment"> // Constructor - Setup the UI components and event handlers</span>
   public MouseEventDemo() {
      setLayout(new FlowLayout());<span class="color-comment"> // "super" frame sets its layout to FlowLayout</span>
 
     <span class="color-comment"> // Label (anonymous)</span>
      add(new Label("X-Click: "));<span class="color-comment"> // "super" frame adds Label component</span>
 
     <span class="color-comment"> // TextField</span>
      tfMouseX = new TextField(10);<span class="color-comment"> // 10 columns</span>
      tfMouseX.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfMouseX);<span class="color-comment">                // "super" frame adds TextField component</span>
 
     <span class="color-comment"> // Label (anonymous)</span>
      add(new Label("Y-Click: "));<span class="color-comment"> // "super" frame adds Label component</span>
 
     <span class="color-comment"> // TextField</span>
      tfMouseY = new TextField(10);
      tfMouseY.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfMouseY);<span class="color-comment">                // "super" frame adds TextField component</span>
 
      <span class="color-new">addMouseListener(this);</span>
         <span class="color-comment"> // "super" frame (source) fires the MouseEvent.</span>
         <span class="color-comment"> // "super" frame adds "this" object as a MouseEvent listener.</span>
 
      setTitle("MouseEvent Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(350, 100);          <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // "super" Frame shows</span>
   }
 
   public static void main(String[] args) {
      new MouseEventDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
 
  <span class="color-comment"> /* MouseEvent handlers */
   // Called back upon mouse clicked</span>
   <span class="color-new">@Override
   public void mouseClicked(MouseEvent evt) {
      tfMouseX.setText(evt.getX() + "");
      tfMouseY.setText(evt.getY() + "");
   }</span>
 
   <span class="color-comment">// Not used - need to provide an empty body to compile.</span>
   <span class="color-new">@Override public void mousePressed(MouseEvent evt) { }
   @Override public void mouseReleased(MouseEvent evt) { }
   @Override public void mouseEntered(MouseEvent evt) { }
   @Override public void mouseExited(MouseEvent evt) { }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>In this example, we setup a GUI with 4 components (two <code>Label</code>s and two non-editable <code>TextField</code>s) inside a top-level container <code>Frame</code>, arranged in <code>FlowLayout</code>.</p> 
     <p>To demonstrate the <code>MouseEvent</code>:</p> 
     <ol> 
      <li>We identity <code>super</code> <code>Frame</code> as the source object.</li> 
      <li>The <code>Frame</code> fires a <code>MouseEvent</code> to all its <code>MouseEvent</code> listener(s) when you click/press/release a mouse-button or enter/exit with the mouse-pointer.</li> 
      <li>We select <code>this</code> object as the <code>MouseEvent</code> listener.</li> 
      <li>We register <code>this</code> object as the <code>MouseEvent</code> listener to <code>super</code> <code>Frame</code> (source) via the method <code>addMouseListener(this)</code>.</li> 
      <li>The listener (<code>this</code> class) is required to implement the <code>MouseListener</code> interface, which declares 5 abstract methods: <code>mouseClicked()</code>, <code>mousePressed()</code>, <code>mouseReleased()</code>, <code>mouseEntered()</code>, and <code>mouseExit()</code>. We override the <code>mouseClicked()</code> to display the (x, y) co-ordinates of the mouse click on the two displayed <code>TextField</code>s. We ignore all the other handlers (for simplicity - but you need to provide an empty body for compilation).</li> 
     </ol> 
     <p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p> 
     <h4 id="MouseMotionDemo">Example 5: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseMotionListener</span> Interface</h4> 
     <p>A <code>MouseEvent</code> is also fired when you move and drag the mouse pointer at the source object. But you need to use <code>MouseMotionListener</code> to handle the mouse-move and mouse-drag. The <code>MouseMotionListener</code> interface declares the following two abstract methods:</p> 
     <pre class="color-syntax">
public void <strong>mouseDragged</strong>(MouseEvent e)
   <span class="color-comment">// Called-back when a mouse-button is pressed on the source component and then dragged.</span>
public void <strong>mouseMoved</strong>(MouseEvent e)
   <span class="color-comment">// Called-back when the mouse-pointer has been moved onto the source component but no buttons have been pushed.</span></pre> 
     <img class="image-center" src="images/AWT_MouseMotionDemo.png" alt="AWT_MouseMotionDemo.png"> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre></td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class MouseMotionDemo extends Frame
      <span class="color-new">implements</span> MouseListener, <span class="color-new">MouseMotionListener</span> {
      <span class="color-comment">// This class acts as MouseListener and MouseMotionListener</span>
 
   <span class="color-comment">// To display the (x, y) of the mouse-clicked</span>
   private TextField tfMouseClickX;
   private TextField tfMouseClickY;
   <span class="color-comment">// To display the (x, y) of the current mouse-pointer position</span>
   private TextField tfMousePositionX;
   private TextField tfMousePositionY;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public MouseMotionDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// "super" frame sets to FlowLayout</span>
 
      add(new Label("X-Click: "));
      tfMouseClickX = new TextField(10);
      tfMouseClickX.setEditable(false);
      add(tfMouseClickX);
      add(new Label("Y-Click: "));
      tfMouseClickY = new TextField(10);
      tfMouseClickY.setEditable(false);
      add(tfMouseClickY);
 
      add(new Label("X-Position: "));
      tfMousePositionX = new TextField(10);
      tfMousePositionX.setEditable(false);
      add(tfMousePositionX);
      add(new Label("Y-Position: "));
      tfMousePositionY = new TextField(10);
      tfMousePositionY.setEditable(false);
      add(tfMousePositionY);
 
      addMouseListener(this);
      <span class="color-new">addMouseMotionListener(this);</span>
        <span class="color-comment">// "super" frame (source) fires MouseEvent.</span>
        <span class="color-comment">// "super" frame adds "this" object as MouseListener and MouseMotionListener.</span>
 
      setTitle("MouseMotion Demo"); <span class="color-comment">// "super" Frame sets title</span>
      setSize(400, 120);            <span class="color-comment">// "super" Frame sets initial size</span>
      setVisible(true);             <span class="color-comment">// "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new MouseMotionDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/** MouseListener handlers */</span>
   <span class="color-comment">// Called back when a mouse-button has been clicked</span>
   @Override
   public void mouseClicked(MouseEvent evt) {
      tfMouseClickX.setText(evt.getX() + "");
      tfMouseClickY.setText(evt.getY() + "");
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void mousePressed(MouseEvent evt) { }
   @Override public void mouseReleased(MouseEvent evt) { }
   @Override public void mouseEntered(MouseEvent evt) { }
   @Override public void mouseExited(MouseEvent evt) { }
 
   <span class="color-comment">/** MouseMotionEvent handlers */</span>
   <span class="color-comment">// Called back when the mouse-pointer has been moved</span>
   <span class="color-new">@Override
   public void mouseMoved(MouseEvent evt) {
      tfMousePositionX.setText(evt.getX() + "");
      tfMousePositionY.setText(evt.getY() + "");
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void mouseDragged(MouseEvent evt) { }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>In this example, we shall illustrate both the <code>MouseListener</code> and <code>MouseMotionListener</code>.</p> 
     <ol> 
      <li>We identify the <code>super</code> <code>Frame</code> as the source, which fires the <code>MouseEvent</code> to its registered <code>MouseListener</code> and <code>MouseMotionListener</code><code></code>.</li> 
      <li>We select <code>this</code> object as the <code>MouseListener</code> and <code>MouseMotionListner</code>.</li> 
      <li>We register <code>this</code> object as the<code> </code>listener to <code>super</code> <code>Frame</code> via method <code>addMouseListener(this)</code> and <code>addMouseMotionListener(this)</code>.</li> 
      <li>The <code>MouseMotionListener</code> (<code>this</code> class) needs to implement 2 abstract methods: <code>mouseMoved()</code> and <code>mouseDragged()</code> declared in the <code>MouseMotionListener</code> interface.</li> 
      <li>We override the <code>mouseMoved()</code> to display the (x, y) position of the mouse pointer. We ignore the <code>MouseDragged()</code> handler by providing an empty body for compilation.</li> 
     </ol> 
     <p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p> 
     <h4 id="KeyEventDemo">Example 6: <span class="font-code">KeyEvent</span> and <span class="font-code">KeyListener</span> Interface</h4> 
     <p>A <code>KeyEvent</code> is fired when you pressed, released, and typed (pressed followed by released) a key on the source object. A <code>KeyEvent</code> listener must implement <code>KeyListener</code> interface, which declares three abstract methods:</p> 
     <pre class="color-syntax">
public void <strong>keyTyped</strong>(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been typed (pressed and released).</span>
public void <strong>keyPressed</strong>(KeyEvent e)
public void <strong>keyReleased</strong>(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been pressed or released.</span></pre> 
     <img class="image-center" src="images/AWT_KeyEventDemo.png" alt="AWT_KeyEventDemo.png"> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class KeyEventDemo extends Frame <span class="color-new">implements KeyListener</span> {
      <span class="color-comment">// This class acts as KeyEvent Listener</span>
 
   private TextField tfInput;  <span class="color-comment">// Single-line TextField to receive tfInput key</span>
   private TextArea taDisplay; <span class="color-comment">// Multi-line TextArea to taDisplay result</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public KeyEventDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// "super" frame sets to FlowLayout</span>
 
      add(new Label("Enter Text: "));
      tfInput = new TextField(10);
      add(tfInput);
      taDisplay = new TextArea(5, 40); <span class="color-comment">// 5 rows, 40 columns</span>
      add(taDisplay);
 
      <span class="color-new">tfInput.addKeyListener(this);</span>
         <span class="color-comment">// tfInput TextField (source) fires KeyEvent.</span>
         <span class="color-comment">// tfInput adds "this" object as a KeyEvent listener.</span>
 
      setTitle("KeyEvent Demo"); <span class="color-comment">// "super" Frame sets title</span>
      setSize(400, 200);         <span class="color-comment">// "super" Frame sets initial size</span>
      setVisible(true);          <span class="color-comment">// "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new KeyEventDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/** KeyEvent handlers */</span>
   <span class="color-comment">// Called back when a key has been typed (pressed and released)</span>
   <span class="color-new">@Override
   public void keyTyped(KeyEvent evt) {
      taDisplay.append("You have typed " + evt.getKeyChar() + "\n");
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void keyPressed(KeyEvent evt) { }
   @Override public void keyReleased(KeyEvent evt) { }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>In this example:</p> 
     <ol> 
      <li>We identify the <code>tfInput</code> (<code>TextField</code>) as the source object.</li> 
      <li>The source fires a <code>KeyEvent</code> when you press/release/type a key to all its <code>KeyEvent</code> listener(s).</li> 
      <li>We select <code>this</code> object as the <code>KeyEvent</code> listener.</li> 
      <li>We register <code>this</code> object as the <code>KeyEvent</code> listener to the source <code>TextField</code> via method <code>input.addKeyListener(this)</code>.</li> 
      <li>The <code>KeyEvent</code> listener (<code>this</code> class) needs to implement the <code>KeyListener</code> interface, which declares 3 abstract methods: <code>keyTyped()</code>, <code>keyPressed()</code>, <code>keyReleased()</code>.</li> 
      <li>We override the <code>keyTyped()</code> to display key typed on the display <code>TextArea</code>. We ignore the <code>keyPressed()</code> and <code>keyReleased()</code>.</li> 
     </ol> 
     <h3 id="innerclass">Nested (Inner) Classes</h3> 
     <p>A <em>nested class</em> (or commonly called <em>inner class</em>) is <em>a class defined inside another class</em> - introduced in JDK 1.1. As an illustration, two nested classes <code>MyNestedClass1</code> and <code>MyNestedClass2</code> are defined <em>inside</em> the definition of an outer class called <code>MyOuterClass</code>.</p> 
     <pre class="color-example">
public <span class="color-new">class</span> MyOuterClass {   <span class="color-comment">// outer class defined here</span>
   ......
   private <span class="color-new">class</span> MyNestedClass1 { ...... }  <span class="color-comment">// an nested class defined inside the outer class</span>
   public static <span class="color-new">class</span> MyNestedClass2 { ...... }  <span class="color-comment">// an "static" nested class defined inside the outer class</span>
   ......
}</pre> 
     <p>A nested class has these properties:</p> 
     <ol> 
      <li>A nested class is a proper class. That is, it could contain constructors, member variables and member methods. You can create an instance of a nested class via the <code>new</code> operator and constructor.</li> 
      <li>A nested class is a <em>member</em> of the outer class, just like any member variables and methods defined inside a class.</li> 
      <li>Most importantly, a nested class can access the <code>private</code> members (variables/methods) of the enclosing outer class, as it is at the <em>same level</em> as these <code>private</code> members. This is the property that makes inner class useful.</li> 
      <li>A nested class can have <code>private</code>, <code>public</code>, <code>protected</code>, or the <em>default</em> access, just like any member variables and methods defined inside a class. A <code>private</code> inner class is only accessible by the enclosing outer class, and is not accessible by any other classes. [An top-level outer class cannot be declared <code>private</code>, as no one can use a <code>private</code> outer class.]</li> 
      <li>A nested class can also be declared <code>static</code>, <code>final</code> or <code>abstract</code>, just like any ordinary class.</li> 
      <li>A nested class is NOT a <em>subclass</em> of the outer class. That is, the nested class does not inherit the variables and methods of the outer class. It is an <em>ordinary</em> self-contained class. [Nonetheless, you could declare it as a subclass of the outer class, via keyword "<code>extends <em>OuterClassName</em></code>", in the nested class's definition.]</li> 
     </ol> 
     <p>The usages of nested class are:</p> 
     <ol> 
      <li>To control visibilities (of the member variables and methods) between inner/outer class. The nested class, being defined inside an outer class, can access <code>private</code> members of the outer class.</li> 
      <li>To place a piece of class definition codes <em>closer</em> to where it is going to be used, to make the program clearer and easier to understand.</li> 
      <li>For namespace management.</li> 
     </ol> 
     <h4>Example 7: A Named Inner Class as Event Listener</h4> 
     <p>A nested class is useful if you need a <em>small</em> class which relies on the enclosing outer class for its private variables and methods. It is ideal in an event-driven environment for implementing event handlers. This is because the event handling methods (in a listener) often require access to the private variables (e.g., a private <code>TextField</code>) of the outer class.</p> 
     <p>In this example (modified from Example 1 <code>AWTCounter</code>), instead of using "<code>this</code>" as the <code>ActionEvent</code> listener for the <code>Button</code>, we define a new class called <code>BtnCountListener</code>, and create an instance of <code>BtnCountListener</code> as the <code>ActionEvent</code> listener for the <code>btnCount</code>. The <code>BtnCountListener</code> needs to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> handler. Since "<code>this</code>" is no long a <code>ActionListener</code>, we remove the "<code>implements ActionListener</code>" from "<code>this</code>" class's definition.</p> 
     <p><code>BtnCountListener</code> needs to be defined as an inner class, as it needs to access private variables (<code>count</code> and <code>tfCount</code>) of the outer class.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTCounterNamedInnerClass extends Frame {
   <span class="color-comment">// This class is NOT a ActionListener, hence, it does not implement ActionListener interface</span>
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these "private" variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounterNamedInnerClass () {
      setLayout(new FlowLayout());  <span class="color-comment">// "super" Frame sets to FlowLayout</span>
      add(new Label("Counter"));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// "super" Frame adds tfCount</span>
 
      btnCount = new Button("Count");
      add(btnCount);                <span class="color-comment">// "super" Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of BtnCountListener (a named inner class).</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      <span class="color-new">btnCount.addActionListener(new BtnCountListener());</span>
 
      setTitle("AWT Counter");
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounterNamedInnerClass(); <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnCountListener is a "named inner class" used as ActionListener.
    * This inner class can access private variables of the outer class.
    */</span>
   <span class="color-new">private class BtnCountListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         ++count;
         tfCount.setText(count + "");
      }
   }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5>Dissecting the Program</h5> 
     <ul> 
      <li>An inner class named <code>BtnCountListener</code> is used as the <code>ActionListner</code>.</li> 
      <li>An anonymous instance of the <code>BtnCountListener</code> inner class is constructed. The <code>btnCount</code> source object adds this instance as a listener, as follows: <pre class="color-example">
btnCount.addActionListener(new BtnCountListener());
</pre> </li> 
      <li>The inner class can access the <code>private</code> variable <code>tfCount</code> and <code>count</code> of the outer class.</li> 
      <li>Since "<code>this</code>" is no longer a listener, we remove the "<code>implements ActionListener</code>" from <code>this</code> class' definition.</li> 
      <li>The inner class is compiled into <code>AWTCount$BtnCountListener.class</code>, in the format of <code><em>OuterClassName$InnerClassName</em>.class</code>.</li> 
     </ul> 
     <h5>(Advanced) Using an Ordinary (Outer) Class as Listener</h5> 
     <p>Try moving the <code>BtnCountListener</code> class outside, and define it as an ordinary class. You would need to pass a reference of the <code>AWTConnter</code> into the constructor of <code>BtnCountListener</code>, and use this reference to access variables <code>tfCount</code> and <code>count</code>, through <code>public</code> getters or granting them to <code>public</code> access.</p> 
     <pre class="color-example">
<span class="color-comment">// An ordinary outer class used as ActionListener for the Button</span>
public class BtnCountListener implements ActionListener {
   AWTCounter frame;
   public BtnCountListener(AWTCounter frame) {
      this.frame = frame;
   }
   
   @Override
   public void actionPerformed(ActionEvent evt) {
      frame.count++;
      frame.tfCount.setText(frame.count + "");
   }
}</pre> 
     <p>This code is messy! Inner class provides a much cleaner solution!</p> 
     <h4>Example 8: An Anonymous Inner Class as Event Listener</h4> 
     <p>Instead of using a <em>named inner class</em> (called <code>BtnCountListner</code> in the previous example), we shall use an inner class without a name, known as <em>anonymous inner class</em> as the <code>ActionListener</code> in this example.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTCounterAnonymousInnerClass extends Frame {
   <span class="color-comment">// This class is NOT a ActionListener, hence, it does not implement ActionListener interface</span>
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these private variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounterAnonymousInnerClass () {
      setLayout(new FlowLayout());  <span class="color-comment">// "super" Frame sets to FlowLayout</span>
      add(new Label("Counter"));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// "super" Frame adds tfCount</span>
 
      btnCount = new Button("Count");
      add(btnCount);                <span class="color-comment">// "super" Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of an anonymous class.</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      btnCount.addActionListener(<span class="color-new">new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + "");
         }
      }</span>);
 
      setTitle("AWT Counter");
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounterAnonymousInnerClass(); <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5>Dissecting the Program</h5> 
     <ul> 
      <li>Again, "<code>this</code>" class is NOT used as the <code>ActionEvent</code> listener. Hence, we remove the "<code>implements ActionListener</code>" from <code>this</code> class' definition.</li> 
      <li>The anonymous inner class is given a name generated by the compiler, and compiled into <code><em>OuterClassName</em>$<em>n</em>.class</code>, where <em><code>n</code></em> is a running number of the inner classes of this outer class.</li> 
      <li>An anonymous instance of an anonymous inner class is constructed, and passed as the argument of the <code>addActionListener()</code> method as follows: <pre class="color-example">
btnCount.addActionListener(<span class="color-new">new ActionListener() {
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + "");
   }
}</span>);</pre> <p>The above codes is equivalent to and compiled as:</p> <pre class="color-example">
private class <em><strong>N</strong></em> implements ActionListener {  <span class="color-comment">// <em>N</em> is a running number of the inner classes created</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + "");
   }
}
btnCount.addActionListener(new <em><strong>N</strong></em>());

<span class="color-comment">// Or</span>
<em><strong>N</strong></em> <strong><em>n</em></strong> = new <em><strong>N</strong></em>()
btnCount.addActionListener(<strong><em>n</em></strong>);</pre></li> 
     </ul> 
     <h5>Properties of Anonymous Inner Class</h5> 
     <ol> 
      <li>The anonymous inner class is define inside a method, instead of a member of the outer class (class member). It is <em>local</em> to the method and cannot be marked with access modifier (such as <code>public</code>, <code>private</code>) or <code>static</code>, just like any local variable of a method.</li> 
      <li>An anonymous inner class must always extend a superclass or implement an interface. The keyword "<code>extends</code>" or "<code>implements</code>" is NOT required in its declaration. An anonymous inner class must implement all the abstract methods in the superclass or in the interface.</li> 
      <li>An anonymous inner class always uses the default (no-arg) constructor from its superclass to create an instance. If an anonymous inner class implements an interface, it uses the <code>java.lang.Object()</code>.</li> 
      <li>An anonymous inner class is compiled into a class named <code>OuterClassName$<em>n</em>.class</code>, where <code><em>n</em></code> is a running number of inner classes within the outer class.</li> 
      <li>An instance of an anonymous inner class is constructed via this syntax: <pre class="color-syntax">
new <em>SuperClassName</em>/<em>InterfaceName</em>() {  <span class="color-comment">// extends superclass or implements interface
                                      // invoke the default no-arg constructor or Object[]</span>
  <span class="color-comment">// Implement abstract methods in superclass/interface
  // More methods if necessary
  ......</span>
}</pre> <p>The created instance can be assigned to a variable or used as an argument of a method.</p> </li> 
     </ol> 
     <h4>Example 9: An Anonymous Inner Class for Each Source</h4> 
     <img class="image-float-right" src="images/AWT_Counter3Buttons.png" alt="AWT_Counter3Buttons.png"> 
     <p>Let's modify our <code>AWTCounter</code> example to include 3 buttons for counting up, counting down, and reset the count, respectively. We shall attach an anonymous inner class as the listener to each of buttons.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTCounter3Buttons extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3Buttons () {
      setLayout(new FlowLayout());
      add(new Label("Counter"));   <span class="color-comment">// an anonymous instance of Label</span>
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfCount);                <span class="color-comment">// "super" Frame adds tfCount</span>
 
      btnCountUp = new Button("Count Up");
      add(btnCountUp);
      <span class="color-comment">// Construct an anonymous instance of an anonymous inner class.</span>
      <span class="color-comment">// The source Button adds the anonymous instance as ActionEvent listener</span>
      <span class="color-new">btnCountUp.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + "");
         }
      });</span>
 
      btnCountDown = new Button("Count Down");
      add(btnCountDown);
      <span class="color-new">btnCountDown.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count--;
            tfCount.setText(count + "");
         }
      });</span>
 
      btnReset = new Button("Reset");
      add(btnReset);
      <span class="color-new">btnReset.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count = 0;
            tfCount.setText("0");
         }
      });</span>
 
      setTitle("AWT Counter");
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3Buttons();  <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5>Dissecting the Program</h5> 
     <ol> 
      <li>Each of the <code>Button</code>s uses one anonymous instance of an anonymous inner class as its <code>ActionEvent</code> listener.</li> 
     </ol> 
     <h4>Example 10: Using the Same Listener Instance for All the Buttons</h4> 
     <p>If you use the same instance as the listener for all the 3 buttons, you need to determine which button has fired the event. It is because all the 3 buttons trigger the same event-handler method.</p> 
     <h5>Using <span class="font-code">ActionEvent</span>'s <span class="font-code">getActionCommand()</span></h5> 
     <p>In the following example, we use the same instance of a "named" inner class as the listener for all the 3 buttons. The listener needs to determine which button has fired the event. This can be accomplished via the <code>ActionEvent</code>'s <code>getActionCommonad()</code> method, which returns the button's label.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTCounter3Buttons1Listener extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3Buttons1Listener () {
      setLayout(new FlowLayout());
      add(new Label("Counter"));
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button("Count Up");
      add(btnCountUp);
      btnCountDown = new Button("Count Down");
      add(btnCountDown);
      btnReset = new Button("Reset");
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of the "named" inner class BtnListener.</span>
      <span class="color-new">BtnListener listener = new BtnListener();</span>
      <span class="color-comment">// Use the same listener instance for all the 3 Buttons.</span>
      <span class="color-new">btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);</span>
 
      setTitle("AWT Counter");
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3Buttons1Listener();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnListener is a named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class BtnListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button fired the event.</span>
         <span class="color-comment">// the getActionCommand() returns the Button's label</span>
         String btnLabel = evt.getActionCommand();
         if (btnLabel.equals("Count Up")) {
            ++count;
         } else if (btnLabel.equals("Count Down")) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + "");
      }
   }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5>Using <span class="font-code">getSource()</span> of <span class="font-code">EventObject</span></h5> 
     <p>Besides the <code>getActionCommand()</code>, which is only available for <code>ActionEvent</code>, you can use the <code>getSource()</code> method, which is available to all event objects, to retrieve a reference to the source object that has fired the event. <code>getSource()</code> returns a <code>java.lang.Object</code>. You may need to downcast it to the proper type of the source object. For example,</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
public class AWTCounter3ButtonsGetSource extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3ButtonsGetSource () {
      setLayout(new FlowLayout());
      add(new Label("Counter"));
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button("Count Up");
      add(btnCountUp);
      btnCountDown = new Button("Count Down");
      add(btnCountDown);
      btnReset = new Button("Reset");
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of inner class BtnListener.</span>
      <span class="color-new">BtnListener listener = new BtnListener();</span>
      <span class="color-comment">// Use the same listener instance to all the 3 Buttons.</span>
      <span class="color-new">btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);</span>
 
      setTitle("AWT Counter");
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3ButtonsGetSource();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnListener is a named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class BtnListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button has fired the event.</span>
         Button source = (Button)evt.getSource();
               <span class="color-comment">// Get a reference of the source that has fired the event.</span>
               <span class="color-comment">// getSource() returns a java.lang.Object. Downcast back to Button.</span>
         if (source == btnCountUp) {
            ++count;
         } else if (source == btnCountDown) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + "");
      }
   }</span>
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h3>Event Listener's Adapter Classes</h3> 
     <h4>Example 11: <span class="font-code">WindowAdapter</span> for <span class="font-code">WindowListener</span></h4> 
     <h5>Using <span class="font-code">WindowListener</span> Interface</h5> 
     <p>Refer to the <code>WindowEventDemo</code>, a <code>WindowEvent</code> listener is required to implement the <code>WindowListener</code> interface, which declares 7 <code>abstract</code> methods. Although we are only interested in <code>windowClosing()</code>, we need to provide an empty body to the other 6 <code>abstract</code> methods in order to compile the program. This is tedious, e.g., we can rewrite the <code>WindowEventDemo</code> using an inner class implementing <code>ActionListener</code> as follows:</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class WindowEventDemoWithInnerClass extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoWithInnerClass () {
      setLayout(new FlowLayout());
      add(new Label("Counter"));
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button("Count");
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + "");
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that implements WindowListener.</span>
      <span class="color-comment">// "super" Frame adds this instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowListener() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// terminate the program</span>
         }
         <span class="color-comment">// Need to provide an empty body for compilation</span>
         @Override public void windowOpened(WindowEvent evt) { }
         @Override public void windowClosed(WindowEvent evt) { }
         @Override public void windowIconified(WindowEvent evt) { }
         @Override public void windowDeiconified(WindowEvent evt) { }
         @Override public void windowActivated(WindowEvent evt) { }
         @Override public void windowDeactivated(WindowEvent evt) { }
      });</span>
 
      setTitle("WindowEvent Demo");
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new WindowEventDemoWithInnerClass();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5>Using <span class="font-code">WindowAdapter</span> Superclass</h5> 
     <p>An <em>adapter</em> class called <code>WindowAdapter</code> is therefore provided, which implements the <code>WindowListener</code> interface and provides default implementations to all the 7 <code>abstract</code> methods. You can then derive a subclass from <code>WindowAdapter</code> and override only methods of interest and leave the rest to their default implementation. For example,</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class WindowEventDemoAdapter extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoAdapter () {
      setLayout(new FlowLayout());
      add(new Label("Counter"));
      tfCount = new TextField("0", 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button("Count");
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + "");
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that extends WindowAdapter.</span>
      <span class="color-comment">// "super" Frame adds the instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowAdapter() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// Terminate the program</span>
         }
      });</span>
 
      setTitle("WindowEvent Demo");
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      new WindowEventDemoAdapter();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>Clearly, the adapter greatly simplifies the codes.</p> 
     <h4>Other Event-Listener Adapter Classes</h4> 
     <p>Similarly, adapter classes such as <code>MouseAdapter</code>,<code> MouseMotionAdapter</code>, <code>KeyAdapter</code>, <code>FocusAdapter</code> are available for <code>MouseListener</code>, <code>MouseMotionListener</code>, <code>KeyListener</code>, and <code>FocusListener</code>, respectively.</p> 
     <p>There is no <code>ActionAdapter</code> for <code>ActionListener</code>, because there is only one <code>abstract</code> method (i.e. <code>actionPerformed()</code>) declared in the <code>ActionListener</code> interface. This method has to be overridden and there is no need for an adapter.</p> 
     <h3>Layout Managers and Panel</h3> 
     <p>A container has a so-called <em>layout manager</em> to arrange its components. The layout managers provide a level of abstraction to map your user interface on all windowing systems, so that the layout can be <em>platform-independent</em>.</p> 
     <p>AWT provides the following layout managers (in package <code>java.awt</code>): <code>FlowLayout</code>, <code>GridLayout</code>, <code>BorderLayout</code>, <code>GridBagLayout</code>, <code>BoxLayout</code>, <code>CardLayout</code>, and others. Swing added more layout manager in package <code>javax.swing</code>, to be described later.</p> 
     <h5>Container's <span class="font-code">setLayout()</span> method</h5> 
     <p>A container has a <code>setLayout()</code> method to set its layout manager:</p> 
     <pre class="color-syntax">
<span class="color-comment">// java.awt.Container</span>
public void setLayout(LayoutManager mgr)</pre> 
     <p>To set up the layout of a <code>Container</code> (such as <code>Frame</code>, <code>JFrame</code>, <code>Panel</code>, or <code>JPanel</code>), you have to:</p> 
     <ol> 
      <li>Construct an instance of the chosen layout object, via <code>new</code> and constructor, e.g., <code>new FlowLayout()</code>)</li> 
      <li>Invoke the <code>setLayout()</code> method of the <code>Container</code>, with the layout object created as the argument;</li> 
      <li>Place the GUI components into the <code>Container</code> using the <code>add()</code> method in the correct order; or into the correct zones.</li> 
     </ol> 
     <p>For example,</p> 
     <pre class="color-example">
<span class="color-comment">// Allocate a Panel (container)</span>
Panel pnl = new Panel();  
<span class="color-comment">// Allocate a new Layout object. The Panel container sets to this layout.</span>
pnl.setLayout(new FlowLayout());
<span class="color-comment">// The Panel container adds components in the proper order.</span>
pnl.add(new JLabel("One"));
pnl.add(new JLabel("Two"));
pnl.add(new JLabel("Three"));
......</pre> 
     <h5>Container's <span class="font-code">getLayout()</span> method</h5> 
     <p>You can get the current layout via <code>Container</code>'s <code>getLayout()</code> method.</p> 
     <pre class="color-example">
Panel pnl = new Panel();
System.out.println(pnl.getLayout());
      <span class="color-comment">// java.awt.FlowLayout[hgap=5,vgap=5,align=center]</span></pre> 
     <h5>Panel's Initial Layout</h5> 
     <p><code>Panel</code> (and Swing's <code>JPanel</code>) provides a constructor to set its initial layout manager. It is because a primary function of <code>Panel</code> is to layout a group of component in a particular layout.</p> 
     <pre class="color-syntax">
public void Panel(LayoutManager <em>layout</em>)  
   <span class="color-comment">// Construct a Panel in the given layout
   // By default, Panel (and JPanel) has FlowLayout</span>
 
<span class="color-comment">// For example, create a Panel in BorderLayout</span>
Panel pnl = new Panel(new BorderLayout());</pre> 
     <h4><span class="font-code">FlowLayout</span></h4> 
     <img class="image-float-right" src="images/AWT_FlowLayout.gif" alt="AWT_FlowLayout.gif"> 
     <p>In the <code>java.awt.FlowLayout</code>, components are arranged from left-to-right inside the container in the order that they are added (via method <code>aContainer.add(aComponent)</code>). When one row is filled, a new row will be started. The actual appearance depends on the width of the display window.</p> 
     <p class="underline float-clear">Constructors</p> 
     <pre class="color-syntax">
public <strong>FlowLayout</strong>();
public <strong>FlowLayout</strong>(int <em>alignment</em>);
public <strong>FlowLayout</strong>(int <em>alignment</em>, int <em>hgap</em>, int <em>vgap</em>);
<span class="color-comment">  // <em>alignment</em>: FlowLayout.LEFT (or LEADING), FlowLayout.RIGHT (or TRAILING), or FlowLayout.CENTER
  // <em>hgap</em>, <em>vgap</em>: horizontal/vertical gap between the components
  // By default: <em>hgap</em> = 5, <em>vgap </em>= 5, <em>alignment </em>= FlowLayout.CENTER</span>
</pre> 
     <p class="underline">Example</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTFlowLayoutDemo extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTFlowLayoutDemo () {
      <span class="color-new">setLayout(new FlowLayout());</span>
        <span class="color-comment"> // "super" Frame sets layout to FlowLayout, which arranges the components</span>
        <span class="color-comment"> // from left-to-right, and flow from top-to-bottom.</span>
 
      <span class="color-new">btn1 = new Button("Button 1");
      add(btn1);
      btn2 = new Button("This is Button 2");
      add(btn2);
      btn3 = new Button("3");
      add(btn3);
      btn4 = new Button("Another Button 4");
      add(btn4);
      btn5 = new Button("Button 5");
      add(btn5);
      btn6 = new Button("One More Button 6");
      add(btn6);</span>
 
      setTitle("FlowLayout Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTFlowLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h4><span class="font-code">GridLayout</span></h4> 
     <img class="image-float-right" src="images/AWT_GridLayout.gif" alt="AWT_GridLayout.gif"> 
     <p>In <code>java.awt.GridLayout</code>, components are arranged in a grid (matrix) of rows and columns inside the <code>Container</code>. Components are added in a left-to-right, top-to-bottom manner in the order they are added (via method <code><em>aContainer</em>.add(<em>aComponent</em>)</code>).</p> 
     <p class="underline float-clear">Constructors</p> 
     <pre class="color-syntax">
public <strong>GridLayout</strong>(int <em>rows</em>, int <em>columns</em>);
public <strong>GridLayout</strong>(int <em>rows</em>, int <em>columns</em>, int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default: rows = 1, cols = 0, hgap = 0, vgap = 0</span></pre> 
     <p class="underline">Example</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTGridLayoutDemo extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTGridLayoutDemo () {
      <span class="color-new">setLayout(new GridLayout(3, 2, 3, 3));</span>
        <span class="color-comment"> // "super" Frame sets layout to 3x2 GridLayout, horizontal and verical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added from left-to-right, top-to-bottom</span>
      <span class="color-new">btn1 = new Button("Button 1");
      add(btn1);
      btn2 = new Button("This is Button 2");
      add(btn2);
      btn3 = new Button("3");
      add(btn3);
      btn4 = new Button("Another Button 4");
      add(btn4);
      btn5 = new Button("Button 5");
      add(btn5);
      btn6 = new Button("One More Button 6");
      add(btn6);</span>
 
      setTitle("GridLayout Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTGridLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h4><span class="font-code">BorderLayout</span></h4> 
     <img class="image-float-right" src="images/AWT_BorderLayout.gif" alt="AWT_BorderLayout.gif"> 
     <p>In <code>java.awt.BorderLayout</code>, the container is divided into 5 zones: <code>EAST</code>, <code>WEST</code>, <code>SOUTH</code>, <code>NORTH</code>, and <code>CENTER</code>. Components are added using method <code><em>aContainer</em>.add(<em>acomponent</em>, <em>zone</em>)</code>, where <code><em>zone</em></code> is either <code>BorderLayout.NORTH</code> (or <code>PAGE_START</code>), <code></code><code>BorderLayout.SOUTH</code> (or <code>PAGE_END</code>), <code>BorderLayout.WEST</code> (or <code>LINE_START</code>), <code>BorderLayout.EAST</code> (or <code>LINE_END</code>), or <code>BorderLayout.CENTER</code>.</p> 
     <p>You need not place components to all the 5 zones. The <code>NORTH</code> and <code>SOUTH</code> components may be stretched horizontally; the <code>EAST</code> and <code>WEST</code> components may be stretched vertically; the <code>CENTER</code> component may stretch both horizontally and vertically to fill any space left over.</p> 
     <p class="underline float-clear">Constructors</p> 
     <pre class="color-syntax">
public <strong>BorderLayout</strong>();
public <strong>BorderLayout</strong>(int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default hgap = 0, vgap = 0</span></pre> 
     <p class="underline">Example</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTBorderLayoutDemo extends Frame {
   private Button btnNorth, btnSouth, btnCenter, btnEast, btnWest;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTBorderLayoutDemo () {
      <span class="color-new">setLayout(new BorderLayout(3, 3));</span>
        <span class="color-comment"> // "super" Frame sets layout to BorderLayout,</span>
        <span class="color-comment"> // horizontal and vertical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added to the specified zone</span>
      <span class="color-new">btnNorth = new Button("NORTH");
      add(btnNorth, BorderLayout.NORTH);
      btnSouth = new Button("SOUTH");
      add(btnSouth, BorderLayout.SOUTH);
      btnCenter = new Button("CENTER");
      add(btnCenter, BorderLayout.CENTER);
      btnEast = new Button("EAST");
      add(btnEast, BorderLayout.EAST);
      btnWest = new Button("WEST");
      add(btnWest, BorderLayout.WEST);</span>
 
      setTitle("BorderLayout Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(280, 150);            <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTBorderLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h4>Using <span class="font-code">Panel</span>s as Sub-Container to Organize Components</h4> 
     <img class="image-float-right" src="images/Swing_JPanel.gif" alt="Swing_JPanel.gif"> 
     <p>An AWT <code>Panel</code> is a rectangular pane, which can be used as sub-container to organized a group of related components in a specific layout (e.g., <code>FlowLayout</code>, <code>BorderLayout</code>). <code>Panel</code>s are <em>secondary</em> containers, which shall be added into a top-level container (such as <code>Frame</code>), or another <code>Panel</code>.</p> 
     <p>For example, the following figure shows a <code>Frame</code> in <code>BorderLayout</code> containing two <code>Panels</code> - <code>panelResult</code> in <code>FlowLayout</code> and <code>panelButtons</code> in <code>GridLayout</code>. <code>panelResult</code> is added to the <code>NORTH</code>, and <code>panelButtons</code> is added to the <code>CENTER</code>.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre> </td> 
        <td> <pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTPanelDemo extends Frame {
   private Button[] btnNumbers; <span class="color-comment"> // Array of 10 numeric Buttons</span>
   private Button btnHash, btnStar;
   private TextField tfDisplay;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTPanelDemo () {
     <span class="color-comment"> // Set up display panel</span>
      Panel panelDisplay = new Panel(new FlowLayout());
      tfDisplay = new TextField("0", 20);
      panelDisplay.add(tfDisplay);
 
     <span class="color-comment"> // Set up button panel</span>
      Panel panelButtons = new Panel(new GridLayout(4, 3));
      btnNumbers = new Button[10];  <span class="color-comment">// Construct an array of 10 numeric Buttons</span>
      btnNumbers[1] = new Button("1");  <span class="color-comment">// Construct Button "1"</span>
      panelButtons.add(btnNumbers[1]);  <span class="color-comment">// The Panel adds this Button</span>
      btnNumbers[2] = new Button("2");
      panelButtons.add(btnNumbers[2]);
      btnNumbers[3] = new Button("3");
      panelButtons.add(btnNumbers[3]);
      btnNumbers[4] = new Button("4");
      panelButtons.add(btnNumbers[4]);
      btnNumbers[5] = new Button("5");
      panelButtons.add(btnNumbers[5]);
      btnNumbers[6] = new Button("6");
      panelButtons.add(btnNumbers[6]);
      btnNumbers[7] = new Button("7");
      panelButtons.add(btnNumbers[7]);
      btnNumbers[8] = new Button("8");
      panelButtons.add(btnNumbers[8]);
      btnNumbers[9] = new Button("9");
      panelButtons.add(btnNumbers[9]);
        <span class="color-comment">    // You should use a loop for the above statements!!!</span>
      btnStar = new Button("*");
      panelButtons.add(btnStar);
      btnNumbers[0] = new Button("0");
      panelButtons.add(btnNumbers[0]);
      btnHash = new Button("#");
      panelButtons.add(btnHash);
 
      setLayout(new BorderLayout()); <span class="color-comment"> // "super" Frame sets to BorderLayout</span>
      add(panelDisplay, BorderLayout.NORTH);
      add(panelButtons, BorderLayout.CENTER);
 
      setTitle("BorderLayout Demo");<span class="color-comment"> // "super" Frame sets title</span>
      setSize(200, 200);            <span class="color-comment"> // "super" Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTPanelDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h4><span class="font-code">BoxLayout</span></h4> 
     <p>BoxLayout arrange components in a single row or column. It respects components' requests on the minimum sizes.</p> 
     <p>[TODO] Example and diagram</p> 
     <h3>Swing</h3> 
     <h4>Introduction</h4> 
     <p>Swing is part of the so-called "Java Foundation Classes (JFC)" (have you heard of MFC?), which was introduced in 1997 after the release of JDK 1.1. JFC was subsequently included as an integral part of JDK since JDK 1.2. JFC consists of:</p> 
     <ul> 
      <li>Swing API: for advanced graphical programming.</li> 
      <li>Accessibility API: provides assistive technology for the disabled.</li> 
      <li>Java 2D API: for high quality 2D graphics and images.</li> 
      <li>Pluggable look and feel supports.</li> 
      <li>Drag-and-drop support between Java and native applications.</li> 
     </ul> 
     <p>The goal of Java GUI programming is to allow the programmer to build GUI that looks good on ALL platforms. JDK 1.0's AWT was awkward and non-object-oriented (using many <code>event.getSource()</code>). JDK 1.1's AWT introduced event-delegation (event-driven) model, much clearer and object-oriented. JDK 1.1 also introduced inner class and JavaBeans  a component programming model for visual programming environment (similar to Visual Basic and Dephi).</p> 
     <p>Swing appeared after JDK 1.1. It was introduced into JDK 1.1 as part of an add-on JFC (Java Foundation Classes). Swing is a rich set of easy-to-use, easy-to-understand JavaBean GUI components that can be dragged and dropped as "GUI builders" in visual programming environment. Swing is now an integral part of Java since JDK 1.2.</p> 
     <h4>Swing's Features</h4> 
     <p>Swing is huge (consists of 18 packages of 737 classes as in JDK 1.8) and has great depth. Compared with AWT, Swing provides a huge and comprehensive collection of reusable GUI components, as shown in the Figure below (extracted form Swing Tutorial).</p> 
     <img class="image-center" src="images/Swing_Components.png" alt="Swing_Components.png"> 
     <p>The main features of Swing are (extracted from the Swing website):</p> 
     <ol> 
      <li>Swing is written in pure Java (except a few classes) and therefore is 100% portable.</li> 
      <li>Swing components are <em>lightweight</em>. The AWT components are <em>heavyweight</em> (in terms of system resource utilization). Each AWT component has its own opaque native display, and always displays on top of the lightweight components. AWT components rely heavily on the underlying windowing subsystem of the native operating system. For example, an AWT button ties to an actual button in the underlying native windowing subsystem, and relies on the native windowing subsystem for their rendering and processing. Swing components (<code>JComponent</code>s) are written in Java. They are generally not "weight-down" by complex GUI considerations imposed by the underlying windowing subsystem.</li> 
      <li>Swing components support <em>pluggable look-and-feel</em>. You can choose between <em>Java look-and-feel</em> and the <em>look-and-feel of the underlying OS</em> (e.g., Windows, UNIX or Mac). If the later is chosen, a Swing button runs on the Windows looks like a Windows' button and feels like a Window's button. Similarly, a Swing button runs on the UNIX looks like a UNIX's button and feels like a UNIX's button.<br> <img src="images/Swing_LaFJava.png" alt="Swing_LaFJava.png"> <img src="images/Swing_LaFNativeSystem.png" alt="Swing_LaFNativeSystem.png"><br> <img src="images/Swing_LaFNimbus.png" alt="Swing_LaFNimbus.png"> <img src="images/Swing_LaFMotif.png" alt="Swing_LaFMotif.png"> </li> 
      <li>Swing supports <em>mouse-less operation</em>, i.e., it can operate entirely using keyboard.</li> 
      <li>Swing components support "tool-tips".</li> 
      <li>Swing components are <em>JavaBeans</em>  a Component-based Model used in Visual Programming (like Visual Basic). You can drag-and-drop a Swing component into a "design form" using a "GUI builder" and double-click to attach an event handler.</li> 
      <li>Swing application uses AWT event-handling classes (in package <code>java.awt.event</code>). Swing added some new classes in package <code>javax.swing.event</code>, but they are not frequently used.</li> 
      <li>Swing application uses AWT's layout manager (such as <code>FlowLayout</code> and <code>BorderLayout</code> in package <code>java.awt</code>). It added new layout managers, such as <code>Springs</code>, <code>Struts</code>, and <code>BoxLayout</code> (in package <code>javax.swing</code>).</li> 
      <li>Swing implements <em>double-buffering</em> and automatic repaint batching for smoother screen repaint.</li> 
      <li>Swing introduces <code>JLayeredPane</code> and <code>JInternalFrame</code> for creating Multiple Document Interface (MDI) applications.</li> 
      <li>Swing supports floating toolbars (in <code>JToolBar</code>), splitter control, "undo".</li> 
      <li>Others - check the Swing website.</li> 
     </ol> 
     <h4>Using Swing API</h4> 
     <p>If you understood the AWT programming (in particular, container/component and event-handling), switching over to Swing (or any other Graphics packages) is straight-forward.</p> 
     <h5>Swing's Components</h5> 
     <p>Compared with the AWT component classes (in package <code>java.awt</code>), Swing component classes (in package <code>javax.swing</code>) begin with a prefix <code>"J"</code>, e.g., <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, <code>JPanel</code>, <code>JFrame</code>, or <code>JApplet</code>.</p> 
     <img class="image-center" src="images/Swing_ClassDiagram.png" alt="Swing_ClassDiagram.png"> 
     <p>The above figure shows the class hierarchy of the swing GUI classes. Similar to AWT, there are two groups of classes: <em>container</em>s and <em>component</em>s. A container is used to hold components. A container can also hold containers because it is a (subclass of) component.</p> 
     <p>As a rule, do not mix heavyweight AWT components and lightweight Swing components in the same program, as the heavyweight components will always be painted <em>on top of</em> the lightweight components.</p> 
     <h5>Swing's Top-Level and Secondary Containers</h5> 
     <img class="image-float-right" src="images/Swing_ContentPane.png" alt="Swing_ContentPane.png"> 
     <p>Just like AWT application, a Swing application requires a <em>top-level container</em>. There are three top-level containers in Swing:</p> 
     <ol> 
      <li><code>JFrame</code>: used for the application's main window (with an icon, a title, minimize/maximize/close buttons, an optional menu-bar, and a content-pane), as illustrated.</li> 
      <li><code>JDialog</code>: used for secondary pop-up window (with a title, a close button, and a content-pane).</li> 
      <li><code>JApplet</code>: used for the applet's display-area (content-pane) inside a browsers window.</li> 
     </ol> 
     <p>Similarly to AWT, there are <em>secondary containers</em> (such as <code>JPanel</code>) which can be used to group and layout relevant components.</p> 
     <h5>The Content-Pane of Swing's Top-Level Container</h5> 
     <p>However, unlike AWT, the <code>JComponents</code> shall not be added onto the top-level container (e.g., <code>JFrame</code>, <code>JApplet</code>) directly because they are lightweight components. The <code>JComponents</code> must be added onto the so-called <em>content-pane</em> of the top-level container. Content-pane is in fact a <code>java.awt.Container</code> that can be used to group and layout components.</p> 
     <p>You could:</p> 
     <ol> 
      <li>get the content-pane via <code>getContentPane()</code> from a top-level container, and add components onto it. For example, <pre class="color-example">
public class SwingDemo <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public SwingDemo() {
      <span class="color-comment">// Get the content-pane of this JFrame, which is a java.awt.Container
      // All operations, such as setLayout() and add() operate on the content-pane</span> 
      Container <strong>cp = getContentPane()</strong>; 
      <strong>cp.setLayout</strong>(new FlowLayout());
      <strong>cp.add</strong>(new JLabel("Hello, world!"));
      <strong>cp.add</strong>(new JButton("Button"));
      ......
   }
   .......
}</pre> </li> 
      <li>set the content-pane to a <code>JPanel</code> (the main panel created in your application which holds all your GUI components) via <code>JFrame</code>'s <code>setContentPane()</code>. <pre class="color-example">
public class SwingDemo <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public SwingDemo() {
      <span class="color-comment">// The "main" JPanel holds all the GUI components</span>
      <strong>JPanel mainPanel</strong> = new JPanel(new FlowLayout());
      mainPanel.add(new JLabel("Hello, world!"));
      mainPanel.add(new JButton("Button"));

      <span class="color-comment">// Set the content-pane of this JFrame to the main JPanel</span>
      <strong>setContentPane(mainPanel);</strong>
      ......
   }
   .......
}</pre> </li> 
     </ol> 
     <p>Notes: If a component is added directly into a <code>JFrame</code>, it is added into the content-pane of <code>JFrame</code> instead, i.e.,</p> 
     <pre class="color-example">
<span class="color-comment">// Suppose that "this" is a JFrame</span>
add(new JLabel("add to JFrame directly"));
<span class="color-comment">// is executed as</span>
getContentPane().add(new JLabel("add to JFrame directly"));</pre> 
     <h5>Event-Handling in Swing</h5> 
     <p>Swing uses the AWT event-handling classes (in package <code>java.awt.event</code>). Swing introduces a few new event-handling classes (in package <code>javax.swing.event</code>) but they are not frequently used.</p> 
     <h5>Writing Swing Applications</h5> 
     <p>In summary, to write a Swing application, you have:</p> 
     <ol> 
      <li>Use the Swing components with prefix <code>"J"</code> in package <code>javax.swing</code>, e.g., <code>JFrame</code>, <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, etc.</li> 
      <li>A top-level container (typically <code>JFrame</code>) is needed. The <code>JComponents</code> should not be added directly onto the top-level container. They shall be added onto the <em>content-pane</em> of the top-level container. You can retrieve a reference to the content-pane by invoking method <code>getContentPane()</code> from the top-level container.</li> 
      <li>Swing applications uses AWT event-handling classes, e.g., <code>ActionEvent/ActionListener</code>, <code>MouseEvent/MouseListener</code>, etc.</li> 
      <li>Run the constructor in the Event Dispatcher Thread (instead of Main thread) for thread safety, as shown in the following program template.</li> 
     </ol> 
     <h4>Swing Program Template</h4> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></td> 
        <td> <pre>
import java.awt.*;        <span class="color-comment">// Using AWT layouts</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;     <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class ...... extends <span class="color-new">JFrame</span> {
 
   <span class="color-comment">// Private instance variables</span>
   <span class="color-comment">// ......</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public ......() {
      <span class="color-comment">// Retrieve the top-level content-pane from JFrame</span>
      <span class="color-new">Container cp = getContentPane();</span>
 
      <span class="color-comment">// Content-pane sets layout</span>
      <span class="color-new">cp.</span>setLayout(new ....Layout());
 
      <span class="color-comment">// Allocate the GUI components</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-comment">// Content-pane adds components</span>
      <span class="color-new">cp.</span>add(....);
 
      <span class="color-comment">// Source object adds listener</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-new">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span>
         <span class="color-comment">// Exit the program when the close-window button clicked</span>
      setTitle("......");  <span class="color-comment">// "super" JFrame sets title</span>
      setSize(300, 150);   <span class="color-comment">// "super" JFrame sets initial size</span>
      setVisible(true);    <span class="color-comment">// "super" JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread-safety</span>
      <span class="color-new">SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new ......();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });</span>
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <p>I will explain this template in the following Swing example.</p> 
     <h4>Swing Example 1: <span class="font-code">SwingCounter</span></h4> 
     <img class="image-float-right" src="images/Swing_Counter.gif" alt="Swing_Counter.gif"> 
     <p>Let's convert the earlier AWT application example into Swing. Compare the two source files and note the changes (which are highlighted). The display is shown below. Note the differences in <em>look and feel</em> between the AWT GUI components and Swing's.</p> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre> </td> 
        <td> <pre>
import java.awt.*;       <span class="color-comment">// Using AWT layout</span>s
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class SwingCounter extends <strong>JFrame</strong> {   <span class="color-comment">// JFrame instead of Frame</span>
   private <strong>JTextField</strong> tfCount;  <span class="color-comment">// Use Swing's JTextField instead of AWT's TextField</span>
   private <strong>JButton</strong> btnCount;    <span class="color-comment">// Using Swing's JButton instead of AWT's Button</span>
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingCounter() {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      <strong>Container cp = getContentPane();</strong>
      <strong>cp.</strong>setLayout(new FlowLayout());   <span class="color-comment">// The content-pane sets its layout</span>
 
      <strong>cp.</strong>add(new <strong>JLabel</strong>("Counter"));
      tfCount = new <strong>JTextField</strong>("0");
      tfCount.setEditable(false);
      <strong>cp.</strong>add(tfCount);
 
      btnCount = new <strong>JButton</strong>("Count");
      <strong>cp.</strong>add(btnCount);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + "");
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle("Swing Counter"); <span class="color-comment">// "super" JFrame sets title</span>
      setSize(300, 100);         <span class="color-comment">// "super" JFrame sets initial size</span>
      setVisible(true);          <span class="color-comment">// "super" JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingCounter(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h5><span class="font-code">JFrame</span>'s Content-Pane</h5> 
     <p>The <code>JFrams</code>'s method <code>getContentPane()</code> returns the content-pane (which is a <code>java.awt.Containter</code>) of the <code>JFrame</code>. You can then set its layout (the default layout is <code>BorderLayout</code>), and add components into it. For example,</p> 
     <pre class="color-example">Container cp = getContentPane(); <span class="color-comment">// Get the content-pane of this JFrame</span>
cp.setLayout(new FlowLayout());  <span class="color-comment">// content-pane sets to FlowLayout</span>
cp.add(new JLabel("Counter"));   <span class="color-comment">// content-pane adds a JLabel component</span>
......
cp.add(tfCount);    <span class="color-comment">// content-pane adds a JTextField component</span>
......
cp.add(btnCount);   <span class="color-comment">// content-pane adds a JButton component</span></pre> 
     <p>You can also use the <code>JFrame</code>'s <code>setContentPane()</code> method to directly set the content-pane to a <code>JPanel</code> (or a <code>JComponent</code>). For example,</p> 
     <pre class="color-example">
JPanel displayPanel = new JPanel();
setContentPane(displayPanel);
      <span class="color-comment">// "this" JFrame sets its content-pane to a JPanel directly</span>
.....
 
<span class="color-comment">// The above is different from:</span>
getContentPane().add(displayPanel);
    <span class="color-comment">  // Add a JPanel into the content-pane. Appearance depends on the JFrame's layout.</span></pre> 
     <h5 class="font-code">JFrame's setDefaultCloseOperation()</h5> 
     <p>Instead of writing a <code>WindowEvent</code> listener with a <code>windowClosing()</code> handler to process the "close-window" button, <code>JFrame</code> provides a method called <code>setDefaultCloseOperation()</code> to sets the default operation when the user initiates a "close" on this frame. Typically, we choose the option <code>JFrame.EXIT_ON_CLOSE</code>, which terminates the application via a <code>System.exit()</code>.</p> 
     <pre class="color-example">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
</pre> 
     <h5>Running the GUI Construction Codes on the Event-Dispatching Thread</h5> 
     <p>In the previous examples, we invoke the constructor directly in the entry <code>main()</code> method to setup the GUI components. For example,</p> 
     <pre class="color-example">
<span class="color-comment">// The entry main method</span>
public static void main(String[] args) {
   <span class="color-comment">// Invoke the constructor (by allocating an instance) to setup the GUI</span>
   new SwingCounter();
}</pre> 
     <p>The constructor will be executed in the so-called "Main-Program" thread. This may cause multi-threading issues (such as unresponsive user-interface and deadlock).</p> 
     <p>It is recommended to execute the GUI setup codes in the so-called "Event-Dispatching" thread, instead of "Main-Program" thread, for thread-safe operations. Event-dispatching thread, which processes events, should be used when the codes updates the GUI.</p> 
     <p> To run the constructor on the event-dispatching thread, invoke <code>static</code> method <code>SwingUtilities.invokeLater()</code> to asynchronously queue the constructor on the event-dispatching thread. The codes will be run after all pending events have been processed. For example,</p> 
     <pre class="color-example">public static void main(String[] args) {
   <span class="color-comment">// Run the GUI codes in the Event-dispatching thread for thread-safety</span>
   <span class="color-new">SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
         new SwingCounter();  <span class="color-comment">// Let the constructor do the job</span>
      }
   });</span>
}</pre> 
     <p>Note: <code>javax.swing.SwingUtilities.invokeLater()</code> is a cover for <code>java.awt.EventQueue.invokeLater()</code> (which is used in the NetBeans' Visual GUI Builder).</p> 
     <p>At times, for example in game programming, the <em>constructor</em> or the <code>main()</code> may contains non-GUI codes. Hence, it is a common practice to create a dedicated method called <code>initComponents()</code> (used in NetBeans visual GUI builder) or <code>createAndShowGUI()</code> (used in Swing tutorial) to handle all the GUI codes (and another method called <code>initGame()</code> to handle initialization of the game's objects). This GUI init method shall be run in the event-dispatching thread.</p> 
     <h5>Warning Message "The serialization class does not declare a static final serialVersionUID field of type long"</h5> 
     <p>This warning message is triggered because <code>java.awt.Frame</code> (via its superclass <code>java.awt.Component</code>) implements the <code>java.io.Serializable</code> interface. This interface enables the object to be written out to an output stream <em>serially</em> (via method <code>writeObject()</code>); and read back into the program (via method <code>readObject()</code>). The serialization runtime uses a number (called <code>serialVersionUID</code>) to ensure that the object read into the program is compatible with the class definition, and not belonging to another version.</p> 
     <p>You have these options:</p> 
     <ol> 
      <li>Simply ignore this warning message. If a <code>serializable</code> class does not explicitly declare a <code>serialVersionUID</code>, then the serialization runtime will calculate a default <code>serialVersionUID</code> value for that class based on various aspects of the class.</li> 
      <li>Add a <code>serialVersionUID</code> (Recommended), e.g. <pre class="color-example">
private static final long <strong>serialVersionUID</strong> = 1L;  <span class="color-comment">// version 1</span></pre></li> 
      <li>Suppress this particular warning via annotation <code>@SuppressWarmomgs</code> (in package <code>java.lang</code>) (JDK 1.5): <pre class="color-example">
<strong>@SuppressWarnings("serial")</strong>
public class MyFrame extends JFrame { ...... }</pre> </li> 
     </ol> 
     <h4>Swing Example 2: <span class="font-code">SwingAccumulator</span></h4> 
     <table class="table-program"> 
      <colgroup>
       <col class="col-line-number"> 
       <col class="col-program"> 
      </colgroup>
      <tbody> 
       <tr> 
        <td> <pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td> 
        <td> <pre>
import java.awt.*;       <span class="color-comment">// Using layouts</span>
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits the top-level container javax.swing.JFrame</span>
public class SwingAccumulator extends <strong>JFrame</strong> {
   private <strong>JTextField</strong> tfInput, tfOutput;
   private int sum = 0;    <span class="color-comment">// accumulated sum, init to 0</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingAccumulator() {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      <strong>Container cp = getContentPane();</strong>
      <strong>cp.</strong>setLayout(new GridLayout(2, 2, 5, 5));  <span class="color-comment">// The content-pane sets its layout</span>
 
      cp.add(new <strong>JLabel</strong>("Enter an Integer: "));
      tfInput = new <strong>JTextField</strong>(10);
      <strong>cp.</strong>add(tfInput);
      <strong>cp.</strong>add(new <strong>JLabel</strong>("The Accumulated Sum is: "));
      tfOutput = new JTextField(10);
      tfOutput.setEditable(false);  <span class="color-comment">// read-only</span>
      <strong>cp.</strong>add(tfOutput);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      tfInput.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            <span class="color-comment">// Get the String entered into the input TextField, convert to int</span>
            int numberIn = Integer.parseInt(tfInput.getText());
            sum += numberIn;      <span class="color-comment">// accumulate numbers entered into sum</span>
            tfInput.setText("");  <span class="color-comment">// clear input TextField</span>
            tfOutput.setText(sum + ""); <span class="color-comment">// display sum on the output TextField</span>
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle("Swing Accumulator"); <span class="color-comment">// "super" Frame sets title</span>
      setSize(350, 120);  <span class="color-comment">// "super" Frame sets initial size</span>
      setVisible(true);   <span class="color-comment">// "super" Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingAccumulator(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre> </td> 
       </tr> 
      </tbody> 
     </table> 
     <h3>Using Visual GUI Builder - NetBeans/Eclipse</h3> 
     <p>If you have a complicated layout for your GUI application, you should use a GUI Builder, such as NetBeans or Eclipse to layout your GUI components in a drag-and-drop manner, similar to the popular visual languages such as Visual Basic and Dephi.</p> 
     <h4>NetBeans</h4> 
     <p>For using NetBeans GUI Builder, read my "<a href="../howto/NetBeans_HowTo.html#netbeans-swing">Writing Java GUI (AWT/Swing) Application in NetBeans</a>"; or Swing Tutorial's "<a href="http://docs.oracle.com/javase/tutorial/uiswing/learn/index.html">Learning Swing with the NetBeans IDE</a>".</p> 
     <h4>Eclipse</h4> 
     <p>For using Eclipse GUI Builder, read "<a href="../howto/EclipseJava_HowTo.html#GUIBuider">Writing Swing Applications using Eclipse GUI Builder</a>".</p> 
     <a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a> 
     <p class="references">MORE REFERENCES &amp; RESOURCES</p> 
     <ol> 
      <li>"Creating a GUI With JFC/Swing" (aka "The Swing Tutorial") @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>.</li> 
      <li>JFC Demo (under JDK demo "<code>jfc</code>" directory).</li> 
      <li>Java2D Tutorial @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>.</li> 
      <li>JOGL (Java Binding on OpenGL) @ <a href="http://java.net/projects/jogl/">http://java.net/projects/jogl/</a>.</li> 
      <li>Java3D (@ <a href="http://java3d.java.net/">http://java3d.java.net/</a>).</li> 
     </ol> 
    </div> 
    <!-- End the content-main division --> 
    <div id="content-footer"> 
     <p>Latest version tested: JDK 1.8.0<br> Last modified: April, 2017</p> 
    </div> 
   </div> 
   <!-- End the wrap-inner division --> 
   <!-- footer filled by JavaScript --> 
   <div id="footer" class="header-footer">
    <p>&nbsp;</p>
   </div> 
  </div> 
  <!-- End the wrap-outer division -->   
 </body>
</html>