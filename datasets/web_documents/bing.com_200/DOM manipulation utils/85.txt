<html>
 <head> 
  <title>Packages and Access Specifiers: Chapter 5 of Objects and Java</title> 
  <meta name="description" content="How to hide the implementation in Java programs and designs."> 
  <meta name="keywords" content="Java Design, Java Book, Java Packages, Java Access Specifiers"> 
  <link rel="stylesheet" type="text/css" href="/artima.css"> 
  <link rel="shortcut icon" href="/favicon.ico"> 
 </head> 
 <body>
  <table width="100%" bgcolor="#FFFFFF" style="margin-top: 5px"> 
   <tbody>
    <tr> 
     <td align="center"> 
      <div id="topbanner" style="height: 90px">
       <noscript>
        <a href="https://www.artima.com/zcr/adclick.php?n=a86d37e9" target="_top"><img src="https://www.artima.com/zcr/adview.php?what=zone:1&amp;n=a86d37e9" border="0" alt=""></a>
       </noscript>
      </div> </td> 
    </tr> 
   </tbody>
  </table> 
  <table width="100%" cellspacing="0"> 
   <tbody>
    <tr> 
     <td align="left" valign="bottom"> <a href="/index.jsp"><img src="/images/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43"></a> </td> 
    </tr>
   </tbody>
  </table> 
  <table width="100%" bgcolor="#333333"> 
   <tbody>
    <tr> 
     <td align="center"> 
      <div class="ml"> 
       <a href="/articles" class="hl">Articles</a>&nbsp;| 
       <a href="/news/index.jsp" class="hl">News</a>&nbsp;| 
       <a href="/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;| 
       <a href="/buzz/index.jsp" class="hl">Buzz</a>&nbsp;| 
       <a href="/shop/catalog" class="hl">Books</a>&nbsp;| 
       <a href="/forums/index.jsp" class="hl">Forums</a> 
      </div> </td> 
    </tr> 
   </tbody>
  </table> 
  <table width="100%" bgcolor="#EEEEEE"> 
   <tbody>
    <tr> 
     <td align="center"> 
      <div class="sc"> 
       <span style="color: #555555">Sponsored Link</span> 
       <span style="color: #888888">•</span> 
       <script language="JavaScript" type="text/javascript" src="https://www.artima.com/zcr/adx.js"></script> 
       <script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("https://www.artima.com/zcr/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script>
       <noscript>
        <a href="https://www.artima.com/zcr/adclick.php?n=a799ecf6" target="_top"><img src="https://www.artima.com/zcr/adview.php?what=zone:9&amp;n=a0587811" border="0" alt=""></a>
       </noscript> 
      </div> </td> 
    </tr> 
   </tbody>
  </table> 
  <br> 
  <div class="vegies"> 
   <div class="tc"> 
    <span class="sts">Objects and Java by Bill Venners</span>
    <br> 
    <span class="sts">Chapter 5:</span>
    <br> 
    <span class="ts">Packages and Access Specifiers</span>
    <br> 
   </div> 
   <p> </p>
   <table align="right" border="0" cellpadding="5" cellspacing="0"> 
    <tbody>
     <tr> 
      <td align="center"> 
       <div style="margin-left: 15%;"> 
        <div class="adnotice">
         Advertisement
        </div> 
        <script language="JavaScript" type="text/javascript" src="https://www.artima.com/zcr/adx.js"></script> 
        <script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("https://www.artima.com/zcr/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:2&amp;target=_top&amp;block=1&amp;blockcampaign=1");
   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script>
        <noscript>
         <a href="https://www.artima.com/zcr/adclick.php?n=a799ecf6" target="_top"><img src="https://www.artima.com/zcr/adview.php?what=zone:2&amp;n=a799ecf6" border="0" alt=""></a>
        </noscript> 
       </div> </td> 
     </tr> 
    </tbody>
   </table> 
   <p></p> 
   <!--BEGIN_OAJBOOK_LINKS--> 
   <div id="links"> 
    <center> 
     <font size="1" face="geneva, arial, sans-serif"> <strong> <a href="../index.html">Objects and Java</a>&nbsp;| <a href="index.html">Contents</a>&nbsp;| <a href="InitCleanup1.html">Previous</a>&nbsp;| <a href="CompoInherit1.html">Next</a>&nbsp; </strong> </font> 
    </center> 
   </div> 
   <!--END_OAJBOOK_LINKS--> 
   <p>The process of software design is largely a process of organizing. The previous three chapters explored the object-oriented ways you can organize a Java program. This chapter discusses an additional way to organize Java programs that has nothing to do with object-orientation: packages. In Java, a <em>package</em> is a library of types (classes and interfaces). This chapter describes four ways to think about packages and shows how to make use of packages in your Java programs. </p>
   <p>Once you know about packages, you can understand all the access levels (such as <code>private</code>, <code>protected</code>, etc.) available to types and their fields and methods. This chapter compares all the access levels and gives advice on how to use them. </p>
   <h2>Avoiding Name Conflicts</h2> 
   <p>The first way to think about packages is as a tool to help you reduce the likelyhood of name conflicts in your programs. When you design a Java program, you model the problem domain by identifying and defining types and assigning each a name. Types refer to each other by name, so each type name you assign must be unique. If you design a large program, or incorporate types named and defined by others, you may encounter name conflicts. To address the problem of name conflicts, you use packages. </p>
   <p>Packages effectively lengthen type names, making the names more distinctive. In a Java program, every type belongs to some package. A package is a set of types grouped together under a common package name. Each type has a <em>simple name</em>, and each package has a <em>package name</em>. The name of the package containing a type, plus a dot, plus the type's simple name is the type's <em><a name="index-fully+qualified+name-definition">fully qualified name</a></em>. For example, if you have a class named <code>CoffeeCup</code> in a package named <code>dishes</code>, "<code>dishes.CoffeeCup</code>" is its fully qualified name. ("<code>dishes</code>" is its package name; "<code>CoffeeCup</code>" its simple name.) The fully qualified name of a type, which is longer and more distinctive than its simple name, enables like-named types from different packages to be used in the same program. </p>
   <p>If you discard the package name from a type's fully qualified name, you get the type's simple name. Therefore, the simple name of <code>dishes.CoffeeCup</code> is, simply, <code>CoffeeCup</code>. To use <code>CoffeeCup</code>, types in the same package can just use its simple name. Types in other packages, however, must also identify <code>dishes</code>, the package containing <code>CoffeeCup</code>, as well as its simple name. This ensures that a different <code>CoffeeCup</code> class defined in a different package will not conflict with <code>dishes.CoffeeCup</code>. </p>
   <p>To help make type names even more distinctive, you can organize your packages hierarchically. Packages can contain not only types, but other packages as well. The entities contained in a package--its classes, interfaces, and sub-packages--are called the package's <em>members</em>. </p>
   <p>The fully qualified name of a class nestled deep down inside several packages is the name of each package and the class's simple name, all separated by dots. For instance, if you placed <code>CoffeeCup</code> inside package <code>dishes</code> and placed <code>dishes</code> inside package <code>vcafe</code> (for virtual cafe), the fully qualified name of <code>CoffeeCup</code> would be "<code>vcafe.dishes.CoffeeCup</code>." The greater the number of nested packages in which you place a class, the more dot-separated names the class will have in its fully qualified name, and the more distinctive that fully qualified name will be. </p>
   <p>Packages help you guard against the potential of name conflicts in your Java programs. Instead of worrying that the simple name of every type you need to use in a program is unique, you need only worry that every fully qualified name is unique. </p>
   <p>One other way to deal with name conflicts involves class loaders and the multiple name spaces offered by the JVM. This will be discussed in Chapter 20. </p>
   <h2>Hierarchical Organization</h2> 
   <p>A second way to think about packages is as a tool to help you organize the types you create for your program. With packages, you can organize a program into logically related groups of types, and organize the groups hierarchically. </p>
   <p>The package is an organizational tool independent of any object-oriented organization of a program. For example, all the types in a particular family of types could belong to the same package, or be spread out across several packages. A class in one package can subclass a class in another package. The only requirement is that the subclass must specify the name of the package containing its superclass as well as the superclass's simple name. When you organize your types into packages, what you are actually organizing is type <em>names</em>. </p>
   <p>Although you can grant special privileges between types that belong to the same package, a topic that will be discussed later in this chapter, you can't grant special privileges between a types in a package and types in a sub-package. To the types defined in a parent package, a sub-package is just like any other package. From the perspective of a Java compiler or the Java Virtual Machine, nested packages are not really seen as a hierarchy. They are just seen as a set of independent packages, each with a unique name. Packages are seen as a conceptual hierarchy only from the perspective of developers, who can use the hierarchy to express conceptual relationships between different groups of types. </p>
   <p>Often, Java compilers and Java Virtual Machines expect the source files or class files contained in a hierarchy of packages to be located in a corresponding directory hierarchy, in which each directory takes the name of a package. Here, the compiler or Java Virtual Machine is using the package hierarchy as a way to locate files on a disk. The actual manner in which a particular compiler or Java Virtual Machine finds class files is a detail specific to each individual development environment or Java Platform implementation. The process of using directory hierarchies that map to package hierarchies to locate class files will be discussed further later in this chapter. </p>
   <h2>Libraries</h2> 
   <p>A third way to think about packages is simply as libraries. Any Java program you write will make use of libraries developed by others and made available to your program as packages. Any program will at least use the run-time libraries of the Java API, some of which are <code>java.lang</code>, <code>java.io</code>, <code>java.util</code>, <code>java.net</code>, <code>java.awt</code>, and <code>java.applet</code>. If, rather than developing a complete program, you wish to develop class library that other developers can use in their programs, your end-product will be a package. </p>
   <h2>Hiding the Implementation</h2> 
   <p>The fourth way to think about packages is as a tool that can help you separate interface from implementation. You can grant special access privileges between types within the same package, and you can declare entire types to be accessible only to other types within the same package. The full details of how to do this will be given later in this chapter as part of a discussion of Java's access levels. </p>
   <h2>Recommended Package Naming Convention</h2> 
   <p>Because the packages used by a program can come from many sources, it is important that you name your packages in a way that won't conflict with the names of packages developed by others. Of course, you don't know what packages might be developed by other programmers, nor how they will name those packages. This points out that the mechanism of packages doesn't actually solve the name conflict problem, it only reduces the likelihood of an actual conflict. Just because you go to the trouble of enclosing your <code>CoffeeCup</code> class in two nested packages--<code>vcafe</code> and <code>dishes</code>--doesn't mean someone else won't inadvertently do the same. </p>
   <p>To combat the potential of name conflicts between types developed by different software vendors, Java comes with a recommended naming convention for packages. If everyone would follow the recommended convention when naming their packages, harmony would cover the Earth. Java does not, however, enforce any naming convention, so name conflicts are still possible. It is up to you to do your part in preventing naming conflicts within Java programs. </p>
   <p>The official recommendation on package naming is to use the reversed internet domain name of your company or organization as the first part of your package names. Because internet domain names are globally unique, this improves the chances your package names will be globally unique. If your company's domain name were <code>artima.com</code>, for instance, you would start any package name with "<code>com.artima</code>." The fully qualified name of <code>CoffeeCup</code> would become <code>com.artima.vcafe.dishes.CoffeeCup</code>. </p>
   <p>All the packages you create must be given a name that will be unique across the scope in which they will be visible. If they will be visible only locally, you needn't use the recommended naming convention. If you are certain your package names are not going to be visible on a global scale, but will remain inside, say, your division, you can devise and follow a division-wide package naming scheme. For any other package, however, following the recommended naming scheme makes you a good Java citizen. </p>
   <h2>The Package Declaration</h2> 
   <p>As you write a Java program, you must place every class you define into a package, and give each package a unique name. You place a class into a package by including a package declaration at the top of the source file. A <em><a name="index-package+declaration-definition">package declaration</a></em> is just the keyword <code>package</code> followed by the package name and a semicolon. The package declaration must appear in the source file before any class or interface declaration, and each source file can contain only one package declaration. For example, you would place <code>CoffeeCup</code> into the package <code>com.artima.vcafe.dishes</code> as follows: </p>
   <pre>
// In Source Packet in file
// packages/ex1/com/artima/vcafe/dishes/CoffeeCup.java
package com.artima.vcafe.dishes;

public class CoffeeCup {

    public static final int MAX_SHORT_ML = 237;
    public static final int MAX_TALL_ML = 355;
    public static final int MAX_GRANDE_ML = 473;

    public void add(int amountOfCoffee) {
        System.out.println("Adding " + amountOfCoffee
            + " ml of coffee.");
    }
    //...
}
</pre> 
   <p>The package name in the example above, <code>com.artima.vcafe.dishes</code>, indicates that <code>dishes</code> is a sub-package of <code>vcafe</code>, which is a sub- package of <code>artima</code>, which is a sub-package of <code>com</code>. You needn't have any source file in your program that declares the <code>com</code> package, the <code>com.artima</code> package, or the <code>com.artima.vcafe</code> package. The package statement in the example above is enough to establish the existence of all four packages: <code>com</code>, <code>artima</code>, <code>vcafe</code>, and <code>dishes</code>. </p>
   <p>On the other hand, if you do have source files that declare classes as members of, say, the <code>com.artima.vcafe</code> package, those classes have no special relation to the classes of <code>com.artima.vcafe.dishes</code>, as far as the Java language is concerned. To the Java language, <code>com.artima.vcafe</code> and <code>com.artima.vcafe.dishes</code> are just two different packages with two different names. To you, the programmer, however, the hierarchical relationship between the two packages would have meaning: it would express the conceptual relationship between two different groups of types. [bv: is this redundant with something that came before?] </p>
   <h2>Location of Source and Class Files</h2> 
   <p>Although the location of source and class files for package members at both compile-time and run- time depends on your particular development and runtime environments, many environments require that you create a hierarchy of directories that correspond to the hierarchy of packages. If you were to work on such a system, you would likely have to put the source and class file for the <code>CoffeeCup</code> class defined above in a directory named "<code>.../com/artima/vcafe/dishes</code>" or "<code>...\com\artima\vcafe\dishes</code>", depending on your preferred direction of slash. </p>
   <p>To give one concrete example, imagine you are using Sun's JDK 1.1.1 to run a Java program on Microsoft Windows95. You would set an environment variable, <code>CLASSPATH</code>, to indicate to the Java Virtual Machine where it should look for class files. If your <code>CLASSPATH</code> is set to "<code>.;C:\MYLIB;C:\JDK1.1.1\LIB\CLASSES.ZIP</code>", then the compiler and the Java Virtual Machine would look in three places for the classes needed by your program: </p>
   <ol> 
    <li>the current directory, "<code>.</code>" </li>
    <li>a directory named "<code>C:\MYLIB</code>" </li>
    <li>a zip file named "<code>C:\JDK1.1.1\LIB\CLASSES.ZIP</code>" </li>
   </ol> If you use 
   <code>com.artima.vcafe.dishes.CoffeeCup</code> in the program, the Java Virtual Machine would first look for a directory, relative to the current directory, named 
   <code>.\com\artima\vcafe\dishes</code>. (It would look here first because "
   <code>.</code>" is the first directory in the 
   <code>CLASSPATH</code>.) If it finds a 
   <code>CoffeeCup.class</code> in that directory, it would load it. If this directory didn't exist, or there was no 
   <code>CoffeeCup.class</code> in that directory, the Java Virtual Machine would look for a directory named 
   <code>C:\MYLIB\com\artima\vcafe\dishes</code>. If it finds a 
   <code>CoffeeCup.class</code> here, it would load it. Otherwise it would look inside the zip file for a 
   <code>com\artima\vcafe\dishes\CoffeeCup.class</code>. It is unlikely that 
   <code>CoffeeCup.class</code> it is in the zip file, because this is where all the runtime libraries of the Java Platform are kept in JDK 1.1.1. 
   <p>As it searches through the directories and zip files listed in the class path, the Java Virtual Machine loads the first class file that it encounters with a name that matches the class name, <code>CoffeeCup.class</code>, and a relative directory that matches the package name, <code>com\artima\vcafe\dishes</code>. Once it has loaded the class file, the virtual machine checks the binary data to verify that the class is indeed <code>com.artima.vcafe.dishes.CoffeeCup</code>. </p>
   <p>This Windows95 and JDK 1.1.1 example was just one possible way a Java Platform implementation could locate class files. To find out how your particular Java Platform or Java development environment locates class files, you must consult its documentation. </p>
   <h2>The Unnamed Package</h2> 
   <p>In every Java program there can be one <em><a name="index-unnamed+package-definition">unnamed package</a></em>, which is simply a package with no name. In a sense, the unnamed package really does have a name, just a very short one, which distinguishes it from the other packages in your program. To place a class into the unnamed package, just define the class in a source file with no package statement. All types declared in this book prior to this chapter were in the unnamed package. </p>
   <p>You should not use the unnamed package for a general-purpose library, because it is probably the most common package name used by Java programmers. (In addition, types declared in the unnamed package are accessible only to each other. In other words, a type in a named package can't access a type in the unnamed package.) In general, you will want to partition large Java programs into named packages to better organize your program and to take advantage of the implementation-hiding capabilities of packages. The unnamed package is convenient and appropriate for the core types that make up an applet or application. </p>
   <h2>The Import Statement</h2> 
   <p>In a Java source file, you have two ways to refer to a class or interface defined in another package. You can either use the fully qualified name of the class everywhere you refer to it, or you can import that class's fully qualified name into your source file and then just use the simple name everywhere. <em><a name="index-importing+types-definition">Importing</a></em><a name="index-importing+types-definition"> a type into a source file means making the compiler recognize the type in that source file by its simple name. </a></p>
   <p><a name="index-importing+types-definition">You can't import packages, just types. Import doesn't include any code, like <code>#include</code> of C or C++. It only means that you can use the simple name of a type instead of the fully qualified names. </a></p>
   <p><a name="index-importing+types-definition">As an example, imagine you are writing code in the unnamed package that takes advantage of the <code>CoffeeCup</code> class defined in package <code>com.artima.vcafe.dishes</code>. One approach is to just use the fully qualified name of <code>CoffeeCup</code> everywhere, as in: </a></p>
   <pre><a name="index-importing+types-definition">
// In Source Packet in file packages/ex1/Example1a.java
// Deep in the heart of the unnamed package...
class Example1a {
    public static void main(String[] args) {

        com.artima.vcafe.dishes.CoffeeCup cup =
            new com.artima.vcafe.dishes.CoffeeCup();

        cup.add(com.artima.vcafe.dishes.CoffeeCup.MAX_SHORT_ML);
    }
}
</a></pre>
   <a name="index-importing+types-definition"> This approach is reasonable if the source file has only a few references to a class, but otherwise can make your code tiresome for you to type and others to read. The alternative is to import the class into the source file and then refer to the class by its simple name. Here's an example: <pre>
// In Source Packet in file packages/ex1/Example1b.java
// At the top of a file in the unnamed package, import the class.
import com.artima.vcafe.dishes.CoffeeCup;

// Everywhere else in the file, just use the simple name.
class Example1b {
    public static void main(String[] args) {

        CoffeeCup cup = new CoffeeCup();
        cup.add(CoffeeCup.MAX_TALL_ML);
    }
}
</pre> <p>If you find yourself using several types from a single package, you can import all their names from a package into your source file with one import statement by using an asterisk in place of the class or interface name. (Actually, the asterisk only imports classes and interfaces declared as public, a feature that will be described in detail later in this chapter.): </p><pre>
// In Source Packet in file packages/ex1/Example1c.java
// Import all public types from the com.artima.vcafe.dishes package.
import com.artima.vcafe.dishes.*;

// Everywhere else in the file, just use the simple names.
class Example1c {
    public static void main(String[] args) {

        CoffeeCup cup = new CoffeeCup();
        cup.add(CoffeeCup.MAX_GRANDE_ML);
    }
}
</pre> <p>Import statements such as the ones shown in the examples above reduce the amount of typing required to use types from other packages, but they also make it possible for names to conflict again. For instance, if you imported two different <code>CoffeeCup</code> classes from two different packages, just referring to "<code>CoffeeCup</code>" would be ambiguous. The compiler wouldn't know which <code>CoffeeCup</code> you were talking about. In this case you would need to explicitly indicate which <code>CoffeeCup</code> you meant by prefacing the simple name with the package name. In other words, even though you imported both <code>CoffeeCup</code> classes, you'll still have to use the fully qualified names to resolve the ambiguity. </p><p>As an example, imagine you imported all the public types from two packages, <code>com.artima.vcafe.dishes</code> and <code>com.artima.pencilholders</code>, both of which contained a <code>CoffeeCup</code> class. To use either version of <code>CoffeeCup</code> you would have to use its fully qualified name, as shown below: </p><pre>
// In Source Packet in file
// packages/ex1/com/artima/pencilholders/CoffeeCup.java
package com.artima.pencilholders;

public class CoffeeCup {

    public void add(int amountOfPencils) {
        System.out.println("Adding " + amountOfPencils
            + " pencils.");
    }
    //...
}

// In Source Packet in file packages/ex1/Example1d.java
// All types defined in both packages are
// imported, yielding two different classes named "CoffeeCup."
import com.artima.pencilholders.*;
import com.artima.vcafe.dishes.*;

class Example1d {
    public static void main(String[] args) {

        // Somewhere later in the code, you wish to instantiate a
        // new CoffeeCup from the com.artima.vcafe.dishes package:
        com.artima.vcafe.dishes.CoffeeCup myCoffee =
            new com.artima.vcafe.dishes.CoffeeCup();

        // While you sip your coffee with the cup from the virtual
        // cafe, you also want a place to store your spare pencils.
        // So, you create a new CoffeeCup from the
        // com.artima.pencilholders package. This is a different
        // class, but one that shares the same simple name as the
        // previous "CoffeeCup."
        com.artima.pencilholders.CoffeeCup myPencilHolder =
            new com.artima.pencilholders.CoffeeCup();

        myCoffee.add(com.artima.vcafe.dishes.CoffeeCup.MAX_SHORT_ML);
        myPencilHolder.add(10);
    }
}
</pre> <p>The code as shown above compiles fine, because each time you use a <code>CoffeeCup</code> you clearly indicate which <code>CoffeeCup</code> you want. You have indeed accomplished your goal of using two different <code>CoffeeCup</code> classes in the same source file, yet you have once again cluttered the code with long package names. </p><p>Fortunately, one other approach exists that may help you reduce some of the clutter. If you only import one of the packages containing a <code>CoffeeCup</code> class, you could use the simple name when referring to that <code>CoffeeCup</code>. As before, you'd have to use the fully qualified name when referring to the other <code>CoffeeCup</code>. Rewriting the previous example using this approach, yields the following code: </p><pre>
// In Source Packet in file packages/ex1/Example1e.java
// Import all types defined in com.artima.vcafe.dishes, but
// don't import anything from com.artima.pencilholders.
import com.artima.vcafe.dishes.*;

class Example1e {
    public static void main(String[] args) {

        // Somewhere later in the code, you wish to instantiate a
        // new CoffeeCup from the com.artima.vcafe.dishes package.
        // Here you can just use the simple name:
        CoffeeCup myCoffee = new CoffeeCup();

        // To create a new CoffeeCup from the
        // com.artima.pencilholders package, you must once again
        // use the fully qualified name:
        com.artima.pencilholders.CoffeeCup myPencilHolder =
            new com.artima.pencilholders.CoffeeCup();

        myCoffee.add(CoffeeCup.MAX_TALL_ML);
        myPencilHolder.add(15);
    }
}
</pre> <p>You might be wondering if you can just import all the members of the <code>com.artima</code> package and just use <code>vcafe.dishes.CoffeeCup</code> and <code>pencilholders.CoffeeCup</code> to distinguish between the two classes of coffee cup. Well, you can't. The import statement only imports types, not packages. The statement "<code>import com.artima.*;</code>" imports all the types defined in that package, but doesn't import any sub- packages defined in that package. The statement "<code>import com.artima;</code>" doesn't compile, because you are trying to import a package and not a class or interface. Another statement that doesn't compile is "<code>import com.artima.*.dishes;</code>". The <code>*</code> must always go at the end, as it only matches type names, not package names. </p><p>There is one exception to the rule that you must import types from other packages before you can use their simple names: <code>java.lang.*</code>. The public types defined in the standard run- time library <code>java.lang</code> are automatically imported into every Java source file. This package contains classes, such as <code>String</code>, <code>Thread</code>, and <code>Object</code>, that are essential to the inner workings of Java programs. To make use of the types contained in the packages from Java's standard run-time library other than <code>java.lang</code>, you must either import the packages or use fully qualified names, just like any other package. </p><p>Import statements are provided as a convenience for the programmer. Because of import statements, you don't have to always type long and tedious fully qualified names. The Java compiler can work out the fully qualified names of types given the import statements and the simple names in a source file. When the compiler generates class files, it discards any import statements in the source file. In class files, all types are identified by their fully qualified names. In your programs, you can choose to use import statements or fully qualified names, whatever you think will maximize the readability of your code. </p><p>As mentioned earlier in this chapter, an import statement does not dynamically include code from a different file, as <code>#include</code> does for C and C++ programs. Import is just about names. </p><h2>Access Levels for Types</h2> <p>One of the most useful features of Java packages is the ability to grant access to classes, interfaces, methods, or fields exclusively to other members of the same package. This feature gives the package an internal implementation and an external interface. It provides the usual advantages of a hidden internal implementation: robustness and ease of modification. The robustness arises from the inability of types declared in other packages to incorrectly manipulate the internal implementation of the package. Types in other packages must go through the external interface of the package, and the package maintains control of its internal implementation. Ease of modification comes from the ability to change the internal implementation of the package without affecting the code of other packages, which is tied only to the external interface. </p><p>The first step you can take to hide the internal implementation of a package is to declare as public only those types that are needed by other packages. When you declare a class or interface, it is by definition contained in a package. If you want a class or interface to be accessible to types declared in other packages, you must declare it public. If you do not declare it public, it will only be accessible to types in the same package. Therefore, you can denote some types (the public ones) as part of the external interface of the package. The other types (the ones that aren't public) are part of the internal implementation of the package. An example of both kinds of class declarations is shown below: </p><pre>
// In Source Packet in file
// packages/ex2/com/artima/vcafe/dishes/Cup.java
package com.artima.vcafe.dishes;

// Class Cup is part of the internal implementation of
// package com.artima.vcafe.dishes.
class Cup {

    public void add(int amountOfCoffee) {
        System.out.println("Adding to a Cup.");
    }
    //...
}

// In Source Packet in file
// packages/ex2/com/artima/vcafe/dishes/CoffeeCup.java
package com.artima.vcafe.dishes;

// Class CoffeeCup is part of the external interface of
// package com.artima.vcafe.dishes.
public class CoffeeCup extends Cup {
    public static final int MAX_SHORT_ML = 237;
    public static final int MAX_TALL_ML = 355;
    public static final int MAX_GRANDE_ML = 473;
    //...
}
</pre> <p>In the code shown above, class <code>CoffeeCup</code> is declared public, but class <code>Cup</code> is not. Consequently, <code>CoffeeCup</code> is accessible everywhere, but <code>Cup</code> is accessible only in the <code>com.artima.vcafe.dishes</code> package. </p><p>Package access is the default for types. Unless you explicitly modify your class declaration with the keyword <code>public</code>, you'll get "package access," as this default level of access is called. You cannot declare a class with the access specifiers <code>protected</code> or <code>private</code>. It must either be declared with the keyword <code>public</code> or have no access specifier. </p><p>As the example above demonstrates, you can declare a superclass with package access and still give its subclass public access. Given the code above, a type in another package could not subclass <code>Cup</code>, but could subclass <code>CoffeeCup</code>. If you want types in other packages to be able to use <code>CoffeeCup</code> but not subclass it, you must also declare it final, as shown below: </p><pre>
// In Source Packet in file
// packages/ex3/com/artima/vcafe/dishes/Cup.java
package com.artima.vcafe.dishes;

// Class Cup is part of the internal implementation of
// package com.artima.vcafe.dishes.
class Cup {

    public void add(int amountOfCoffee) {
        System.out.println("Adding to a Cup.");
    }
    //...
}

// In Source Packet in file
// packages/ex3/com/artima/vcafe/dishes/CoffeeCup.java
package com.artima.vcafe.dishes;

// Class CoffeeCup is part of the external interface of
// package com.artima.vcafe.dishes. It can be used, but
// not subclassed, by classes in other packages.
public final class CoffeeCup extends Cup {
    public static final int MAX_SHORT_ML = 237;
    public static final int MAX_TALL_ML = 355;
    public static final int MAX_GRANDE_ML = 473;
    //...
}
</pre> <p>When you fill a package with types, you should separate the types that represent the implementation of the package from those that represent the interface. Only those types that are needed by other packages should be declared public. A good rule of thumb is to leave any class or interface with its default package access, unless you're sure it should be public. </p><p>Declaring a public class as final will prevent classes in other packages from declaring a subclass, but it will also restrict any other class in its own package from declaring a subclass. This is a severe restriction on the use of a class. Often you will want clients of your package to be able to subclass its public classes. That is one of the fundamental ways to reuse code in object-oriented programming. The rule of thumb here is to make classes final only when you have a good reason. </p><p>One possible reason to make a class final is to ensure your package will always behave as expected. For example, imagine you write a package that depends for correctness on the proper behavior of a certain class of objects, say the <code>CoffeeCup</code> class, defined in your package. You make class <code>CoffeeCup</code> public so that clients can create instances of it to pass to the methods of other classes defined in your package. If your package requires that the <code>CoffeeCup</code> objects passed to it behave in a certain way, your package might break if a client declares their own subclass of class <code>CoffeeCup</code>, say <code>LeakyCup</code>, and overrides the methods that your package depends upon for correctness. You can avoid this by declaring every method in <code>CoffeeCup</code> as final, or by declaring the entire <code>CoffeeCup</code> class final. </p><p>In the examples in this book, each type is declared in its own source file. The name of the source file is the name of the type plus the extension <code>.java</code>. For example, class <code>CoffeeCup</code> is declared in file <code>CoffeeCup.java</code>, and interface <code>Washable</code> is declared in file <code>Washable.java</code>. Although placing each type in a separate file named after the type is in general a good practice, because it makes the type's source easier for you and other developers to locate, it is not always required. Java compilers do require that public types be declared in a file that bears the name of the public types. They do not, however, require this of non-public types. You can place as many non-public types in the same file as you wish, and the file can have whatever name you wish. If a file does contain a public type, however, the file must be given the name of the public type. Because you can only have one package statement in each source file, all types declared in the same source file are members of the same package. </p><h2>Access Levels for Class Members</h2> <p>In general, within any class you design you will want to hide the implementation. Given that packages can (and should) be used to group related types, however, you may want to expose some fields and methods to other classes in the same package while keeping them hidden from classes outside the package. Java provides access control modifiers to support this intermediate level of implementation hiding. By applying proper modifiers on a class's fields and methods, you can hide the class's implementation from classes outside the package while exposing the implementation to classes inside the package. </p><p>Java gives you three access control modifiers--<code>private</code>, <code>protected</code>, and <code>public</code>--to apply to the fields and methods of public classes, but you can obtain four distinct levels of access from their use. Three of the levels (private, protected, and public access) are denoted by the use of one of the three access control modifiers. The fourth level (package access) is the default and is indicated by the lack of any access control modifier. Here is a description of each of the four access levels available to members of public classes, in order from least to most accessible: </p>
    <ol> 
     <li>private access (denoted by the keyword <code>private</code>) - a field or method accessible only to the class which defines it. </li>
     <li>package access (denoted by no access control modifier keywords) - a field or method accessible to any type in the same package. </li>
     <li>protected access (denoted by the keyword <code>protected</code>) - a field or method accessible to any type in the same package, and to subclasses in any package. </li>
     <li>public access (denoted by the keyword <code>public</code>) - a field or method accessible to any type in any package. </li>
    </ol> <p>There is no way to grant special access to types in sub-packages. This is why the Java compiler and the Java Virtual Machine view a package and its sub-packages as independent packages with no special privileges between them. Thus, the relationship between types in hierarchically related packages, such as <code>com.artima.vcafe</code> and <code>com.artima.vcafe.dishes</code>, is only conceptual. Package hierarchies help you organize your types, but don't allow any special access privileges between the two groups of types. </p><p>A graphical depiction of the effect of each kind of access control modifier is shown in Figures 7-1 through 7-4. In these figures, the ovals represent classes, the arrows represent inheritance, the rectangles represent packages. Each figure indicates which classes will be able to access a member of class <code>Cup</code> with one of the five access levels. Classes that can access the member in <code>Cup</code> are shown in solid gray; classes that can't are shown with a checkerboard pattern. </p><p><img src="images/packFig1.gif"><br> Figure 5-1. Private access to a member of <code>Cup</code>. </p><p><img src="images/packFig2.gif"><br> Figure 5-2. Package access to a member of <code>Cup</code>. </p><p><img src="images/packFig3.gif"><br> Figure 5-3. Protected access to a member of <code>Cup</code>. </p><p><img src="images/packFig4.gif"><br> Figure 5-4. Public access to a member of <code>Cup</code>. </p><p>An example of each kind of access control modifier is shown in the following version of class <code>Coffee</code>: </p><pre>
// In Source Packet in file
// packages/ex4/com/artima/vcafe/beverages/Coffee.java
package com.artima.vcafe.beverages;

public class Coffee {

    // PRIVATE ACCESS
    // Accessible to only class Coffee itself.
    private int temperature;

    // PACKAGE ACCESS
    // Accessible to Coffee and to the other classes and
    // interfaces of package com.artima.vcafe.beverages.
    void changeTemperature(int delta) {
        temperature += delta;
    }

    // PROTECTED ACCESS
    // Accessible to Coffee, to its subclasses (no matter what
    // package the subclasses are defined in), and to the other
    // types of package com.artima.vcafe.beverages, including
    // non-subclasses.
    protected static final int bestTemperature = 50;

    // PUBLIC ACCESS
    // Accessible to the entire universe.
    public void setTemperature(int temperature) {
        this.temperature = temperature;
    }
    public int getTemperature() {
        return temperature;
    }
}
</pre> <h2>The True Meaning of <code>private</code> and <code>protected</code></h2> <p>The <code>private</code> keyword grants exclusive access not to an object, but to a class. An object can access its private members, but so can any other object of the same class. For example, if a <code>CoffeeCup</code> object has a reference to another <code>CoffeeCup</code> object, the first <code>CoffeeCup</code> can access the second <code>CoffeeCup</code>'s private members through that reference. This is true of both private variables and private methods, whether they are static or not. </p><p>Inside a package, the true meaning of the <code>protected</code> keyword is quite simple. To classes in the same package, protected access looks just like package access. Any class can access any protected member of another class declared in the same package. </p><p>When you have subclasses in other packages, however, the true meaning of <code>protected</code> becomes more complex. Take a look at the inheritance hierarchy shown in Figure 5-5. In this hierarchy, class <code>Cup</code>, which is declared in the <code>com.artima.vcafe.dishes</code> package, declares a protected instance method named <code>getSize()</code>. This method is accessible to any subclasses declared anywhere, including those shown declared in package <code>com.artima.other</code>. Any objects whose class descends from <code>Cup</code>--instances of class <code>CoffeeCup</code>, <code>CoffeeMug</code>, <code>EspressoCup</code>, or <code>TeaCup</code>-- can invoke <code>getSize()</code> on themselves. Whether they can invoke <code>getSize()</code> on a reference to another object, however, depends upon where that other object sits in the inheritance hierarchy. </p><p><img src="images/packFig5.gif"><br> Figure 5-5. The true meaning of <code>protected</code>. </p><p>If a protected instance variable or instance method is accessible to a class, that class can access the protected member through a reference only if the reference type is the class or one of its subclasses. For example, for code in the <code>CoffeeCup</code> class to invoke <code>getSize()</code> on a reference to another object, that reference must be of type <code>CoffeeCup</code> or one of its subclasses. A <code>CoffeeCup</code> object could therefore invoke <code>getSize()</code> on a <code>CoffeeCup</code> reference, a <code>CoffeeMug</code> reference, or an <code>EspressoCup</code> reference. A <code>CoffeeCup</code> object could not, however, invoke <code>getSize()</code> on a <code>Cup</code> reference or a <code>TeaCup</code> reference. </p><p>If class has a protected variable or method that is <code>static</code>, the rules are different. Take as an example the protected static method <code>getCupsInUse()</code> declared in class <code>Cup</code> as shown in Figure 5-5. Any code in a subclass of <code>Cup</code> can access a <code>getCupsInUse()</code> by invoking it on itself or invoking it on a reference of type <code>Cup</code> or any of its subclasses. Code in the <code>EspressoCup</code> class could invoke <code>getCupsInUse()</code> on itself or on a reference of type <code>Cup</code>, <code>CoffeeCup</code>, <code>CoffeeMug</code>, <code>EspressoCup</code>, or <code>TeaCup</code>. </p><h2>Rules of Thumb for Class Member Access Levels</h2> <p>The most important rule of thumb concerning the use of access control modifiers is to keep data private unless you have a good reason not to. Keeping data private is the best way to maximize the robustness and ease of modification of your classes. If you keep data private, other classes can access a class's fields only through its methods. This enables the designer of a class to keep control over the manner in which the class's fields are manipulated. If fields are not private, other classes can change the fields directly, possibly in unpredictable and improper ways. Keeping data private also enables a class designer to more easily change the algorithms and data structures used by a class. Given that other classes can only manipulate a class's private fields indirectly, through the class's methods, other classes will depend only upon the external interface to the private fields provided by the methods. You can change the private fields of a class and modify the code of the methods that manipulate those fields. As long as you don't alter the signature and return type of the methods, the other classes that depended on the previous version of the class will still link properly. Making fields private is the fundamental technique for hiding the implementation of Java classes. </p><p>As mentioned in an earlier chapter, one other reason to make data private is because you synchronize access to data by multiple threads through methods. This justification for keeping data private will be discussed in Chapter 17. </p><p>As a general rule, the only good non-private field is a final one. Given that final fields cannot be changed after they are initialized, non-private final fields do not run the risk of improper manipulation by other classes. Other classes can use the field, but not change it. </p><p>A common use of non-private final fields is to define names to represent a set of valid values that may be passed to (or returned from) a method. As mentioned in Chapter 5, such fields are called constants and are declared static as well as non-private and final. A Java programmer will create constants in this manner in situations where a C++ programmer would have used an enumerated type or declared a "const" member variable. </p><p>Rules of thumb such as the ones outlined above are called rules of thumb for a reason: They are not absolute laws. Java allows you to declare fields in classes with any kind of access level, and you may very well encounter situations in which declaring a field private is too restrictive. One potential justification for non-private fields is simple trust. In some situations you may have absolute trust of certain other classes. For example, perhaps you are designing a small set of types that must work together closely to solve a particular problem. It may make sense to put all of these types in their own package, and allow them direct access to some of each other's fields. Although this would create interdependencies between the internal implementations of the classes, you may deem the level of interdependency to be acceptable. If later you change the internal implementation of one of the classes, you'll have to update the other classes that relied on the original implementation. As long as you don't grant access to the fields to classes outside the package, any repercussions of the implementation change will remain inside the package. </p><p>Nevertheless, the general rule of thumb in designing packages is to treat the types that share the same package with as much suspicion as types from different packages. If you don't trust classes from other packages to directly manipulate your class's fields, neither should you let classes from the same package directly manipulate them. Keep in mind that you usually can't prevent another programmer from adding new classes to your package, even if you only deliver class files to that programmer. If you leave all your fields with package access, a programmer using your package can easily gain access to those fields by creating a class and declaring it as a member of your package. Therefore, it is best to keep data private, except sometimes when the data is final, so that irrespective of what package classes are defined in, all classes must go through methods to manipulate each other's fields. </p><p>The methods you define in public classes should have whatever level of access control matches their role in your program. You should exploit the full range of access levels provided by Java on the methods of your public classes, assigning to each method the most restrictive access level it can reasonably have. </p><p>You can use the same rule of thumb to design classes that have package access. You must keep in mind, however, that for package-access classes, fields and methods declared public won't be accessible outside the package. Fields and methods declared protected won't be accessible to subclasses in other packages, because there won't be any subclasses in other packages. Only classes within the same package will be able to subclass the package-access class. Still, you should probably keep the same mindset when designing package-access classes as you do when designing public classes, because at some later time you may turn a package-access class into a public class. </p><h2>Access Levels for Interfaces</h2> <p>Interfaces have slightly different rules for access levels, because every field and method defined by an interface is implicitly public. You can't use the keywords <code>private</code> or <code>protected</code> on the fields and methods of interfaces. If you leave off the <code>public</code> keyword when declaring interface members, as is officially recommended by the Java Language Specification, you do not get package access. You still get public access. Therefore, you can't hide any implementation details of a package inside an interface (You can't hide an interface's members). On the other hand, you can hide the entire interface. If you don't declare an interface public, the interface as a whole will only be available to other types in the same package. As with classes, you should make interfaces public only if they are needed by classes and interfaces defined in other packages. </p><p>Here's an example of two interfaces. Interface <code>Soakable</code> is part of the internal implementation of a package. Interface <code>Washable</code> is part of the external implementation of the package: </p><pre>
// In Source Packet in file
// packages/ex5/com/artima/vcafe/dishes/Washable.java
package com.artima.vcafe.dishes;

public interface Washable {

    void wash();
}

// In Source Packet in file
// packages/ex5/com/artima/vcafe/dishes/Soakable.java
package com.artima.vcafe.dishes;

interface Soakable extends Washable {

    void soak();
}
</pre> <p>In this example, <code>wash()</code> and <code>breakIt()</code> are not explicitly declared public, because they are public by default. Because the <code>Washable</code> interface as a whole is not explicitly declared as public, however, it has package access. Interface <code>Washable</code> is only be accessible to other types declared in the <code>com.artima.vcafe.dishes</code> package. Interface <code>Breakable</code>, because it is declared as public, is available to any type declared in any package. </p><h2>Mention This</h2> <p> The compiler gives default constructors the same access level as their class. In the example above, class <code>CoffeeCup</code> is public, so the default constructor is public. If <code>CoffeeCup</code> had been given package access (which will be defined in , the default constructor would be given package access as well. </p><p> Example: How Singleton pattern can be implemented using private constructors. </p></a>
  </div>
  <a name="index-importing+types-definition"> 
   <hr width="100%"> 
   <table width="50%" align="center"> 
    <tbody>
     <tr> 
      <td> 
       <div class="horizontaltextadbox"> 
        <div class="adheadline">
         Sponsored Links
        </div> 
        <div id="sponsoredlinks"> 
        </div> 
       </div> </td> 
     </tr> 
    </tbody>
   </table> 
   <hr width="100%"> 
   <center> 
    <script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script> 
    <script type="text/javascript" src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script> 
    <br> 
    <br> 
    <!-- SiteSearch Google --> 
    <form method="get" action="https://www.google.com/custom"> 
     <table border="0" bgcolor="#ffffff"> 
      <tbody>
       <tr>
        <td nowrap valign="top" align="left" height="32"> <a href="https://www.google.com/"> <img src="https://www.google.com/logos/Logo_25wht.gif" border="0" alt="Google"></a> </td> 
        <td nowrap> <input type="hidden" name="domains" value="Artima.com"> <input type="text" name="q" size="31" maxlength="255" value=""> <input type="submit" name="sa" value="Search"> </td>
       </tr> 
       <tr> 
        <td>&nbsp;</td> 
        <td nowrap> <font size="-1" color="#000000"> <input type="radio" name="sitesearch" value=""> Web <input type="radio" name="sitesearch" value="Artima.com" checked>Artima.com </font>&nbsp;&nbsp; <input type="hidden" name="client" value="pub-3911176865765226"> <input type="hidden" name="forid" value="1"> <input type="hidden" name="ie" value="ISO-8859-1"> <input type="hidden" name="oe" value="ISO-8859-1"> <input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;"> <input type="hidden" name="hl" value="en"> </td>
       </tr>
      </tbody>
     </table> 
    </form> 
    <!-- SiteSearch Google --> 
   </center> </a>
  <div class="sp">
   <a name="index-importing+types-definition"> 
    <div style="text-align: center"> 
     <a href="https://www.artima.com/copyright.html">Copyright</a> © 1996-2017 Artima, Inc. All Rights Reserved. - 
     <a href="https://www.artima.com/privacy.html">Privacy Policy</a> - 
     <a href="https://www.artima.com/termsofuse.html">Terms of Use</a> - 
     <a href="https://www.artima.com/advertising.html">Advertise with Us</a> 
    </div></a> 
  </div> 
  <br> 
  <script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = 'https://www.artima.com/zcr/' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script> 
  <script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(1);
-->
</script> 
  <script language="JavaScript" type="text/javascript">
<!--
replaceDiv('topbanner');
-->
</script> 
  <script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script> 
  <script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>   
 </body>
</html>