<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
  <title>May Column: Multi-threaded Algorithm Implementations - O'Reilly Broadcast</title> 
  <meta name="generator" content="Movable Type Pro 4.21-en"> 
  <!-- metas7 --> 
  <meta name="keywords" content="algorithms"> 
  <meta name="description" content="Many of the algorithms presented in the book,  <a href=&quot;http://oreilly.com/catalog/9780596516246/&quot;>Algorithms in a Nutshell</a>, can take advantage of multi-core chips by using threads. In this column we explore effective uses of threads and report on situations where using threads will not help. "> 
  <meta name="search_date" content="2009-06-18"> 
  <meta name="author" content="George T. Heineman"> 
  <!-- metas7 --> 
  <link rel="alternate" type="application/atom+xml" title="O'Reilly News" href="http://feeds.oreilly.com/oreilly/news"> 
  <link rel="alternate" type="application/atom+xml" title="George T. Heineman" href="http://broadcast.oreilly.com/george-t-heineman/atom.xml"> 
  <script src="http://blogs.oreilly.com/broadcast/_ui/js/jquery.js" type="text/javascript" charset="utf-8"></script> 
  <script src="http://blogs.oreilly.com/broadcast/_ui/js/main.js" type="text/javascript" charset="utf-8"></script> 
  <!-- removed --> 
  <script language="JavaScript" type="text/javascript" src="http://broadcast.oreilly.com/mt.js"></script> 
  <script language="JavaScript" type="text/javascript" src="http://www.oreillynet.com/engine.js"></script> 
  <script type="text/javascript" src="http://blogs.oreilly.com/scripts/highslide/highslide.js"></script> 
  <script type="text/javascript" src="http://blogs.oreilly.com/scripts/highslide/highslide-html.js"></script> 
  <script type="text/javascript">    
    hs.graphicsDir = 'http://blogs.oreilly.com/scripts/highslide/graphics/';
    hs.outlineType = 'rounded-white';
    hs.outlineWhileAnimating = true;
</script> 
  <script language="javascript" src="http://blogs.oreilly.com/rave/rave.js"></script> 
  <script language="javascript" src="http://blogs.oreilly.com/menutest.js"></script> 
  <!-- readspeak --> 
  <script>
<!--
function readspeaker(rs_call, rs_file_name)
{
savelink=rs_call+"&save=1&audiofilename="+rs_file_name; /* Build the save link by adding the required parameters */
rs_call=rs_call+"&output=audio";			/* build the ReadSpeaker Enterprise call */
rs_call=escape(rs_call);				/* URL Encode the url since it will be used as a query string parameter */

start_rs_table="<table style='border:1px solid #aeaeae; font-size: 10px; padding-right: 4px;'><tr><td>"; /* Create the table for the inserted player etc */

/* create the embedded flash player that uses the ReadSpeaker Enterprise call */

rs_embed="<object type='application/x-shockwave-flash' data='http://app.readspeaker.com/wr/dewplayer.swf?mp3="+rs_call+"&bgcolor=FFFFFF&showtime=1&autoplay=1' height='20' width='170'><param name='movie' value='http://app.readspeaker.com/wr/dewplayer.swf?mp3="+rs_call+"&autoplay=1'><param name='quality' value='high'><param name='SCALE' value='exactfit'><param name='wmode' value='transparent'><embed wmode='transparent' src='http://app.readspeaker.com/wr/dewplayer.swf?mp3="+rs_call+"' quality='high' pluginspage='http://www.macromedia.com/go/getflashplayer' type='application/x-shockwaveflash' autostart=1 scale='exactfit' height='20' width='170'></embed></object>";
rs_downloadlink="<br><a href='"+savelink+"'>Download audio</a><br />powered by <a href='http://www.voice-corp.com/'>Readspeaker</a>";		/* create the download link */
close_rs=" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          <a href='#' onclick='close_rs_div();'>[X]</a>"; /* create the "close window" link */
end_rs_table="</td></tr></table>";					/* create the end of the table */

var x=document.getElementById('rs_div');	/* get hold of the DIV with the ID "rs_div" see in the body of this page */
x.innerHTML=start_rs_table+rs_embed+rs_downloadlink+close_rs+end_rs_table;	/* write the HTML code that was created above into the page */
}

function close_rs_div()
{
var x=document.getElementById('rs_div');	/* get hold of the DIV with the ID "rs_div" see in the body of this page */
x.innerHTML="";					/* fill it with nothing */
}
//-->
</script> 
  <link rel="stylesheet" href="http://broadcast.oreilly.com/styles.css?3" type="text/css"> 
  <!--Auto Complete --> 
  <script type="text/javascript" src="http://content.atomz.com/static/ac/1.0/autocomplete.js"></script> 
  <link rel="stylesheet" type="text/css" href="http://content.atomz.com/pb000035c5/publish/autocompletestyles.css"> 
  <!-- MarketLive Head Elements --> 
  <!--script type="text/javascript" src="http://shop.oreilly.com/includes/jquery/jquery-1.4.min.js"></script--> 
  <script type="text/javascript" src="http://shop.oreilly.com/includes/jquery/plugins/jquery.hoverIntent.minified.js"></script> 
  <script type="text/javascript" src="http://shop.oreilly.com/includes/jquery/plugins/jquery.bgiframe.min.js"></script> 
  <script type="text/javascript" src="https://shop.oreilly.com/includes/jquery/plugins/jquery.popDown.js"></script> 
  <script type="text/javascript" src="http://shop.oreilly.com/includes/jquery/plugins/jquery.autocomplete.js"></script> 
  <script src="http://shop.oreilly.com/mod/productquickview/includes/pqv.compressed.js"></script> 
  <link href="http://shop.oreilly.com/mod/productquickview/includes/themes/default.css" rel="stylesheet" type="text/css"> 
  <link href="http://shop.oreilly.com/mod/productquickview/includes/themes/pqv.css" rel="stylesheet" type="text/css"> 
  <link REL="stylesheet" TYPE="text/css" HREF="http://shop.oreilly.com/includes/stylesheet.css" TITLE="style"> 
  <link rel="shortcut icon" href="http://shop.oreilly.com/images/oreilly/en_us/favicon.ico" type="image/vnd.microsoft.icon"> 
  <script type="text/javascript" src="https://shop.oreilly.com/includes/headerScripts.js"></script> 
  <!-- MyBuys libraries and style sheet --> 
  <link href="http://t.p.mybuys.com/css/mbstyles.css" type="text/css" rel="stylesheet" id="mybuysstyles"> 
  <script type="text/javascript" src="http://t.p.mybuys.com/js/mybuys3.js"></script> 
  <script type="text/javascript" src="http://t.p.mybuys.com/clients/OREILLY/js/setup.js"></script> 
  <!-- #MyBuys libraries and style sheet --> 
 </head> 
 <body onload="setMenu();" id="community" class="mt-archive-listing mt-entry-archive layout-twt"> 
  <div id="page"> 
   <script>
	var iPop_imagePath='https://ormstore-prod.oreilly.com/images/oreilly/en_us/';//use this image path along with the IPop.js
	</script> 
   <script src="https://ormstore-prod.oreilly.com/includes/lPop.js"></script> 
   <script type="text/javascript" src="https://ormstore-prod.oreilly.com/includes/jquery/plugins/jquery.expandCollapseList.js"></script> 
   <div id="popdiv"></div> 
   <noscript> 
    <a href=" http://www.quantcast.com/p-20l78bOOCbhcg " target="_blank"><img src=" http://pixel.quantserve.com/pixel/p-20l78bOOCbhcg.gif?tags=News " style="display: none;" border="0" height="1" width="1" alt="Quantcast"></a> 
   </noscript>
   <table width="990" border="0" cellpadding="0" cellspacing="0" class="mainLayoutTable"> 
    <tbody>
     <tr> 
      <td class="navheaderbg"> 
       <div> 
        <!--top-header-div--> 
        <!--TopNav Start--> 
        <script type="text/javascript">
					  function checkIfDefault(keyword) {
						var defaultSearchTerm = "Search";
							if(keyword==defaultSearchTerm) {
						  return '';
						}
						else {
						  return keyword;
		}
						  }
					</script> 
        <div id="header" style="width:990px;"> 
         <div class="logo"> 
          <a href="http://broadcast.oreilly.com/"> <img src="http://cdn.oreilly.com/images/sitewide-headers/ml-header-community.png" border="0" alt="May Column: Multi-threaded Algorithm Implementations - O'Reilly Broadcast"></a> 
         </div> 
         <div class="tools"> 
          <p><a href="https://members.oreilly.com" class="signInLinkmy">Your Account</a></p> 
          <div id="globalBasket" class="popDownWrapper globalCartWrapper" style=" margin:2px 0px 0px 0px; width:239px;"> 
           <div class="popDownNav globalCartNav"> 
            <div class="globalCartBasketImg" style=""> 
             <img src="http://cdn.oreilly.com/images/sitewide-headers/basketicon.gif" border="0" alt="Shopping" cart=""> 
            </div> 
            <div class="globalCartBasketInfo" style=""> 
             <a href="http://shop.oreilly.com/basket.do"><span class="navHeader">Shopping Cart</span></a> 
            </div> 
           </div> 
           <!--popDownNav--> 
          </div> 
          <!--globalBaseket --> 
         </div> 
         <!--tools--> 
         <div id="search-box" class="yui-skin-sam"> 
          <form name="searchform" method="get" id="search-form" action="http://search.oreilly.com/"> 
           <div class="search"> 
            <fieldset> 
             <span id="search-input"> 
              <div class="searchInput"> 
               <span id="search-field"><input type="text" value="Search" name="q" maxlength="64" id="q" onfocus="this.value=checkIfDefault(this.value);"></span> 
              </div> <span id="search-button"> <input type="image" value="SEARCH" src="http://cdn.oreilly.com/images/sitewide-headers/search_btn.gif" border="0" style="float:left" alt="Search" align="top"> </span> </span> 
             <div id="autocomplete"></div> 
            </fieldset> 
           </div>
           <!--search--> 
          </form> 
         </div>
         <!--search-box--> 
        </div>
        <!--header--> 
        <ul id="primarynav"> 
         <li><a href="http://oreilly.com" title="">Home</a></li> 
         <li><a href="http://shop.oreilly.com" title="">Shop</a></li> 
         <li><a href="http://radar.oreilly.com" title="" ">Radar: News &amp; Commentary</a></li> 
         <li><a href="http://answers.oreilly.com/" title="">Answers</a></li> 
         <li><a href="http://safari.oreilly.com/?cid=orm-nav-global" title="">Safari Books Online</a></li> 
         <li><a href="http://conferences.oreilly.com/" title="">Conferences</a></li> 
         <li><a href="http://training.oreilly.com/" title="">Training</a></li> 
         <li><a href="http://www.oreillyschool.com/" title="">School of Technology</a></li> 
         <li class="current" style="border-right:0;"><a href="http://people.oreilly.com/index.php?app=members&amp;section=view&amp;module=list" class="current title=">Community</a></li> 
        </ul> 
       </div> 
       <!--top-header-div--> 
       <div> 
        <!--bottom-header-div--> 
        <div id="sf-menu-text-nav"> 
         <script type="text/javascript" src="https://ormstore-prod.oreilly.com/includes/jquery/plugins/superfish.js"></script> 
         <script type="text/javascript" src="https://ormstore-prod.oreilly.com/includes/jquery/plugins/supersubs.js"></script> 
         <ul class="sf-menu"> 
          <li> 
           <div id="tnc_100015">
            <a class="sf-top-level-link" href="http://oreilly.com/authors/"><span>Authors</span></a>
           </div> </li> 
          <li> 
           <div id="tnc_100164">
            <a class="sf-top-level-link current" href="http://oreilly.com/blogs/"><span>Blogs</span></a>
           </div> </li> 
          <li> 
           <div id="tnc_100165">
            <a class="sf-top-level-link" href="http://forums.oreilly.com"><span>Forums</span></a>
           </div> </li> 
          <li> 
           <div id="tnc_100167">
            <a class="sf-top-level-link" href="http://ug.oreilly.com/"><span>User Groups</span></a>
           </div> </li>
          <li> 
           <div id="tnc_100169">
            <a class="sf-top-level-link" href="http://members.oreilly.com"><span>Membership</span></a>
           </div> </li> 
          <li> 
           <div id="tnc_100168">
            <a class="sf-top-level-link" href="http://oreilly.com/community/guidelines.html"><span>Community Guidelines</span></a>
           </div> </li> 
          <li class="GlobalNavInfo">
           <div>
            1-800-998-9938 / 707-827-7000 / accounts@oreilly.com
           </div> 
           <div class="social">
            <a class="youtube" href="http://youtube.com/oreillymedia"><span class="hidden">YouTube</span></a> 
            <a class="facebook" href="http://www.facebook.com/OReilly"><span class="hidden">Facebook</span></a> 
            <a class="twitter" href="http://twitter.com/oreillymedia"><span class="hidden">Twitter</span></a> 
            <a class="rss" href="http://feeds.feedburner.com/oreilly/news"><span class="hidden">RSS</span></a> 
           </div> </li> 
         </ul> 
         <script type="text/javascript">
						
							jQuery(document).ready(function($){
								jQuery("ul.sf-menu").supersubs({ 
						
									minWidth:    12,   // minimum width of sub-menus in em units 
						
									maxWidth:    27,   // maximum width of sub-menus in em units 
						
									extraWidth:  1     										// extra width can ensure lines don't sometimes turn over 
																											// due to slight rounding differences and font-family 
								}).superfish({ 
						
									delay:       450,   // millisecond delay on mouseout 
						
									animation:   {opacity:'show'},							// animation style 
						
									speed:       1,															// animation speed 
						
									autoArrows:  false,                         // arrow mark-up config 
						
									dropShadows: true       // drop shadow config 
						
								}).find('ul').bgIframe({opacity:false});
								// make top cats stay 'on' when hovering over their subs 
								jQuery("ul.sf-menu").find("a[onmouseover]").each(function (i){
									jQuery(this).parent("li").find("ul:first").hover(jQuery(this).attr("onmouseover"), jQuery(this).attr("onmouseout"));
								});
							});
						</script> 
         <!-- dhtml menu end --> 
        </div> 
        <!--sf-menu-text-nav--> 
       </div> 
       <!--bottom-header-div--> </td> 
     </tr> 
     <tr> 
      <td> 
       <div id="content-09" style="border:none;"> 
        <div id="content"> 
         <div id="content-inner"> 
          <div id="alpha"> 
           <div id="alpha-inner"> 
            <div id="entry-37158" class="entry-asset asset hentry"> 
             <!-- toolbar --> 
             <div class="floater" style="float: right; display:block; text-align:left;"> 
              <table class="navbar" width="180"> 
               <!-- print --> 
               <tbody>
                <tr height="20">
                 <td align="right"> <a href="#" style="text-decoration:none" onclick="window.open('http://broadcast.oreilly.com/print/37158.html','print','width=800,height=600,menubar=no,status=no,location=yes,toolbar=yes,scrollbars=yes'); return false;"><img src="http://cachefly.oreilly.com/news/images/printtag.jpg" style="padding-left: 90px;padding-right: 5px;" border="0">Print</a> </td>
                </tr> 
                <!--twitter button --> 
                <!--tr height="26"><td align="right">
<a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="oreillymedia" data-related="radar:radar.oreilly.com">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
</td></tr--> 
                <!-- listen --> 
                <tr height="20">
                 <td align="right"> <a accesskey="L" href="http://app.readspeaker.com/cgi-bin/rsent?customerid=14&amp;lang=en_us&amp;url=http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html" onclick="readspeaker(this.href+'&amp;selectedhtml='+escape(selectedString), 'rs_37158'); return false;" style="text-decoration:none;"><img border="0" src="http://cachefly.oreilly.com/news/images/listentag.jpg" style="padding-left: 90px; padding-right: 5px;" alt="Listen to the text content of this page">Listen</a>
                  <div class="readspeak">
                   <div id="rs_37158" style="padding-right: 4px; text-align: right;"></div>
                  </div> </td>
                </tr> 
                <!-- share --> 
                <tr height="20"> 
                 <td align="right"> 
                  <div id="share-options" style="padding:3px 0 3px 90px;"> 
                   <script type="text/javascript" src="http://w.sharethis.com/button/sharethis.js#publisher=16098316-763b-41fc-a31d-7bbadcfcf894&amp;type=website&amp;embeds=true&amp;style=rotate&amp;send_services=email%2Caim%2Csms&amp;post_services=twitter%2Cfriendfeed%2Cfacebook%2Cdigg%2Cdelicious%2Creddit%2Cslashdot%2Cgoogle_bmarks%2Cblogger%2Ctypepad%2Cstumbleupon%2Cwordpress%2Cwindows_live%2Cnewsvine%2Clinkedin%2Cmyspace%2Ctechnorati"></script> 
                  </div> </td>
                </tr> 
               </tbody>
              </table> 
             </div>
             <!-- floater#--> 
             <!-- #toolbar --> 
             <div class="asset-header" style="float: left; display:block; width: 300px;"> 
              <h1 id="page-title" class="asset-name entry-title">
               <!-- RSPEAK_START -->May Column: Multi-threaded Algorithm Implementations
               <!-- RSPEAK_STOP --></h1> 
              <div class="asset-meta"> 
               <img src="http://www.oreillynet.com/images/people/weblogs/george_heineman.jpg" style="padding-right: 5px; padding-top: 2px; float: left; border: none;" alt="">
               <!-- RSPEAK_START -->By 
               <a href="http://www.oreillynet.com/pub/au/3414">George T. Heineman</a>
               <br>June 18, 2009
               <!-- RSPEAK_STOP --> 
               <span class="separator">|</span> 
               <a href="http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html#comments">Comments: 2</a>
               <br> 
               <p class="asset-meta"><span class="social-counters"> <span class="retweet"><a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-url="http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html" data-text="May Column: Multi-threaded Algorithm Implementations" data-via="oreillymedia" data-related="radar:radar.oreilly.com">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script></span> <span class="plus">
                  <g:plusone href="http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html" size="medium" count="true"></g:plusone></span> <span class="like"><iframe src="http://www.facebook.com/plugins/like.php?href=http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html&amp;layout=button_count&amp;show_faces=false&amp;width=200&amp;action=like&amp;colorscheme=light&amp;height=20" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:110px; height:20px;" allowtransparency="true"></iframe></span> </span></p> 
              </div> 
             </div> 
             <div class="asset-content entry-content"> 
              <div class="asset-body"> 
               <!-- RSPEAK_START --> 
               <p>This is the seventh of a series of monthly columns in the blog associated with the <a href="http://oreilly.com/catalog/9780596516246/">Algorithms in a Nutshell</a> book, published October 2008 by <a href="http://oreilly.com">O'Reilly Media, Inc.</a></p>
               <p></p> 
               <p>The past six blog entries (which you can find at the end of <a href="http://broadcast.oreilly.com/2009/05/april-column-computational-geo.html">last month's column</a>) described in greater detail algorithms drawn from the chapters of our book. In the remaining entries for this year, we will "branch out" and cover some new territory, or at least provide a different perspective to existing results from the book. At the end of last month's column, I promised to explore the sorting algorithm <span style="font-variant: small-caps;">IntroSort</span> but that discussion will have to wait until a future blog entry because I got caught up instead with the notion of multithreading. In computer science a thread can be considerably more "light-weight" than an operating system process. With the increasing support for and popularity of multi-core processing chips, the use of threads has the potential to take advantage of these multi-core chips with only minimal change to the underlying algorithm implementation.</p>
               <p></p> 
               <p>In this column we explore how to use threads in Java and C, on both Windows machines and Unix architectures. For this column we focus on the following examples:</p> 
               <ul> 
                <li><a href="#MTQS">Multi-threaded <span style="font-variant: small-caps;">QuickSort</span></a> in C with a single helper thread</li> 
                <li><a href="#MTJ">Multi-threaded <span style="font-variant: small-caps;">QuickSort</span></a> in Java with a single helper thread</li> 
                <li>How to <a href="#gen">generalize</a> such a solution to support an arbitrary number of helper threads</li> 
                <li><a href="#MTCH">Multi-threaded ConvexHull</a> in Java with a single helper thread</li> 
                <li>An example of when threading does not help: <a href="#MTNN">Multi-threaded Nearest-Neighbor</a></li> 
                <li><a href="#MTLL">Lessons Learned</a></li> 
               </ul> 
               <p>All of the code provided for this month's Blog is new. While developing this code, I actually decided to implement a new ConvexHull algorithm known as <span style="font-variant: small-caps;">QuickHull</span>, but that discussion will have to wait until next Month's June Blog entry.</p>
               <p></p> 
               <p><strong><a name="may_2009"></a>Download May Code Samples</strong></p>
               <p></p> 
               <p>You can download the code samples described in this column from the <i>code.zip</i> file found at <a href="http://examples.oreilly.com/9780596516246/Blogs/May_2009/code.zip">code.zip</a> (206,753 bytes). The following examples were tested on a standard Windows desktop computer running <a href="http://www.eclipse.org">Eclipse Version 3.4.1</a>. The <a href="http://java.sun.com/javase/6/">JDK version</a> is 1.6.0_13. In fact, the <i>code.zip</i> file is actually an exported Eclipse project, which means you will be able to easily load this month's code into your Eclipse workspace. Should you choose to compile and execute these examples outside of Eclipse, simply ensure that your CLASSPATH variable is properly configured to use the compiled sources of the ADK.</p>
               <p></p> 
               <p>To bring this month's code into Eclipse, simply unzip the code.zip file found at code.zip. Once you have unzipped the files, in Eclipse choose to create a New Java Project. For the "Project name" enter "May 2009". Then choose the "Create project from existing source" radio button and browse to the location where you unzip'd the code.zip file. Make sure you select the directory named "May_2009". Then click Finish. If you have already imported the JavaCode project from the ADK into this Eclipse workspace, then the code should compile cleanly; if you have not, then you will need to tell this Eclipse project about the location of the compiled Jar file for the ADK in which the implemented algorithms can be found.</p>
               <p></p> 
               <p><strong><a name="MTQS"></a>Multi-threaded <span style="font-variant: small-caps;">QuickSort</span> in Java with a single helper thread</strong></p>
               <p></p> 
               <p><span style="font-variant: small-caps;">QuickSort</span> is able to decompose a larger sorting problem into two smaller subproblems. </p> 
               <pre>
/**
 * Straight quicksort.
 *
 * @param ar           array to be sorted.
 * @param cmp          comparison function.
 * @param left         lower bound index position  (inclusive)
 * @param right        upper bound index position  (inclusive)
 */
void quickSort(void **ar, int(*cmp)(const void *,const void *),
               int left, int right) {
  if (left &lt; right) {
    int p = partition(ar, cmp, left, right);
    quickSort(ar, cmp, left, p-1);
    quickSort(ar, cmp, p+1, right);
  }
}
 <br>
</pre>
               <b>Fig. 1</b>: 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in C
               <p> </p>
               <p>The two subproblems <i>sort ar[left, pi-1]</i> and <i>sort ar[p+1, right]</i> are independent problems and, theoretically, can be solved at the same time. It has long been hoped that sophisticated compilers would be able to detect such situations and automatically generate code to construct and execute threads. Until such time, however, we have to take care of this work manually.</p>
               <p></p> 
               <p>Let's first start by constructing a solution with a single helper thread that will be used to complete one of these quickSort subtasks. However, thread resources are precious and we must be careful when we use extra threads. Should we use it on a large subproblem or only for small ones? Let's decide to use a helper thread to solve a subproblem if (a) there currently is no helper thread working; and (b) the requested number of elements to sort is below a specific threshold value. We can experimentally evaluate different threshold values to see what might be a good choice. Rather than choose an absolute threshold value, we choose to set the threshold value to N/R where N is the number of elements to be sorted and R is a user-specified ratio value. Thus, when R=1, the threshold value is set to N and the program tries to always solve subproblems with the helper thread, should it be available. When R=MAXINT then the threshold value is set to ZERO and therefore the program never uses a helper thread. We constructed an experiment to run 20 trials of sorting N={65536, 131072, 262144, 524288, and 1048576} random 26-character strings using values of R from 1 to 50; there is one final run for R=MAXINT. The following graphs show the results of execution on a Linux box with four Dual-Core AMD Opteron(tm) Processor chips.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="performanceNR.PNG" src="http://broadcast.oreilly.com/Aian/performanceNR.PNG" width="541" height="421" class="mt-image-none" style=""></span><br><b>Fig. 2</b>: Performance of Multi-Thread <span style="font-variant: small-caps;">QuickSort</span> for varying N and R.</p>
               <p></p> 
               <p>Reading the graph from left to right, you can see that the first data point (R=1) reports the performance that tries to immediately begin using the helper thread while the last data point (R=51) reports the result when no helper thread is ever used. When we compute the "speedup factor" from time T1 to a smaller time T2, we use the equation T1/T2. Simply using an extra thread shows a speedup factor of 1.19 for 65,536 strings to 1.52 for 1,048,576. This is a very nice return on investment for a small programming change!</p> 
               <table cellpadding="3" cellspacing="3" border="2" style="border-collapse: collapse" id="diffTableID"> 
                <tbody>
                 <tr>
                  <td><em>n</em></td>
                  <td>Speedup of Multi-thread to no thread</td>
                 </tr> 
                 <tr>
                  <td>65,536</td>
                  <td>1.19</td>
                 </tr> 
                 <tr>
                  <td>131,072</td>
                  <td>1.32</td>
                 </tr> 
                 <tr>
                  <td>262,144</td>
                  <td>1.26</td>
                 </tr> 
                 <tr>
                  <td>524,288</td>
                  <td>1.51</td>
                 </tr> 
                 <tr>
                  <td>1,048,576</td>
                  <td>1.52</td>
                 </tr> 
                 <tr>
                  <td>2,097,152</td>
                  <td>1.36</td>
                 </tr> 
                 <tr>
                  <td>4,194,304</td>
                  <td>1.61</td>
                 </tr> 
                 <tr>
                  <td>8,388,608</td>
                  <td>1.38</td>
                 </tr> 
                </tbody>
               </table> 
               <a name="diffTable"></a>
               <b>Table 1: </b>Speedup for (ratio=1) vs. (ratio=MAXINT).
               <p> </p>
               <p>Returning to <b>Fig. 2</b>, you can see that the best improvement occurs near where R=2, and as N increases in size, it appears that the best result appears when R=3 or R=4. My interpretation is that there is a built-in overhead to using threads, and one shouldn't automatically dispatch a new thread of execution without some assurance that the primary thread will not have to wait and "block" until the helper thread completes its execution. It seems the "sweet spot" is near where R=4.</p>
               <p></p> 
               <p>Another way to view the results from <b>Fig. 2</b> is to compare the ratio of performance as compared against R=1 (always initiating a helper thread when available). As you can see in <b>Fig. 3</b>, there is an initial performance benefit for small R (such as R=2, 3 or 4) but over time as R increases the benefit becomes smaller. Indeed for large enough n (greater than 131,072, for example), the actual performance of delaying a threaded subproblem only for "small enough" problems actually becomes worse than simply multithreading at every opportunity. The final point (R=51) in <b>Fig. 3</b> reflects the numeric values from <b>Table 1</b>.</p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="performanceRatioNR.PNG" src="http://broadcast.oreilly.com/Aian/performanceRatioNR.PNG" width="554" height="426" class="mt-image-none" style=""></span><br><b>Fig. 3: </b>Comparing the performance ratio of multi-thread <span style="font-variant: small-caps;">QuickSort</span> with different N and R values.</p>
               <p></p> 
               <p>So let's see the solution. The fully coded solution is available in the <code>multithreadQsort.c</code> file found in this month's blog code file. First we show the modified <code>quickSort</code> routine, which we label as <code>quickSort2</code>. This code executes within a primary thread. <code>helpRequested</code> has the value 0 when no helper thread is currently processing a subproblem. For each of the two subproblems, there is a simple check to see whether the primary thread should continue the recursive <code>quickSort2</code> function call. As you can see, the separate helper thread is dispatched to compute a subproblem only if (a) no help is currently requested and (b) the size of the subproblem is smaller than the specified threshold value. This logic is applied to both the sorting of the left sub-array as well as the sorting of the right sub-array.</p>
               <p></p> 
               <p>To dispatch the helper thread to solve a subproblem, the primary thread sets the value of <code>helpRequested</code> to 1 after specifying to the helper the range of the sub-array which it is being asked to sort (either ar [left, p-1] or ar [p+1, right]).</p> 
               <pre>
/**
 * Quicksort that delegates to helper thread the sorting of a 
 * sub-array should a thread be available and if the problem 
 * size is small enough to warrant such an action.
 *
 * @param ar           array being sorted
 * @param cmp          comparison function to use
 * @param helper       context for helper thread
 * @param left         lower bound index position  (inclusive)    
 * @param right        upper bound index position  (inclusive) 
 */
void quickSort2(void **ar, int(*cmp)(const void *,const void *),
		THREAD_INFO *helper, int left, int right) {
  int p,n;
  
  if (left &lt; right) {
    p = partition(ar, cmp, left, right);
    n = p - left;
  
    /* If already requested help or problem too big, recurse. */
    if (helpRequested || n &gt;= helper-&gt;threshold) {
      quickSort2(ar, cmp, helper, left, p-1);
    } else  {
      /* initialize helper variables and ask for help. */
      helper-&gt;left = left;
      helper-&gt;right = p-1;
        
      helpRequested = 1;
    }
    
    n = right - p;
    if (helpRequested || n &gt;= helper-&gt;threshold) {
      quickSort2(ar, cmp, helper, p+1, right);
    } else {
      /* initialize helper variables and ask for help. */
      helper-&gt;left = p+1;
      helper-&gt;right = right;
      
      helpRequested = 1;
    }
  }
}
 <br>
</pre>
               <b>Fig. 4</b>: 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in C
               <p> </p>
               <p>To understand how the helper thread completes its task, we need to look at the <code>quickSort1</code> function which executes within the helper thread, as shown in <b>Fig. 5</b>. This thread runs until it is told that it is done, during which it checks to see if any help has been requested. Once <code>helpRequested</code> is "raised" (or otherwise set to 1) it immediately launches the single-threaded implementation of <code>quickSort</code> which was shown in <b>Fig. 1</b>. When it completes, it sets <code>helpRequested</code> back to 0 to announce it is once again free.</p>
               <p></p> 
               <p>Using Pthreads, the popular POSIX standard, the helper thread will first wait until all threads are ready to go (at the first <code>pthread_barrier_wait</code> invocation) and then, once done, it will wait a second time until all threads have synchronized to completion. It is worth pointing out the condition for the while loop in <code>quickSort1</code>; it would be incorrect to simply check <code>!done</code> since there may be a race condition that occurs if the primary thread decides that its final subtask needs to be performed within a helper thread. In this case, it is technically possible that both <code>done</code> and <code>helpRequested</code> are non-zero at the same time. For this reason, the while loop must check for either <code>!done</code> or helpRequested.<br> </p>
               <p> </p> 
               <pre>
/**
 * Helper thread executes single-thread QuickSort.
 *
 * @param arg    thread context
 */
void *quickSort1(void *arg) {
  THREAD_INFO *context = (THREAD_INFO *) arg;
  
  pthread_barrier_wait(&amp;barrier);
  
  /** Tight spin loop. Only do work if requested. */
  while (!done || helpRequested) {
    if (helpRequested) {
      quickSort(context-&gt;ar, context-&gt;cmp, 
                      context-&gt;left, context-&gt;right);
  
      helpRequested = 0;
    }
  }
  
  pthread_barrier_wait(&amp;barrier);
}
 <br>
</pre>
               <b>Fig. 5</b>: 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in C, continued...
               <p> </p>
               <p>The primary thread executes the <code>quickSortEntry</code> function as shown in <b>Fig. 6</b>. It synchronizes with the helper thread and then executes <code>quickSort2</code> as shown in <b>Fig. 4</b>. Once this function returns, <code>quickSortEntry</code> disables the helper thread and waits for its completion.</p>
               <p></p> 
               <pre>
/**
 * Entry point for primary thread.
 * 
 * Once synchronized, launches the primary sort routine.
 * 
 * @param arg    thread context
 */
void quickSortEntry(void *arg) {
  THREAD_INFO *context = (THREAD_INFO *) arg;
  
  /** Wait until all threads ready to go. */
  pthread_barrier_wait(&amp;barrier);
  
  /** When we get here, all threads are synchronized. 
   * numElements is a global storing the number of elements. */
  quickSort2(context-&gt;ar, context-&gt;cmp, context-&gt;helper,
	     0, numElements-1);
  
  /** Stop Helper thread. and wait for all threads before exit. */
  done=1;
  pthread_barrier_wait(&amp;barrier);
}
 <br>
</pre> 
               <b>Fig. 6</b>: 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in C, continued...
               <p> </p>
               <p>Please read the <code>multithreadQsort.c</code> file for full details on the <code>THREAD_INFO</code> data structure and how threads are properly initialized and launched.</p> 
               <p><strong><a name="MTJ"></a>Multi-threaded <span style="font-variant: small-caps;">QuickSort</span> in Java with a single helper thread</strong></p>
               <p></p> 
               <p>We can replicate the one-helper solution in Java, as shown in <b>Fig. 7</b>. This time, the elements being sorted are all integers rather than randomized 26-character strings used earlier.</p>
               <p></p> 
               <p>Because of the simplified threading model in Java, the code is simpler. Whenever <code>qsort2</code> determines that the number of elements to be sorted is smaller than the threshold and the helper is not working, it spawns a new thread. When this new thread completes its execution, it resets <code>helpRequested</code> back to <b>false</b>.</p> 
               <pre>
/**
 * Sort using quicksort method with separate helper thread.
 * Both left and right and bounded by [0, ar.length).
 * @param left     The left-bounds within which to sort 
 * @param right    The right-bounds within which to sort 
 */
public void qsort (final int left, final int right) {
  qsort2 (left, right);
  	
  // wait until helper is done (if it is still executing).
  while (helpRequested) { }
}
  
/**
 * Sort using quicksort method with separate helper thread.
 */
public void qsort2 (final int left, final int right) {
  if (right &lt;= left) { return; }
       
  // partition
  int p = pi.selectPivotIndex (ar, left, right);
  final int pivotIndex = partition (left, right, p);
      
  // If helper working or problem too big, continue with recursion
  int n = pivotIndex - left;
  if (helpRequested || n &gt;= threshold) {
    qsort2 (left, pivotIndex-1);
  } else {
    helpRequested = true;
   	
    // complete in separate thread
    new Thread () {
      public void run () {
        qsort2 (left, pivotIndex - 1);
        helpRequested = false;
      }
    }.start();
  }
   
  // If helper working or problem too big, continue with recursion
  n = right - pivotIndex;
  if (helpRequested || n &gt;= threshold) {
    qsort2 (pivotIndex+1, right);
  } else {
    // complete in separate thread
    helpRequested = true;
  
    new Thread () {
      public void run () {
        qsort2 (pivotIndex+1, right);
        helpRequested = false;
       }
    }.start();
  }
}	
 <br>
</pre> 
               <b>Fig. 7</b>: Multi-threaded 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in Java
               <p> </p>
               <p>The code properly works since only the primary thread reads the <code>helpRequested</code> variable or sets it to <b>true</b>, while the helper thread only resets the value of <code>helpRequested</code> back to <b>false</b>. It is true that certain timing considerations could cause the primary thread to miss an opportunity to launch the helper thread (because <code>qsort2</code> could have completed and the thread may not have yet reset <code>helpRequested</code>). However, such a situation will not lead to either deadlock or livelock, so we can safely use this simpler implementation. When we execute this code on the same Unix machine as earlier, we witness similar performance trends.</p>
               <p></p> 
               <p>If we wish to use additional helper threads, we have to change the underlying solution we have shown for both C and Java. The next section shows our solution using Java.</p> 
               <p><strong><a name="gen"></a>How to generalize such a solution to support an arbitrary number of helper threads.</strong></p>
               <p></p> 
               <p>The code from <b>Fig. 7</b> cannot easily be extended to multiple threads because we need to add bookkeeping to remember which threads are executing, and we have to avoid spawning either too many threads or deadlocking. The <code>algs.model.multithread.array.QuickSort</code> implementation in this month's blog code base shows how this works.</p>
               <p></p> 
               <p>The primary change is that we introduce an integer variable, <code>helpersWorking</code> which records the number of active helper threads working. Because multiple threads must access this variable we use a <i>mutex object</i>, which ensures mutually-exclusive access to this shared variable. <b>Fig. 8</b> shows the <code>qsort2</code> implementation.</p> 
               <pre>
/**
 * Multi-threaded quicksort method entry point.
 * Both left and right and bounded by [0, ar.length).
 * @param left     The left-bounds within which to sort 
 * @param right    The right-bounds within which to sort 
 */
private void qsort2 (final int left, final int right) {
  if (right &lt;= left) { return; }
   
  // partition
  int p = pi.selectPivotIndex (ar, left, right);
  final int pivotIndex = partition (left, right, p);
  
  // are all helper threads working OR is problem too big? 
  // Continue with recursion if so.
  int n = pivotIndex - left;
  if (helpersWorking == numThreads || n &gt;= threshold) {
    qsort2 (left, pivotIndex-1);
  } else {
    // otherwise, complete in separate thread
    synchronized(helpRequestedMutex) {
      helpersWorking++;
    }
			
    new Thread () {
      public void run () {
        // invoke single-thread qsort
        qsortN (left, pivotIndex - 1);
        synchronized(helpRequestedMutex) {
           helpersWorking--;
        }
      }
    }.start();
  }
   
  // are all helper threads working OR is problem too big? 
  // Continue with recursion if so.
  n = right - pivotIndex;
  if (helpersWorking == numThreads || n &gt;= threshold) {
    qsort2 (pivotIndex+1, right);
  } else {
    // otherwise, complete in separate thread
    synchronized(helpRequestedMutex) {
      helpersWorking++;
    }
  	
    new Thread () {
      public void run () {
        // invoke single-thread qsort
        qsortN (pivotIndex+1, right);
        synchronized(helpRequestedMutex) {
          helpersWorking--;
        }
      }
    }.start();
  }
}
 <br>
</pre> 
               <b>Fig. 8</b>: Multi-threaded 
               <span style="font-variant: small-caps;">QuickSort</span> implementation in Java with multiple helper threads
               <p> </p>
               <p>Whenever a thread is spawned, the <code>helpersWorking</code> variable is incremented, and the thread itself will decrement this same value upon completion. Using the mutex variable, <code>helpRequestedMutex</code> and the ability in Java to <b>synchronize</b> a block of code for exclusive access, this implementation safely updates the <code>helpersWorking</code> variable. As with our original C implementation with a single helper, <code>qsort2</code> invokes the single-threaded <code>qsortN</code> method within its helper threads. This ensures that only the primary thread is responsible for spawning new threads of computation.</p>
               <p></p> 
               <p>For this design, why is it so important to prevent helper threads from spawning new helper threads? Should this be allowed to happen, then the "first" helper thread would have to synchronize with these "second" threads so the "second" threads would only begin to execute after the "first" helper thread had properly partitioned the array. Implementing this logic will prove challenging.</p>
               <p></p> 
               <p>Let's now consider how well this multi-helper thread solution works when compared to the earlier single-helper thread solution. In order to compare like-minded executions with each other, the following graphs compare the Java single-helper solution against the Java multi-helper solution. Also the <span style="font-variant: small-caps;">QuickSort</span> algorithms are going to be sorting random floating point numbers from the range [0, 1]. We have several parameters that we consider:</p> 
               <ul> 
                <li>Size N of the array being sorted: This falls in range {65,536 to 1,048,576} </li>
                <li>Ratio threshold N/R below which a helper thread computes a sub-problem. We experimented with values of R in the range {1 to 20} and also MAXINT. </li>
                <li>Number of helper threads available: we experimented with 1 to 9 helper threads </li>
                <li>Partition method to use: we tried both "select a random element" and "select the rightmost element". </li> 
               </ul> 
               <p>The parameter space thus amounts to 1,890 unique combination of these parameters. The <code>MultiThreadDriver</code> Java file contains the code to generate results for these experiments. For convenience, we include an Excel spreadsheet file <code>ComputationResults.xls</code> within this month's blog entry.</p>
               <p></p> 
               <p>In all of the ensuing graphs, we use the "select rightmost element" as the partition algorithm. In general, we have found there is a noticeable performance slowdown of about 5% in using the random number generator across all experiments.</p>
               <p></p> 
               <p>If R=1, then the algorithm chooses to initiate a helper thread whenever it can. The graph in <b>Fig. 9</b> shows there is a speedup factor of 1.61 for N=1,048,576 when there may be one helper thread. However, for all values of N, adding more threads actually worsens the situation. Thus with up to 9 helper threads for N=1,048,576 the improvement converges on an improvement of about 1.49.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="multiThread_R=1_Tvaries.PNG" src="http://broadcast.oreilly.com/Aian/multiThread_R%3D1_Tvaries.PNG" width="460" height="313" class="mt-image-none" style=""></span><br> <b>Fig. 9</b>: Multi-threaded <span style="font-variant: small-caps;">QuickSort</span> : R=1 and up to 9 helper threads.</p>
               <p></p> 
               <p>Now consider the "sweet spot" we had identified earlier, namely for R=4. The execution performance is graphed in <b>Fig. 10</b>. The results are quite favorable. For N=1,048,576 one sees continuous improvement, converging on a final speedup factor of 2.3. Thus using threads judiciously has cut the performance time of <span style="font-variant: small-caps;">QuickSort</span> by more than half.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="multiThread_R=4_Tvaries.PNG" src="http://broadcast.oreilly.com/Aian/multiThread_R%3D4_Tvaries.PNG" width="460" height="313" class="mt-image-none" style=""></span><br> <b>Fig. 10</b>: Multi-threaded <span style="font-variant: small-caps;">QuickSort</span> : R=4 and up to 9 helper threads.</p>
               <p></p> 
               <p>Research in speedup factors for parallel algorithms shows there are inherent limitations to how much extra threading or extra processing will actually help a specific algorithmic implementation. Under these restrictions, I feel quite satisfied in producing a multi-threaded <span style="font-variant: small-caps;">QuickSort</span> implementation that achieved a speedup factor greater than 2. The primary reason we were able to achieve this speedup is that the individual subproblems of recursive <span style="font-variant: small-caps;">QuickSort</span> are entirely independent, and there will be no contention for shared resources by the multiple threads. If other problems share this same characteristic, then they too should be able to benefit from our multi-threaded approach. We do not have far to look to find a candidate problem.</p> 
               <p><strong><a name="MTCH"></a>Multi-threaded <span style="font-variant: small-caps;">ConvexHull</span> in Java with a single helper thread</strong></p>
               <p></p> 
               <p>Given a set of two-dimensional points P in the Cartesian plane, the <i>convex hull</i> is the smallest convex shape that fully encloses all points in P. <b>Fig. 11</b> shows the computed convex hull for a small sample points set. One can verify that a point <b>x</b> should <b>not</b> belong on the convex hull by simply finding three points in P that form a triangle that contains <b>x</b>. For example, the point <b>6</b> can be eliminated since it is enclosed within the triangle formed by points <b>4</b>, <b>5</b> and <b>7</b>. The convex hull is the clockwise ordering of points labeled <b>L0</b> through <b>L7</b>.</p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="convexHull.PNG" src="http://broadcast.oreilly.com/Aian/convexHull.PNG" width="247" height="202" class="mt-image-none" style=""></span><br> <b>Fig. 11</b>: Computed Convex Hull for a sample of points.</p>
               <p></p> 
               <p>Using a brute force approach, one can generate all possible triangles from the set P and eliminate all points from P that fall within a triangle. As shown in our book, such a brute force algorithm exhibits O(n<sup>4</sup>) performance. Surely we can do better than this!</p>
               <p></p> 
               <p>The implementation of the <span style="font-variant: small-caps;">Convex Hull Scan</span> algorithm is listed in <b>Fig. 12</b>.</p> 
               <pre>
/**
 * Use Andrew's algorithm to return the computed convex hull for 
 * the input set of points.
 * 
 * Points array must have at least three points to be meaningful. 
 * If it does not, then the sorted array is returned as the "hull".
 * 
 * This algorithm will still work if duplicate points are found in
 * the input set of points.
 *
 * @param points     a set of (n ? 3) two dimensional points.
 */
public IPoint[] compute (IPoint[] points) {
  // sort by x-coordinate (and if ==, by y-coordinate). 
  int n = points.length;
  new HeapSort
                <ipoint>
                 ().sort(points, 0, n-1, IPoint.xy_sorter);
  if (n &lt; 3) { return points; }
	
  // Compute upper hull by starting with leftmost two points
  PartialHull upper = new PartialHull(points[0], points[1]);
  for (int i = 2; i &lt; n; i++) {
    upper.add(points[i]);
    while (upper.hasThree() &amp;&amp; upper.areLastThreeNonRight()) {
      upper.removeMiddleOfLastThree();
    }
  }
   
  // Compute lower hull by starting with rightmost two points
  PartialHull lower = new PartialHull(points[n-1], points[n-2]);
  for (int i = n-3; i &gt;=0; i--) {
    lower.add(points[i]);
    while (lower.hasThree() &amp;&amp; lower.areLastThreeNonRight()) {
      lower.removeMiddleOfLastThree();
    }
  }
  
  // remove duplicate end points when combining.
  IPoint[] hull = new IPoint[upper.size()+lower.size()-2];
  System.arraycopy(upper.getPoints(), 
     0, hull, 0, upper.size());
  System.arraycopy(lower.getPoints(), 
     1, hull, upper.size(), lower.size()-2);
  
  return hull;
}
 
                 <br>

                </ipoint></pre> 
               <b>Fig. 12</b>: Implementation of Convex Hull Scan
               <p> </p>
               <p>The key idea of this algorithm is to break the problem into two: Compute the upper partial hull and then the lower partial hull. Once these are computed, they are fused together to form the actual convex hull. This algorithm first sorts the points by x-coordinate from left to right (breaking ties using the y-coordinate). It then "walks" through the points from left to right to form the upper hull and then walks again through the points from right to left to form the lower hull. One can readily see that these two partial hulls can be computed at the same time since they are independent problems. </p>
               <p></p> 
               <p>The two inefficiencies in this implementation (which we will call the ADK implementation) are: (1) the use of <span style="font-variant: small-caps;">HeapSort</span> where <span style="font-variant: small-caps;">QuickSort</span> would be noticeably faster; and (2) the waste of the invocations to getPoints() of the partially computed hulls. If you review the code, you will see that this method creates and populates an array of points which represents the partial hull, only to simply copy this array into the computed solution, <code>hull</code>. We will address both of these inefficiencies even as we work to involve multiple helper threads into the implementation.</p>
               <p></p> 
               <p>Note that we can only use multiple threads once the initial points are sorted, and we must synchronize and wait for both threads to complete before we fuse the two partial results together again. The code to complete this task is shown in <b>Fig. 13</b>.</p>
               <p></p> 
               <p>In our original ConvexHullScan implementation we used a <span style="font-variant: small-caps;">HeapSort</span> algorithm to sort the array of points. The code in this month's blog now uses a multi-threaded Quick Sort implementation where the elements being sorted are two-dimensional points in the Cartesian plane. We have to create a new class to handle situations where the elements being sorted do not automatically provide a comparable method to compare to elements. You can review the <code>QuickSortExternal</code> class to see how this is done. For the implementation shown below, we choose to use <span style="font-variant: small-caps;">QuickSort</span> using our favorite threshold ratio of 4, with a number of helper threads.</p>
               <p></p> 
               <pre>
public IPoint[] compute (final IPoint[] points) {
    // sort by x-coordinate (and if ==, by y-coordinate). 
    final int n = points.length;
    
    // sort with available threads, using R=4 sweet spot.
    QuickSortExternal
                <ipoint>
                  qs = 
      new QuickSortExternal
                 <ipoint>
                  (points, IPoint.xy_sorter); qs.setPivotMethod(qs.lastSelector()); qs.setNumberHelperThreads(numThreads); qs.setThresholdRatio(4); // trivial cases can return now. if (n &lt; 3) { return points; } // from this point on, we only use two threads. final PartialHull upper =new PartialHull(points[0],points[1]); final PartialHull lower =new PartialHull(points[n-1],points[n-2]); Thread up = new Thread() { public void run() { // Compute upper hull by starting with leftmost two points for (int i = 2; i &lt; n; i++) { upper.add(points[i]); while (upper.hasThree() &amp;&amp; upper.areLastThreeNonRight()) { upper.removeMiddleOfLastThree(); } } } }; Thread down = new Thread() { public void run() { // Compute lower hull by starting with rightmost two points for (int i = n-3; i &gt;=0; i--) { lower.add(points[i]); while (lower.hasThree() &amp;&amp; lower.areLastThreeNonRight()) { lower.removeMiddleOfLastThree(); } } } }; // start both threads and wait until both are done. up.start(); down.start(); try { up.join(); down.join(); } catch (InterruptedException ie) { System.err.println("Multithreaded execution interrupted."); } // remove duplicate end points when combining. Transcribe the // partial hulls into the array return value. IPoint[] hull = new IPoint[upper.size()+lower.size()-2]; int num = upper.transcribe (hull, 0); lower.transcribe (hull, num-1, lower.size() - 2); return hull; } 
                  <br> 
                 </ipoint>
                </ipoint></pre> 
               <b>Fig. 13</b>: Multi-threaded implementation of Convex Hull Scan
               <p> </p>
               <p>As you can see in the <b>Fig. 13</b>, we are restricted to using only two threads for constructing the two partial hulls, even though we may have used a larger number of threads during the <span style="font-variant: small-caps;">QuickSort</span> phase of the algorithm. At the end of this method, we avoid the wasteful allocation of unneeded arrays by modifying the <code>PartialHull</code> class (included just within this month's blog code) which simply transcribes into the <code>hull</code> solution the points from the partial hulls.</p>
               <p></p> 
               <p>As shown in the following graphs, we indeed witness a speedup; adding a large number of helper threads only helps the sorting step of the algorithm, however, since the problem can only be subdivided into two concurrently executing sub-tasks. However, the speedup is substantial; recall we replaced the use of <span style="font-variant: small-caps;">HeapSort</span> by using <span style="font-variant: small-caps;">QuickSort</span> (this alone should introduce a speedup factor of about 2 given the performance benefit of <span style="font-variant: small-caps;">QuickSort</span> over <span style="font-variant: small-caps;">HeapSort</span>); but this alone is not enough to account for the truly noticeable speedup shown in <b>Table 2</b>. Clearly the use of multiple threads for this algorithm has a noticeable and great speedup.</p> 
               <table cellpadding="3" cellspacing="3" border="2" style="border-collapse: collapse" id="diffTableID2"> 
                <tbody>
                 <tr>
                  <td><em>n</em></td>
                  <td>Speedup of one-helper thread to no thread</td>
                 </tr> 
                 <tr>
                  <td>65,536</td>
                  <td>6.41</td>
                 </tr> 
                 <tr>
                  <td>131,072</td>
                  <td>8.66</td>
                 </tr> 
                 <tr>
                  <td>262,144</td>
                  <td>9.93 </td>
                 </tr> 
                 <tr>
                  <td>524,288</td>
                  <td>11.07</td>
                 </tr> 
                 <tr>
                  <td>1,048,576</td>
                  <td>12.35 </td>
                 </tr> 
                </tbody>
               </table> 
               <a name="diffTable2"></a>
               <b>Table 2: </b>Speedup for Multi-thread ConvexHull with QuickSort over implementation of convex hull in the ADK.
               <p> </p>
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="multiThread_ConvexHull.PNG" src="http://broadcast.oreilly.com/Aian/multiThread_ConvexHull.PNG" width="460" height="314" class="mt-image-none" style=""></span><br> <b>Fig. 14</b>: Multi-threaded performance of Akl-Toussaint heuristic.</p>
               <p></p> 
               <p>We also include a multi-threaded implementation of the Akl-Toussaint heuristic, which pre-processes the initial set of points to eliminate from contention those points which are contained within the extreme quadrilateral formed by the extreme left, right, top and bottom points of this set. In our multi-threaded implementation, we use just two separate threads, each processing half of the points; during testing, we found that the increased communication and programming burden of trying to use more than two threads is just not worthwhile. Naturally, then, the resulting speedup of about 2.58 is the best we were able to achieve.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="multiThread_Akl_Toussaint.PNG" src="http://broadcast.oreilly.com/Aian/multiThread_Akl_Toussaint.PNG" width="459" height="311" class="mt-image-none" style=""></span><br> <b>Fig. 15</b>: Multi-threaded performance of Akl-Toussaint heuristic.</p>
               <p></p> 
               <p>We should be excited that we were able to rather easily double the performance of two sample algorithms. Because threading appears to be so powerful, it is important to identify situations where the use of multiple threads is exactly the wrong approach to take.</p>
               <p></p> 
               <p><strong><a name="MTNN"></a>An example of when threading does not help: Multi-threaded Nearest-Neighbor</strong></p>
               <p></p> 
               <p>In the nearest neighbor problem in which you are given a set of points P in a d-dimensional plane and you must answer queries of the form "what point in P is closest to point <b>x</b> using Euclidean distance?" A brute force algorithm simply scans all <i>n</i> points in P and finds the closest one to <b>x</b>. Perhaps we can achieve arbitrary improvements in speedup simply by throwing more threads at the brute force solution. Unfortunately, the performance experiment shown in <b>Fig. 16</b> tells another tale. For small values of N (such as 512) with up to eight helper threads, the multi-threaded version is about 45 times <b>slower</b> than the single-threaded version. Only when there are 32,768 points does the multi-threaded implementation out-perform its single-threaded counterpart, but this benefit doesn't last long. As you can see, the benefit lasts only with a high number of dimensions, and even then the speedup plateaus at about 1.2 regardless of how many threads are used. Only with 262,144 points are we able to achieve a consistent speedup of between 1.3 and 1.9. Clearly, simply throwing eight threads at the problem will not make this problem eight times faster.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="SpeedUp_BruteForce.PNG" src="http://broadcast.oreilly.com/Aian/SpeedUp_BruteForce.PNG" width="412" height="286" class="mt-image-none" style=""></span><br> <b>Fig. 16</b>: Multi-threaded performance of Nearest Neighbor brute force algorithm.</p>
               <p></p> 
               <p>Why does this problem not benefit from multiple threads? The essential difference is that the sub-problems computed by the multiple threads are not independent. Each of K threads is given an N/K subset of the initial N points and computes the nearest point from within that subset. Once this computation is complete, the smallest distance of these K computed points must then be computed. The details of the implementation are shown in <b>Fig. 17</b>.</p> 
               <pre>
public IMultiPoint nearest (IMultiPoint x) {
  final double[] xraw = x.raw();
  
  // start thread for each subset
  BruteForceThread[] threads=new BruteForceThread[numThreads];
  int size= points.length/numThreads;
  int offset = 0;
  
  for (int t = 0; t &lt; threads.length - 1; t++) {
    threads[t] = new BruteForceThread(points, xraw, offset, size);
    threads[t].start();
    offset += size;
  }
  
  // remainder computed specially.
  threads [threads.length-1] = 
    new BruteForceThread(points, xraw, offset, points.length-offset);
  threads [threads.length-1].start();
		
  // wait until all done, and compute min along the way
  double minValue = Double.MAX_VALUE;
  int bestIndex = -1;
  for (int t = 0; t &lt; threads.length; t++) {
    try {
      threads [t].join();
    } catch (InterruptedException e) {
	System.err.println ("Multi Thread Brute Force interrupted.");
    }
  
    if (threads[t].best &lt; minValue) {
      minValue = threads[t].best;
      bestIndex = threads[t].bestIndex;
    }
  }
  
  return results[bestIndex];
}
 <br>
</pre> 
               <b>Fig. 17</b>: Multi-threaded implementation of Nearest Neighbor brute force algorithm.
               <p> </p>
               <p>Starting the threads is not the problem; each <code>BruteForceThread</code> takes the information and processes different subset of points to locate the best point (i.e., the one closest to the target search point). The problem arises in processing the results of these threads, since they must all complete before we can compare the different results. The code fragment from <b>Fig. 17</b> chooses to wait for each thread, in order, until all threads are processed and the shortest result has been found. This situation creates a bottleneck which prevents the speedup from achieving its theoretic maximum.</p>
               <p></p> 
               <p>As shown in Chapter 9, an alternative algorithm requires only O(log n) time if a <i>kd-tree</i> (see pp. 280-282 of our book) is constructed from the initial points. The pseudo-code for this algorithm is shown in <b>Fig. 18</b>.</p> 
               <pre>
nearest (T, x)
  n = find parent node where x would have been inserted
  min = distance from x to n.point
  better = nearest (T.root, min, x)
  <strong>if </strong>(better found) { <strong>return </strong>better } <strong>else </strong>{ <strong>return </strong>n.point }
<strong>end</strong>
  
nearest (node, min, x)
  d = distance from x to node.point
  <strong>if </strong>(d &lt; min) <strong>then </strong>
    min = d; result = node.point
  dp = perpendicular distance to node
  <strong>if </strong>(dp &lt; min) <strong>then</strong>
    // note two recursive invocations which could be parallelized
    pt = nearest (node.above, min, x)
    <strong>if </strong>(distance from pt to x &lt; min) <strong>then</strong>
      result = pt; min = distance from pt to x
    pt = nearest (node.below, min, x)
    <strong>if </strong>(distance from pt to x &lt; min) <strong>then</strong>
      result = pt; min = distance from pt to x
  <strong>else</strong>
    // note just a single recursive invocation here
    <strong>if </strong>(node is above x) <strong>then</strong>
      pt = nearest (node.above, min, x)
    <strong>else</strong>
      pt = nearest (node.below, min, x)
    <strong>if </strong>(pt exists) <strong>then return </strong>pt
  <strong>return </strong>result
<strong>end</strong>
 <br>
</pre> 
               <b>Fig. 18</b>: Pseudo-code for Nearest Neighbor queries
               <p> </p>
               <p>This recursive function, at times, invokes two recursive calls (when the computed perpendicular distance to the node is less than the current minimum value). Couldn't these two sub-task invocations be executed in parallel to improve performance? It turns out there are two reasons that prevent such a strategy from being helpful. First, these two tasks will compute two nearest neighbor results from which the actual nearest must be chosen; this bottleneck is the same as the one that appears in <b>Fig. 17</b>. Second, when do we use the helper threads? When the problem size is "small enough" as we did with <span style="font-variant: small-caps;">QuickSort</span>? Judging the size of a problem is difficult without adding extra state and computation to the problem. After extensive testing we found the only situation where there was an improved speedup was when a single helper thread is used only the very first time that the double recursive invocation occurs; when it occurs, thereafter only the single-thread solution is attempted. In the graphs below, we show the performance for N=4,096 and N=262,144 over a number of dimensions. In the graphs shown in <b>Fig. 19</b>, we compare the performance times of single-threaded KD-tree nearest neighbor vs. the one-helper thread KD-tree nearest neighbor. We also record the amount of time that we spend actually waiting for threads to complete execution. For data sets higher than 14 dimensions (N=4,096) or 13 dimensions (N=262,144) the one-helper threaded implementation finally outperforms its single-threaded counterpart for a speed up of about 1.35 (or 1.55 for N=262,144). It is interesting to note that the computed waiting time forms an increasingly large percentage of the total time as both the number of points and dimensions increases.</p>
               <p></p> 
               <p>The code for the multi-threaded implementation is a bit too long to provide "as is" within this blog, so I would ask you to look at the code in both packages <code>algs.model.multithread.nearestNeighbor.onehelper</code> and <code>algs.model.multithread.nearestNeighbor.smallhelpers</code>.</p>
               <p></p> 
               <p><span class="mt-enclosure mt-enclosure-image" style="display: inline;"><img alt="SpeedUp_KDTree.PNG" src="http://broadcast.oreilly.com/Aian/SpeedUp_KDTree.PNG" width="465" height="310" class="mt-image-none" style=""></span><br> <b>Fig. 19</b>: Comparing multi-threaded Nearest Neighbor (PKD) with single-threaded (KD).</p>
               <p></p> 
               <p><strong><a name="MTLL"></a>Lessons Learned</strong></p>
               <p></p> 
               <p>Using multiple threads to improve the performance of single-threaded algorithms is challenging. One must pay careful attention that the semantic meaning of the multiple-threaded implementation has not changed; at the same time, one must strive to avoid deadlock. In general, I would stress the following points:</p>
               <p></p> 
               <ul> 
                <li>Only truly independent sub-problems should be solved by separate threads</li> 
                <li>Most serial algorithms cannot achieve theoretic maximal speedup because only part of the algorithm can be parallelized among multiple threads</li> 
                <li>Don't try to find solutions with as many threads as possible. In many cases, the best empirical results I had were with one helper thread, and this held true on laptops with dual-core chips and Linux boxes with multiple dual-core chips </li>
               </ul> 
               <p>Ok, so this blog contained a lot of material, which just goes to show how interesting these algorithms are! Full details of all Java classes and C functions are found in the code.zip repository associated with this Blog.</p>
               <p></p> 
               <p><strong><a name="NextColumn"></a>Next Column</strong></p>
               <p></p> 
               <p>In next Month's June column, we will investigate the <span style="font-variant: small-caps;">QuickHull</span> sorting algorithm which did not make it into the actual book itself. Until next time, we hope you take the opportunity to investigate the numerous algorithms in the Algorithms in a Nutshell book as well as to explore the examples provided in the ADK.</p> 
               <p><a href="http://oreilly.com/catalog/9780596516246/">Algorithms in a Nutshell</a><br> George T. Heineman, Gary Pollice, Stanley Selkow<br> </p> 
               <!-- RSPEAK_STOP --> 
              </div> 
              <br clear="left">
              <div class="asset-footer"> 
               <div class="entry-tags"> 
                <h4 class="entry-tags-header">Tags<span class="delimiter">:</span></h4> 
                <ul class="entry-tags-list"> 
                 <li class="entry-tag"><a href="http://oreilly.com/blogs/tags.csp?tag=algorithms" rel="tag">algorithms</a></li> 
                </ul> 
               </div> 
               <br> 
              </div> 
             </div> 
            </div> 
            <div style="width: 100%; margin-right: 0px; margin-left: 0px; padding-right: 0px; padding-left: 0px;">
             <h3>You might also be interested in:</h3> 
             <div style="width: 100%; margin-right: 0px; margin-left: 0px; padding-right: 0px; padding-left: 0px;"> 
              <!-- MyBuys Web Recommendation Zone --> 
              <div mybuyszone="4"></div> 
              <!-- End MyBuys Web Recommendation Zone --> 
             </div> 
            </div> 
            <div class="linebreak"> 
             <div class="noindex"> 
              <div id="comments" class="comments"> 
               <h2 class="comments-header">2 Comments</h2> 
               <div class="comments-content"> 
                <!-- If comment doesn't have a top-level-parent --> 
                <div id="comment-2213984" class="comment"> 
                 <div class="inner"> 
                  <div class="comment-header"> 
                   <div class="asset-meta"> 
                    <span class="byline"> By <span class="vcard author">Anonymous Coward</span> on <a href="http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html#comment-2213984"><abbr class="published" title="2009-12-05T09:07:08-08:00">December 5, 2009 9:07 AM</abbr></a> </span> 
                   </div> 
                  </div> 
                  <div class="comment-content"> 
                   <p>In your Java quicksort I do really fail to see what would guarantee that swap made by spawned threads are visible to someone launching the quicksort.</p> 
                   <p>For example, say at the beginning we have: 8,7,6,5,4,3,2,1</p> 
                   <p>First thread swaps to 4,3,2,1,8,7,6,5 and spawns to threads. Those two threads shall correctly see, respectively, 4,3,2,1 and 8,7,6,5.</p> 
                   <p>But there are zero guarantee that any change made by these two spawned threads shall be visible by an observer as far as I understand the Java memory model and your code.</p> 
                   <p>The only way to make it work would be to use AtomicReferenceArray and not []. But the trials/examples I see are using [].</p> 
                   <p>It may work on some VM but it's not guaranteed to work. I don't see/understand how the synchronization on the [] is done.</p> 
                  </div> 
                 </div> 
                </div> 
                <!-- If comment doesn't have a top-level-parent --> 
                <div id="comment-2567074" class="comment"> 
                 <div class="inner"> 
                  <div class="comment-header"> 
                   <div class="asset-meta"> 
                    <span class="byline"> By <span class="vcard author">big bad bombastic bob</span> on <a href="http://broadcast.oreilly.com/2009/06/may-column-multithreaded-algor.html#comment-2567074"><abbr class="published" title="2010-06-04T01:36:23-08:00">June 4, 2010 1:36 AM</abbr></a> </span> 
                   </div> 
                  </div> 
                  <div class="comment-content"> 
                   <p>nice example. With multi-core machines you NEED threaded solutions to take advantage of the extra horsepower. I've recently done something similar (an 'N thread' solution) using "work units". Surfing for other multi-thread quicksort solutions led me here. Distributed calculations like 'dnetc' and 'seti@home' use work units also, and it seems to be an effective way of scheduling and NOT deadlocking. Waiting for a work unit you can always do another work unit (and in fact my algorithm does this). On a quad-core machine with 4 worker threads you would expect to see about 1/3 execution time over single-thread, primarily because of the single-threaded 'partition()' process. A DFT or FFT is also a good candidate for threading.</p> 
                  </div> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
          <div id="beta"> 
           <div id="beta-inner"> 
            <div class="widget-left"> 
             <h3>News Topics</h3> 
             <div id="default-cloud" class="widget-cloud"> 
              <iframe src="http://www.oreillynet.com/oreilly/orn/newstagcloud.csp" name="related" width="174" height="300" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> 
             </div> 
            </div> 
           </div> 
          </div> 
          <div id="gamma"> 
           <div id="gamma-inner"> 
            <div class="noindex">
             <div class="widget-right" style="margin-right: 0px; margin-left: 0px; padding-right: 0px; padding-left: 0px;">
              <h3>Recommended for You</h3> 
              <div class="widget-content" style="margin-right: 0px; margin-left: 0px; padding-right: 0px; padding-left: 0px;"> 
               <!-- MyBuys Web Recommendation Zone --> 
               <div mybuyszone="3"></div> 
               <!-- End MyBuys Web Recommendation Zone --> 
              </div> 
             </div>
             <div class="widget-right"> 
              <h3>Got a Question?</h3> 
              <div class="widget-content"> 
               <div id="gsfn_list_widget"> 
                <div class="sidebar-item-content">
                 <img src="http://oreilly.com/images/oreilly/satisfaction-icons.gif">
                 <br> 
                 <div class="gsfn_content"> 
                  <form id="gsfn_search_form" action="http://getsatisfaction.com/oreilly" method="get" accept-charset="utf-8" onsubmit="gsfn_search(this); return false;"> 
                   <input type="hidden" name="widget" value=""> 
                   <input type="hidden" name="limit" value="3"> 
                   <input type="hidden" name="style" value=""> 
                   <input type="hidden" name="callback" value="gsfnResultsCallback"> 
                   <input type="hidden" name="format" value="json"> 
                   <label for="gsfn_search_query" class="gsfn_label"> Do you have a question about <strong>O'Reilly's products and services</strong>? Share an idea! Report a problem...</label>
                   <br>
                   <br> 
                   <input type="text" size="16" name="query" value="" id="gsfn_search_query" maxlength="120" style="padding-bottom: 6px;">
                   <br> 
                   <input type="submit" id="continue" value="Continue"> 
                  </form> 
                  <div id="gsfn_search_results" style="height: auto;"></div> 
                 </div> 
                 <br> 
                 <a href="http://getsatisfaction.com/oreilly" class="widget_title">Active discussions:</a>
                 <br>
                 <br> 
                 <div id="gsfn_content">
                  Loading... 
                 </div> 
                 <div class="powered_by">
                  <a href="http://getsatisfaction.com/"><img alt="Favicon" src="http://www.getsatisfaction.com/favicon.gif" style="vertical-align: middle;"></a> 
                  <a href="http://getsatisfaction.com/">Service and support by Satisfaction</a>
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> &nbsp;
           </div> 
          </div> 
         </div> 
        </div> 
       </div></td>
     </tr>
     <tr valign="bottom"> 
      <td align="center" colspan="3" class="navfooterbg"> 
       <!--BottomNav Start--> 
       <table border="0" cellspacing="0" cellpadding="0" class="emailSignUpTable"> 
        <tbody>
         <tr> 
          <td style="width:516px;"> 
           <form method="POST" id="emailSignUp" action="http://post.oreilly.com/client/o/oreilly/forms/quicksignup.cgi"> 
            <table border="0" cellspacing="0" cellpadding="0" width="500"> 
             <tbody> 
              <tr> 
               <td width="275">
                <div style="padding-left: 12px;">
                 Sign up today to receive special discounts,
                 <br> product alerts, and news from O'Reilly.
                </div></td> 
               <td width="172"> <input type="hidden" name="client_token" value="oreilly"><input type="hidden" name="subscribe" value="optin"> <input type="hidden" name="success_url" value="http://oreilly.com/store/newsletter-thankyou.html"> <input type="hidden" name="error_url" value="http://oreilly.com/store/newsletter-signup-error.html"> <input type="hidden" name="news_oreilly" value="1"> <input type="text" name="email_addr" value="Enter Email" maxlength="100" size="12" class="NavSearchBottom"></td> 
               <td width="53"><input border="0" type="image" alt="Submit" src="https://ormstore-prod.oreilly.com/images/oreilly/en_us/global/globalnav/emailsignup_btn.gif" name="submit" value="submit"></td>
              </tr>
             </tbody>
            </table>
           </form> </td> 
          <td> <a href="http://oreilly.com/oreilly/privacy.html">Privacy Policy &gt;</a> <br> <a href="http://oreilly.com/pdf/sample-newsletter.pdf">View Sample Newsletter &gt;</a> </td> 
          <td style="text-align:right"> </td>
          <td style="text-align:right"> 
           <ul class="utility social"> 
            <li><a class="youtube" href="http://youtube.com/oreillymedia" target="_blank"><span class="hidden">YouTube</span></a></li> 
            <li><a class="facebook" href="http://www.facebook.com/OReilly" target="_blank"><span class="hidden">Facebook</span></a></li> 
            <li><a class="twitter" href="http://twitter.com/oreillymedia" target="_blank"><span class="hidden">Twitter</span></a></li> 
            <li><a class="rss" href="http://feeds.feedburner.com/oreilly/news" target="_blank"><span class="hidden">RSS</span></a></li> 
            <li><a class="all-rss" href="http://oreilly.com/feeds">View All RSS Feeds &gt;</a></li> 
           </ul> </td> 
         </tr>
        </tbody> 
       </table> 
       <div id="multiColumnFooter"> 
        <div id="footer-branding"> 
         <img src="https://ormstore-prod.oreilly.com/images/oreilly/en_us/global/globalnav/logo02.gif" alt="O'Reilly"> 
         <p class="copyright"> 2011, O'Reilly Media, Inc.</p> 
         <p><span class="phone-number">(707) 827-7019</span><span class="phone-number">(800) 889-8969</span></p> 
         <p class="trademarks">All trademarks and registered trademarks appearing on oreilly.com are the property of their respective owners.</p> 
        </div> 
        <div class="contentSectionBlock"> 
         <!-- style="width:25%;" --> 
         <div class="contentSectionContainer"> 
          <span id="footerColumn-1" class="contentSection"> <h3>About O'Reilly</h3> 
           <ul> 
            <li><a class="footer" href="http://oreilly.com/academic/">Academic Solutions</a></li> 
            <li><a class="footer" href="http://oreilly.com/jobs/">Jobs</a></li> 
            <li><a class="footer" href="http://oreilly.com/contact.html">Contacts</a></li> 
            <li><a class="footer" href="http://oreilly.com/about/">Corporate Information</a></li> 
            <li><a class="footer" href="http://press.oreilly.com/index.html">Press Room</a></li> 
            <li><a class="footer" href="http://oreilly.com/oreilly/privacy.csp">Privacy Policy</a></li> 
            <li><a class="footer" href="http://oreilly.com/terms/">Terms of Service</a></li> 
            <li><a class="footer" href="http://oreilly.com/oreilly/author/intro.csp">Writing for O'Reilly</a></li> 
           </ul> </span> 
         </div> 
         <!-- style="width:25%;" --> 
         <div class="contentSectionContainer"> 
          <span id="footerColumn-2" class="contentSection"> <h3>Community</h3> 
           <ul> 
            <li><a class="footer" href="http://oreilly.com/authors/">Authors</a></li> 
            <li><a class="footer" href="http://oreilly.com/community/">Community &amp; Featured Users</a></li> 
            <li><a class="footer" href="http://forums.oreilly.com/">Forums</a></li> 
            <li><a class="footer" href="https://members.oreilly.com/">Membership</a></li> 
            <li><a class="footer" href="http://elists.oreilly.com/">Newsletters</a></li> 
            <li><a class="footer" href="http://answers.oreilly.com/">O'Reilly Answers</a></li> 
            <li><a class="footer" href="http://oreilly.com/feeds/">RSS Feeds</a></li> 
            <li><a class="footer" href="http://ug.oreilly.com/">User Groups</a></li> 
           </ul> </span> 
         </div> 
         <!-- style="width:25%;" --> 
         <div class="contentSectionContainer"> 
          <span id="footerColumn-3" class="contentSection"> <h3>More O'Reilly Sites</h3> 
           <ul> 
            <li><a class="footer" href="http://igniteshow.com/">igniteshow.com</a></li> 
            <li><a class="footer" href="http://makerfaire.com/">makerfaire.com</a></li> 
            <li><a class="footer" href="http://makezine.com/">makezine.com</a></li> 
            <li><a class="footer" href="http://craftzine.com/">craftzine.com</a></li> 
            <li><a class="footer" href="http://labs.oreilly.com/">labs.oreilly.com</a></li> 
            <li><h2>Partner Sites</h2></li> 
            <li><a class="footer" href="https://www.x.com/community/ppx/devzone">PayPal Developer Zone</a></li> 
            <li><a class="footer" href="http://blogs.forbes.com/oreillymedia/">O'Reilly Insights on Forbes.com</a></li> 
           </ul> </span> 
         </div> 
         <!-- style="width:24%;" --> 
         <div class="contentSectionContainer"> 
          <span id="footerColumn-4" class="contentSection"> <h3>Shop O'Reilly</h3> 
           <ul> 
            <li><a class="footer" href="http://shop.oreilly.com/category/customer-service.do">Customer Service</a></li> 
            <li><a class="footer" href="http://shop.oreilly.com/category/customer-service.do">Contact Us</a></li> 
            <li><a class="footer" href="http://shop.oreilly.com/category/customer-service/shipping-information.do">Shipping Information</a></li> 
            <li><a class="footer" href="http://shop.oreilly.com/category/customer-service/ordering-payment.do">Ordering &amp; Payment</a></li> 
            <li><a class="footer" href="http://shop.oreilly.com/category/customer-service/oreilly-guarantee.do">The O'Reilly Guarantee</a></li> 
           </ul> </span> 
         </div> 
         <div style="clear:both;"></div> 
        </div> 
       </div> 
       <!--BottomNav End--> </td> 
     </tr> 
     <!-- Satisfaction Widget JS --> 
     <script src="http://1.static.getsatisfaction.com/oreilly/widgets/javascripts/1992/widgets.js" type="text/javascript"></script>
     <script src="http://getsatisfaction.com/oreilly/topics.json?callback=gsfnTopicsCallback&amp;length=0&amp;limit=3&amp;sort=recently_active" type="text/javascript"></script> 
     <!-- End Satisfaction Widget JS --> 
     <!-- MyBuys Page Parameters --> 
     <script type="text/javascript">
mybuys.setPageType("CONTENT_ITEM");
mybuys.set("categoryid","");
</script> 
     <!-- #MyBuys Page Parameters --> 
     <!-- analytics --> 
     <!-- Start Quantcast tag --> 
     <script type="text/javascript" src=" http://edge.quantserve.com/quant.js "></script> 
     <script type="text/javascript">_qoptions = { tags:"News" }; _qacct="p-20l78bOOCbhcg";quantserve();</script>  
     <!-- End Quantcast tag --> 
     <script type="text/javascript">

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-4591498-1']);
_gaq.push(['_setDomainName', 'oreilly.com']);
_gaq.push(['_addIgnoredRef', 'oreilly.com']);
_gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script> 
     <!-- #analytics --> 
     <script language="JavaScript" type="text/javascript">
var s_account="ororeilly,orglobal"  // change report suite ID accordingly
</script> 
     <!-- SiteCatalyst code version: H.20.3. Copyright 1997-2009 Omniture, Inc. More info available at http://www.omniture.com --> 
     <script language="JavaScript" type="text/javascript" src="http://assets.oreilly.com/js/s_code.js"></script> 
     <script language="JavaScript" type="text/javascript">
s.pageName="oreilly:broadcast:may column multi threaded algorithm implementations"
s.channel="oreilly"
s.prop1="oreilly:broadcast"
s.prop2="oreilly:broadcast:broadcast"
s.prop3="oreilly:broadcast:broadcast:broadcast"
s.prop4="article"
s.hier1="oreilly,broadcast,broadcast,broadcast"
s.prop5="may column multi threaded algorithm implementations"
s.prop6="BC37158" 
s.prop7="06/18/2009" // publish date
//s.prop15=""
//These props should be set when a blog/article is read, post or reply made. 
s.prop21="george t heineman" // author name
s.prop22="broadcast" // blog name
s.prop23="may column multi threaded algorithm implementations" // entry title
s.prop24="06/18/2009" // post date
//s.prop25="" // days since last post
s.prop26="wednesday" // day of week
/* Conversion Variables */
s.campaign=""
s.events=""

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)//--></script> 
     <!-- End SiteCatalyst code version: H.20.2. --> 
     <!-- MyBuys Page Initialization --> 
     <script type="text/javascript">
  mybuys.initPage();
</script> 
     <!-- #MyBuys Page Initialization --> 
     <!-- chartbeat --> 
     <script type="text/javascript">
var cbjspath = "static.chartbeat.com/js/chartbeat.js?uid=1632&domain=broadcast.oreilly.com";
var cbjsprotocol = (("https:" == document.location.protocol) ? "https://s3.amazonaws.com/" : "http://");
document.write(unescape("%3Cscript src='"+cbjsprotocol+cbjspath+"' type='text/javascript'%3E%3C/script%3E"))
</script> 
     <!-- #chartbeat --> 
     <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/yui/2.6.0/build/utilities/utilities.js"></script> 
     <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/yui/2.6.0/build/datasource/datasource-min.js"></script> 
     <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/yui/2.6.0/build/autocomplete/autocomplete-min.js"></script> 
     <script type="text/javascript" src="http://content.atomz.com/sp1003bcf0/publish/autocomplete_data.js?sp_js_cache_ver=3"></script>   
    </tbody>
   </table>   
  </div>
 </body>
</html>