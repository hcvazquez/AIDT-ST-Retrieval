<!doctype html>
<html lang="en">
 <head> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> 
  <meta charset="utf-8"> 
  <title>SQL, PL/SQL, and Java</title> 
  <meta name="generator" content="Oracle DARB XHTML converter - Version 4.5.1 Build 4"> 
  <meta name="dcterms.created" content="October 10, 2005 16:49:37"> 
  <meta name="robots" content="all"> 
  <meta name="dcterms.title" content="Database Concepts"> 
  <meta name="dcterms.identifier" content="B14220-02"> 
  <meta name="dcterms.isVersionOf" content="CNCPT"> 
  <link rel="Start" href="../../index.htm" title="Home" type="text/html"> 
  <link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html"> 
  <script type="application/javascript" src="../../dcommon/js/headfoot.js"></script> 
  <script type="application/javascript" src="../../nav/js/doccd.js"></script> 
  <link rel="Contents" href="toc.htm" title="Contents" type="text/html"> 
  <link rel="Index" href="index.htm" title="Index" type="text/html"> 
  <link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html"> 
  <link rel="Prev" href="integrat.htm" title="Previous" type="text/html"> 
  <link rel="Next" href="data_access.htm" title="Next" type="text/html"> 
  <link rel="alternate" href="../b14220.pdf" title="PDF version" type="application/pdf"> 
  <link rel="alternate" href="../B14220-02.epub" title="ePub version" type="application/epub+zip"> 
  <link rel="alternate" href="../B14220-02.mobi" title="Mobipocket version" type="application/x-mobipocket-ebook"> 
  <link rel="schema.dcterms" href="http://purl.org/dc/terms/"> 
  <link rel="stylesheet" href="../../dcommon/css/fusiondoc.css"> 
  <link rel="stylesheet" type="text/css" href="../../dcommon/css/header.css"> 
  <link rel="stylesheet" type="text/css" href="../../dcommon/css/footer.css"> 
  <link rel="stylesheet" type="text/css" href="../../dcommon/css/fonts.css"> 
  <link rel="stylesheet" href="../../dcommon/css/foundation.css"> 
  <link rel="stylesheet" href="../../dcommon/css/codemirror.css"> 
  <link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css"> 
  <link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css"> 
  <link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css"> 
  <link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css"> 
  <script type="application/javascript" src="../../dcommon/js/modernizr.js"></script> 
  <script type="application/javascript" src="../../dcommon/js/codemirror.js"></script> 
  <script type="application/javascript" src="../../dcommon/js/jquery.js"></script> 
  <script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script> 
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async></script> 
  <script type="application/javascript" src="../../dcommon/js/jqfns.js"></script> 
  <script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script> 
  <!-- Add fancyBox --> 
  <link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen"> 
  <script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script> 
  <!-- Optionally add helpers - button, thumbnail and/or media --> 
  <link rel="stylesheet" href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5" type="text/css" media="screen"> 
  <script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script> 
  <script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script> 
  <link rel="stylesheet" href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7" type="text/css" media="screen"> 
  <script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script> 
 </head> 
 <body> 
  <a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a> 
  <header>
   <!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>-->
  </header> 
  <div class="row" id="CONTENT"> 
   <div class="IND large-9 medium-8 columns" dir="ltr"> 
    <a id="BEGIN" name="BEGIN"></a> 
    <span id="PAGE" style="display:none;">31/36</span> 
    <!-- End Header -->
    <a id="g35564"></a>
    <a id="i15198"></a> 
    <h1 class="chapter"><span class="secnum">24</span> <a id="CNCPT015"></a>SQL, PL/SQL, and Java</h1> 
    <p>This chapter provides an overview of SQL, PL/SQL, and Java.</p> 
    <p>This chapter contains the following topics:</p> 
    <ul> 
     <li> <p><a href="#i1411">Overview of SQL</a></p> </li> 
     <li> <p><a href="#i24650">Overview of Procedural Languages</a></p> </li> 
    </ul> 
    <div class="infoboxnotealso"> 
     <p class="notep1">See Also:</p> 
     <ul> 
      <li> <p><a class="olink SQLRF" href="../b14200/toc.htm"><span class="italic">Oracle Database SQL Reference</span></a></p> </li> 
      <li> <p><a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a></p> </li> 
      <li> <p><a class="olink JJDEV" href="../../java.102/b14187/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a></p> </li> 
     </ul> 
    </div> 
    <a id="i1411"></a> 
    <div class="sect1">
     <a id="sthref3366"></a> 
     <h2 class="sect1"><a id="CNCPT116"></a>Overview of SQL</h2> 
     <p><a id="sthref3367"></a><a id="sthref3368"></a><a id="sthref3369"></a>SQL is a database access, nonprocedural language. Users describe in SQL what they want done, and the SQL language compiler automatically generates a procedure to navigate the database and perform the desired task.</p> 
     <p><a id="sthref3370"></a>IBM Research developed and defined SQL, and ANSI/ISO has refined SQL as the standard language for relational database management systems.The minimal conformance level for SQL-99 is known as Core. Core SQL-99 is a superset of SQL-92 Entry Level specification. Oracle Database is broadly compatible with the SQL-99 Core specification.</p> 
     <p><a id="sthref3371"></a><a id="sthref3372"></a><a id="sthref3373"></a>Oracle SQL includes many extensions to the ANSI/ISO standard SQL language, and Oracle tools and applications provide additional statements. The Oracle tools SQL*Plus and Oracle Enterprise Manager let you run any ANSI/ISO standard SQL statement against an Oracle database, as well as additional statements or functions that are available for those tools.</p> 
     <p>Although some Oracle tools and applications simplify or mask SQL use, all database operations are performed using SQL. Any other data access method circumvents the security built into Oracle and potentially compromise data security and integrity.</p> 
     <div class="infoboxnotealso"> 
      <p class="notep1">See Also:</p> 
      <ul> 
       <li> <p><a class="olink SQLRF" href="../b14200/toc.htm"><span class="italic">Oracle Database SQL Reference</span></a> for detailed information about SQL statements and other parts of SQL (such as operators, functions, and format models)</p> </li> 
       <li> <p><a class="olink OEMCN" href="../../em.102/b31949/toc.htm"><span class="italic">Oracle Enterprise Manager Concepts</span></a></p> </li> 
       <li> <p><a class="olink SQPUG" href="../b14357/toc.htm"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for SQL*Plus statements, including their distinction from SQL statements</p> </li> 
      </ul> 
     </div> 
     <a id="i1225"></a> 
     <div class="sect2">
      <a id="sthref3374"></a> 
      <h3 class="sect2">SQL Statements</h3> 
      <p><a id="sthref3375"></a><a id="sthref3376"></a><a id="sthref3377"></a>All operations performed on the information in an Oracle database are run using SQL <span class="bold">statements</span>. A statement consists partially of SQL <span class="bold">reserved words</span>, which have special meaning in SQL and cannot be used for any other purpose. For example, <code>SELECT</code> and <code>UPDATE</code> are reserved words and cannot be used as table names.</p> 
      <p>A SQL statement is a computer program or instruction. The statement must be the equivalent of a complete SQL sentence, as in:</p> 
      <pre>
SELECT last_name, department_id FROM employees;

</pre> 
      <p>Only a complete SQL statement can be run. A fragment such as the following generates an error indicating that more text is required before a SQL statement can run:</p> 
      <pre>
SELECT last_name 

</pre> 
      <p><a id="sthref3378"></a><a id="sthref3379"></a>Oracle SQL statements are divided into the following categories:</p> 
      <ul> 
       <li> <p><a href="#i18503">Data Manipulation Language Statements</a></p> </li> 
       <li> <p><a href="#i18507">Data Definition Language Statements</a></p> </li> 
       <li> <p><a href="#i18511">Transaction Control Statements</a></p> </li> 
       <li> <p><a href="#i18515">Session Control Statements</a></p> </li> 
       <li> <p><a href="#i18519">System Control Statements</a></p> </li> 
       <li> <p><a href="#i18523">Embedded SQL Statements</a></p> </li> 
      </ul> 
      <div class="infoboxnotealso"> 
       <p class="notep1">See Also:</p> 
       <a href="triggers.htm#g22503">Chapter 22, "Triggers"</a> for more information about using SQL statements in PL/SQL program units
      </div> 
      <a id="i18503"></a> 
      <div class="sect3">
       <a id="sthref3380"></a> 
       <h4 class="sect3"><a id="CNCPT516"></a>Data Manipulation Language Statements</h4> 
       <p><a id="sthref3381"></a><a id="sthref3382"></a><a id="sthref3383"></a>Data manipulation language (DML) statements query or manipulate data in existing schema objects. They enable you to:</p> 
       <ul> 
        <li> <p><a id="sthref3384"></a>Retrieve data from one or more tables or views (<code>SELECT</code>); fetches can be scrollable (see <a href="#i14803">"Scrollable Cursors"</a>)</p> </li> 
        <li> <p><a id="sthref3385"></a>Add new rows of data into a table or view (<code>INSERT</code>)</p> </li> 
        <li> <p><a id="sthref3386"></a>Change column values in existing rows of a table or view (<code>UPDATE</code>)</p> </li> 
        <li> <p><a id="sthref3387"></a>Update or insert rows conditionally into a table or view (<code>MERGE</code>)</p> </li> 
        <li> <p><a id="sthref3388"></a>Remove rows from tables or views (<code>DELETE</code>)</p> </li> 
        <li> <p><a id="sthref3389"></a><a id="sthref3390"></a><a id="sthref3391"></a>See the execution plan for a SQL statement (<code>EXPLAIN</code> <code>PLAN</code>)</p> </li> 
        <li> <p><a id="sthref3392"></a>Lock a table or view, temporarily limiting other users' access (<code>LOCK</code> <code>TABLE</code>)</p> </li> 
       </ul> 
       <p>DML statements are the most frequently used SQL statements. Some examples of DML statements are:</p> 
       <pre>
SELECT last_name, manager_id, commission_pct + salary FROM employees; 

INSERT INTO employees VALUES 
    (1234, 'DAVIS', 'SALESMAN', 7698, '14-FEB-1988', 1600, 500, 30); 

DELETE FROM employees WHERE last_name IN ('WARD','JONES'); 
</pre> 
       <div class="sect4">
        <!-- infolevel="all" infotype="General" -->
        <a id="sthref3393"></a> 
        <h5 class="sect4">DML Error Logging</h5> 
        <p>When a DML statement encounters an error, the statement can continue processing while the error code and the associated error message text is logged to an error logging table. This is particularly helpful to long-running, bulk DML statements. After the DML operation completes, you can check the error logging table to correct rows with errors.</p> 
        <p>New syntax is added to the DML statements to provide the name of the error logging table, a statement tag, and a reject limit. The reject limit determines whether the statement should be aborted. For parallel DML operations, the reject limit is applied for each slave. The only values for the reject limit that are precisely enforced on parallel operations are zero and unlimited.</p> 
        <p>With data conversion errors, Oracle tries to provide a meaningful value to log for the column. For example, it could log the value of the first operand to the conversion operator that failed. If a value cannot be derived, then <code>NULL</code> is logged for the column.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <ul> 
          <li> <p><a class="olink ADMIN" href="../b14231/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on DML error logging</p> </li> 
          <li> <p><a class="olink DWHSG" href="../b14223/toc.htm"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for examples using DML error logging</p> </li> 
          <li> <p><a class="olink SQLRF" href="../b14200/toc.htm"><span class="italic">Oracle Database SQL Reference</span></a> for the syntax for DML error logging</p> </li> 
         </ul> 
        </div> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i18507"></a> 
      <div class="sect3">
       <a id="sthref3394"></a> 
       <h4 class="sect3">Data Definition Language Statements</h4> 
       <p><a id="sthref3395"></a><a id="sthref3396"></a>Data definition language (DDL) statements define, alter the structure of, and drop schema objects. DDL statements enable you to:</p> 
       <ul> 
        <li> <p><a id="sthref3397"></a><a id="sthref3398"></a><a id="sthref3399"></a>Create, alter, and drop schema objects and other database structures, including the database itself and database users (<code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>)</p> </li> 
        <li> <p><a id="sthref3400"></a>Change the names of schema objects (<code>RENAME</code>)</p> </li> 
        <li> <p><a id="sthref3401"></a>Delete all the data in schema objects without removing the objects' structure (<code>TRUNCATE</code>)</p> </li> 
        <li> <p><a id="sthref3402"></a><a id="sthref3403"></a>Grant and revoke privileges and roles (<code>GRANT</code>, <code>REVOKE</code>)</p> </li> 
        <li> <p><a id="sthref3404"></a><a id="sthref3405"></a>Turn auditing options on and off (<code>AUDIT</code>, <code>NOAUDIT</code>)</p> </li> 
        <li> <p><a id="sthref3406"></a>Add a comment to the data dictionary (<code>COMMENT</code>)</p> </li> 
       </ul> 
       <p>DDL statements implicitly commit the preceding and start a new transaction. Some examples of DDL statements are:</p> 
       <pre>
CREATE TABLE plants  
    (COMMON_NAME VARCHAR2 (15), LATIN_NAME VARCHAR2 (40)); 

DROP TABLE plants; 

GRANT SELECT ON employees TO scott; 

REVOKE DELETE ON employees FROM scott; 
</pre> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a href="security.htm#g24279">Chapter 20, "Database Security"</a>
       </div> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i18511"></a> 
      <div class="sect3">
       <a id="sthref3407"></a> 
       <h4 class="sect3">Transaction Control Statements</h4> 
       <p><a id="sthref3408"></a><a id="sthref3409"></a><a id="sthref3410"></a>Transaction control statements manage the changes made by DML statements and group DML statements into transactions. They enable you to:</p> 
       <ul> 
        <li> <p><a id="sthref3411"></a>Make a transaction's changes permanent (<code>COMMIT</code>)</p> </li> 
        <li> <p><a id="sthref3412"></a>Undo the changes in a transaction, either since the transaction started or since a savepoint (<code>ROLLBACK</code>)</p> </li> 
        <li> <p><a id="sthref3413"></a>Set a point to which you can roll back (<code>SAVEPOINT</code>)</p> </li> 
        <li> <p><a id="sthref3414"></a>Establish properties for a transaction (<code>SET</code> <code>TRANSACTION</code>)</p> </li> 
       </ul> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i18515"></a> 
      <div class="sect3">
       <a id="sthref3415"></a> 
       <h4 class="sect3">Session Control Statements</h4> 
       <p><a id="sthref3416"></a><a id="sthref3417"></a>Session control statements manage the properties of a particular user's session. For example, they enable you to:</p> 
       <ul> 
        <li> <p><a id="sthref3418"></a>Alter the current session by performing a specialized function, such as enabling and disabling the SQL trace facility (<code>ALTER</code> <code>SESSION</code>)</p> </li> 
        <li> <p><a id="sthref3419"></a>Enable and disable roles (groups of privileges) for the current session (<code>SET</code> <code>ROLE</code>)</p> </li> 
       </ul> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i18519"></a> 
      <div class="sect3">
       <a id="sthref3420"></a> 
       <h4 class="sect3">System Control Statements</h4> 
       <p><a id="sthref3421"></a><a id="sthref3422"></a>System control statements change the properties of the Oracle database server instance. <a id="sthref3423"></a>The only system control statement is <code>ALTER</code> <code>SYSTEM</code>. It enables you to change settings (such as the minimum number of shared servers), kill a session, and perform other tasks.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i18523"></a> 
      <div class="sect3">
       <a id="sthref3424"></a> 
       <h4 class="sect3">Embedded SQL Statements</h4> 
       <p><a id="sthref3425"></a><a id="sthref3426"></a><a id="sthref3427"></a><a id="sthref3428"></a><a id="sthref3429"></a>Embedded SQL statements incorporate DDL, DML, and transaction control statements within a procedural language program. They are used with the Oracle precompilers. Embedded SQL statements enable you to:</p> 
       <ul> 
        <li> <p><a id="sthref3430"></a>Define, allocate, and release cursors (<code>DECLARE</code> <code>CURSOR</code>, <code>OPEN</code>, <code>CLOSE</code>)</p> </li> 
        <li> <p><a id="sthref3431"></a>Specify a database and connect to Oracle (<code>DECLARE</code> <code>DATABASE</code>, <code>CONNECT</code>)</p> </li> 
        <li> <p><a id="sthref3432"></a>Assign variable names (<code>DECLARE</code> <code>STATEMENT</code>)</p> </li> 
        <li> <p>Initialize descriptors (<code>DESCRIBE</code>)</p> </li> 
        <li> <p><a id="sthref3433"></a>Specify how error and warning conditions are handled (<code>WHENEVER</code>)</p> </li> 
        <li> <p><a id="sthref3434"></a>Parse and run SQL statements (<code>PREPARE</code>, <code>EXECUTE</code>, <code>EXECUTE</code> <code>IMMEDIATE</code>)</p> </li> 
        <li> <p><a id="sthref3435"></a>Retrieve data from the database (<code>FETCH</code>)</p> </li> 
       </ul> 
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" --> 
     <a id="i1209"></a> 
     <div class="sect2">
      <a id="sthref3436"></a> 
      <h3 class="sect2">Cursors</h3> 
      <p><a id="sthref3437"></a><a id="sthref3438"></a><a id="sthref3439"></a>A <span class="bold">cursor</span> is a handle or name for a <span class="bold">private SQL area</span>—an area in memory in which a parsed statement and other information for processing the statement are kept.</p> 
      <p>Although most Oracle users rely on the automatic cursor handling of the Oracle utilities, the programmatic interfaces offer application designers more control over cursors. In application development, a cursor is a named resource available to a program and can be used specifically to parse SQL statements embedded within the application.</p> 
      <p><span class="bold"><a id="sthref3440"></a><a id="sthref3441"></a><a id="sthref3442"></a><a id="sthref3443"></a></span>Each user session can open multiple cursors up to the limit set by the initialization parameter <code>OPEN_CURSORS</code>. However, applications should close unneeded cursors to conserve system memory. If a cursor cannot be opened due to a limit on the number of cursors, then the database administrator can alter the <code>OPEN_CURSORS</code> initialization parameter.</p> 
      <p><a id="sthref3444"></a><a id="sthref3445"></a><a id="sthref3446"></a><a id="sthref3447"></a>Some statements (primarily DDL statements) require Oracle to implicitly issue recursive SQL statements, which also require <span class="bold">recursive cursors</span>. For example, a <code>CREATE</code> <code>TABLE</code> statement causes many updates to various data dictionary tables to record the new table and columns. <span class="bold">Recursive calls</span> are made for those recursive cursors; one cursor can run several recursive calls. These recursive cursors also use <span class="bold">shared SQL areas</span>.</p> 
      <a id="i14803"></a> 
      <div class="sect3">
       <a id="sthref3448"></a> 
       <h4 class="sect3"><a id="sthref3449"></a>Scrollable Cursors</h4> 
       <p>Execution of a cursor puts the results of the query into a set of rows called the result set, which can be fetched sequentially or nonsequentially. <span class="bold">Scrollable cursors</span> are cursors in which fetches and DML operations do not need to be forward sequential only. Interfaces exist to fetch previously fetched rows, to fetch the <span class="italic">n</span>th row in the result set, and to fetch the nth row from the current position in the result set.</p> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a class="olink LNOCI" href="../../appdev.102/b14250/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about using scrollable cursors in OCI
       </div> 
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" --> 
     <a id="i1208"></a> 
     <div class="sect2">
      <a id="sthref3450"></a> 
      <h3 class="sect2">Shared SQL</h3> 
      <p><a id="sthref3451"></a><a id="sthref3452"></a><a id="sthref3453"></a><a id="sthref3454"></a>Oracle automatically notices when applications send similar SQL statements to the database. The SQL area used to process the first occurrence of the statement is <span class="bold">shared</span>—that is, used for processing subsequent occurrences of that same statement. Therefore, only one shared SQL area exists for a unique statement. Because shared SQL areas are shared memory areas, any Oracle process can use a shared SQL area. The sharing of SQL areas reduces memory use on the database server, thereby increasing system throughput.</p> 
      <p>In evaluating whether statements are similar or identical, Oracle considers SQL statements issued directly by users and applications as well as recursive SQL statements issued internally by a DDL statement.</p> 
      <div class="infoboxnotealso"> 
       <p class="notep1">See Also:</p> 
       <a class="olink ADFNS" href="../../appdev.102/b14251/toc.htm"><span class="italic">Oracle Database Application Developer's Guide - Fundamentals</span></a> and 
       <a class="olink PFGRF" href="../b14211/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about shared SQL
      </div> 
     </div> 
     <!-- class="sect2" --> 
     <a id="i1243"></a> 
     <div class="sect2">
      <a id="sthref3455"></a> 
      <h3 class="sect2">Parsing</h3> 
      <p><span class="bold"><a id="sthref3456"></a>Parsing</span> is one stage in the processing of a SQL statement<a id="sthref3457"></a>. When an application issues a SQL statement, the application makes a parse call to Oracle. During the parse call, Oracle:</p> 
      <ul> 
       <li> <p>Checks the statement for syntactic and semantic validity</p> </li> 
       <li> <p>Determines whether the process issuing the statement has privileges to run it</p> </li> 
       <li> <p>Allocates a private SQL area for the statement</p> </li> 
      </ul> 
      <p>Oracle also determines whether there is an existing shared SQL area containing the parsed representation of the statement in the library cache. If so, the user process uses this parsed representation and runs the statement immediately. If not, Oracle generates the parsed representation of the statement, and the user process allocates a shared SQL area for the statement in the library cache and stores its parsed representation there.</p> 
      <p><a id="sthref3458"></a><a id="sthref3459"></a>Note the difference between an application making a parse call for a SQL statement and Oracle actually parsing the statement. A <span class="bold">parse call</span> by the <span class="bold">application</span> associates a SQL statement with a private SQL area. After a statement has been associated with a private SQL area, it can be run repeatedly without your application making a parse call. A <span class="bold">parse operation</span> by Oracle allocates a shared SQL area for a SQL statement. Once a shared SQL area has been allocated for a statement, it can be run repeatedly without being reparsed.</p> 
      <p>Both parse calls and parsing can be expensive relative to execution, so perform them as seldom as possible.</p> 
      <div class="infoboxnotealso"> 
       <p class="notep1">See Also:</p> 
       <a href="#i8536">"Overview of PL/SQL"</a>
      </div> 
     </div> 
     <!-- class="sect2" --> 
     <a id="i1694"></a> 
     <div class="sect2">
      <a id="sthref3460"></a> 
      <h3 class="sect2"><a id="CNCPT216"></a>SQL Processing</h3> 
      <p><a id="sthref3461"></a><a id="sthref3462"></a>This section introduces the basics of SQL processing. Topics include:</p> 
      <ul> 
       <li> <p><a href="#i1712">SQL Statement Execution</a></p> </li> 
       <li> <p><a href="#i1721">DML Statement Processing</a></p> </li> 
       <li> <p><a href="#i1727">DDL Statement Processing</a></p> </li> 
       <li> <p><a href="#i1733">Control of Transactions</a></p> </li> 
      </ul> 
      <a id="i1712"></a> 
      <div class="sect3">
       <a id="sthref3463"></a> 
       <h4 class="sect3">SQL Statement Execution</h4> 
       <p><a id="sthref3464"></a><a id="sthref3465"></a><a href="#i1740">Figure 24-1</a> outlines the stages commonly used to process and run a SQL statement. In some cases, Oracle can run these stages in a slightly different order. For example, the <code>DEFINE</code> stage could occur just before the <code>FETCH</code> stage, depending on how you wrote your code.</p> 
       <p>For many Oracle tools, several of the stages are performed automatically. Most users need not be concerned with or aware of this level of detail. However, this information could be useful when writing Oracle applications.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i1740"></a><a id="sthref3466"></a>Figure 24-1 The Stages in Processing a SQL Statement</p> 
        <img width="579" height="701" src="img/cncpt105.gif" alt="Description of Figure 24-1 follows" title="Description of Figure 24-1 follows">
        <br> 
        <a id="sthref3467" href="img_text/cncpt105.htm">Description of "Figure 24-1 The Stages in Processing a SQL Statement "</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i1721"></a> 
      <div class="sect3">
       <a id="sthref3468"></a> 
       <h4 class="sect3">DML Statement Processing</h4> 
       <p><a id="sthref3469"></a><a id="sthref3470"></a><a id="sthref3471"></a>This section provides an example of what happens during the execution of a SQL statement in each stage of DML statement processing.</p> 
       <p><a id="sthref3472"></a>Assume that you are using a Pro*C program to increase the salary for all employees in a department. The program you are using has connected to Oracle and you are connected to the proper schema to update the <code>employees</code> table. You can embed the following SQL statement in your program:</p> 
       <pre>
EXEC SQL UPDATE employees SET salary = 1.10 * salary 
    WHERE department_id = :department_id; 

</pre> 
       <p><code>Department_id</code> is a program variable containing a value for department number. When the SQL statement is run, the value of <code>department_id</code> is used, as provided by the application program.</p> 
       <p>The following stages are necessary for each type of statement processing:</p> 
       <ul> 
        <li> <p><a href="#i2191">Stage 1: Create a Cursor</a></p> </li> 
        <li> <p><a href="#i2196">Stage 2: Parse the Statement</a></p> </li> 
        <li> <p><a href="#i2202">Stage 5: Bind Any Variables</a></p> </li> 
        <li> <p><a href="#i2208">Stage 7: Run the Statement</a></p> </li> 
        <li> <p><a href="#i2214">Stage 9: Close the Cursor</a></p> </li> 
       </ul> 
       <p>Optionally, you can include another stage:</p> 
       <ul> 
        <li> <p><a href="#i15804">Stage 6: Parallelize the Statement</a></p> </li> 
       </ul> 
       <p>Queries (<code>SELECT</code>s) require several additional stages, as shown in <a href="#i1740">Figure 24-1</a>:</p> 
       <ul> 
        <li> <p><a href="#i2220">Stage 3: Describe Results of a Query</a></p> </li> 
        <li> <p><a href="#i2224">Stage 4: Define Output of a Query</a></p> </li> 
        <li> <p><a href="#i2228">Stage 8: Fetch Rows of a Query</a></p> </li> 
       </ul> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a href="#i2079">"Query Processing"</a>
       </div> 
       <a id="i2191"></a> 
       <div class="sect4">
        <a id="sthref3473"></a> 
        <h5 class="sect4">Stage 1: Create a Cursor</h5> 
        <p><a id="sthref3474"></a><a id="sthref3475"></a><a id="sthref3476"></a><a id="sthref3477"></a>A program interface call creates a cursor. The cursor is created independent of any SQL statement: it is created in expectation of any SQL statement. In most applications, cursor creation is automatic. However, in precompiler programs, cursor creation can either occur implicitly or be explicitly declared.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2196"></a> 
       <div class="sect4">
        <a id="sthref3478"></a> 
        <h5 class="sect4">Stage 2: Parse the Statement</h5> 
        <p><a id="sthref3479"></a><a id="sthref3480"></a><a id="sthref3481"></a>During parsing, the SQL statement is passed from the user process to Oracle, and a parsed representation of the SQL statement is loaded into a shared SQL area. Many errors can be caught during this stage of statement processing.</p> 
        <p>Parsing is the process of:</p> 
        <ul> 
         <li> <p>Translating a SQL statement, verifying it to be a valid statement</p> </li> 
         <li> <p><a id="sthref3482"></a>Performing data dictionary lookups to check table and column definitions</p> </li> 
         <li> <p><a id="sthref3483"></a><a id="sthref3484"></a>Acquiring parse locks on required objects so that their definitions do not change during the statement's parsing (however, parse locks can be broken to allow conflicting DDL operations)</p> </li> 
         <li> <p><a id="sthref3485"></a>Checking privileges to access referenced schema objects</p> </li> 
         <li> <p><a id="sthref3486"></a><a id="sthref3487"></a>Determining the optimal execution plan for the statement</p> </li> 
         <li> <p><a id="sthref3488"></a>Loading it into a shared SQL area</p> </li> 
         <li> <p><a id="sthref3489"></a><a id="sthref3490"></a>Routing all or part of distributed statements to remote nodes that contain referenced data</p> </li> 
        </ul> 
        <p>Oracle parses a SQL statement only if a shared SQL area for an similar SQL statement does not exist in the shared pool. In this case, a new shared SQL area is allocated, and the statement is parsed.</p> 
        <p>The parse stage includes processing requirements that need to be done only once no matter how many times the statement is run. Oracle translates each SQL statement only once, rerunning that parsed statement during subsequent references to the statement.</p> 
        <p>Although parsing a SQL statement validates that statement, parsing only identifies errors that can be found <span class="italic">before statement execution</span>. Thus, some errors cannot be caught by parsing. For example, errors in data conversion or errors in data (such as an attempt to enter duplicate values in a primary key) and deadlocks are all errors or situations that can be encountered and reported only during the execution stage.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a href="#i1208">"Shared SQL"</a>
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2079"></a> 
       <div class="sect4">
        <a id="sthref3491"></a> 
        <h5 class="sect4">Query Processing</h5> 
        <p><a id="sthref3492"></a><a id="sthref3493"></a><a id="sthref3494"></a><a id="sthref3495"></a>Queries are different from other types of SQL statements because, if successful, they return data as results. Whereas other statements simply return success or failure, a query can return one row or thousands of rows. The results of a query are <span class="italic">always</span> in <span class="bold">tabular format,</span> and the rows of the result are <span class="bold">fetched</span> (retrieved), either a row at a time or in groups.</p> 
        <p>Several issues relate only to query processing. <a id="sthref3496"></a><a id="sthref3497"></a><a id="sthref3498"></a>Queries include not only explicit <code>SELECT</code> statements but also the implicit queries <span class="italic">(</span>subqueries<span class="italic">)</span> in other SQL statements. For example, each of the following statements requires a query as a part of its execution:</p> 
        <pre>
INSERT INTO table SELECT... 

UPDATE table SET x = y WHERE... 

DELETE FROM table WHERE... 

CREATE table AS SELECT... 

</pre> 
        <p>In particular, queries:</p> 
        <ul> 
         <li> <p><a id="sthref3499"></a>Require <span class="bold">read consistency</span></p> </li> 
         <li> <p><a id="sthref3500"></a>Can use temporary segments for intermediate processing</p> </li> 
         <li> <p>Can require the describe, define, and fetch stages of SQL statement processing.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2220"></a> 
       <div class="sect4">
        <a id="sthref3501"></a> 
        <h5 class="sect4">Stage 3: Describe Results of a Query</h5> 
        <p><a id="sthref3502"></a><a id="sthref3503"></a>The describe stage is necessary only if the characteristics of a query's result are not known; for example, when a query is entered interactively by a user. In this case, the describe stage determines the characteristics (datatypes, lengths, and names) of a query's result.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2224"></a> 
       <div class="sect4">
        <a id="sthref3504"></a> 
        <h5 class="sect4">Stage 4: Define Output of a Query</h5> 
        <p><a id="sthref3505"></a><a id="sthref3506"></a>In the define stage for queries, you specify the location, size, and datatype of variables defined to receive each fetched value. These variables are called <span class="glossaryterm"><a id="sthref3507"></a>define variables</span>. Oracle performs datatype conversion if necessary. (See DEFINE on <a href="#i1740">Figure 24-1, "The Stages in Processing a SQL Statement"</a>.)</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2202"></a> 
       <div class="sect4">
        <a id="sthref3508"></a> 
        <h5 class="sect4">Stage 5: Bind Any Variables</h5> 
        <p>At this point, Oracle knows the meaning of the SQL statement but still does not have enough information to run the statement. Oracle needs values for any variables listed in the statement; in the example, Oracle needs a value for <code>department_id</code>. The process of obtaining these values is called <span class="bold">binding variables</span><span class="italic">.</span></p> 
        <p>A program must specify the location (memory address) where the value can be found. End users of applications may be unaware that they are specifying bind variables, because the Oracle utility can simply prompt them for a new value.</p> 
        <p>Because you specify the location (binding by reference), you need not rebind the variable before reexecution. You can change its value and Oracle looks up the value on each execution, using the memory address.</p> 
        <p><a id="sthref3509"></a><a id="sthref3510"></a><a id="sthref3511"></a>You must also specify a datatype and length for each value (unless they are implied or defaulted) if Oracle needs to perform datatype conversion.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <ul> 
          <li> <p><a class="olink LNOCI" href="../../appdev.102/b14250/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a></p> </li> 
          <li> <p><a class="olink LNPCC" href="../../appdev.102/b14407/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> (see "Dynamic SQL Method 4")</p> </li> 
          <li> <p><a class="olink LNPCB" href="../../appdev.102/a96109/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> (see "Dynamic SQL Method 4")</p> </li> 
         </ul> 
         <p>for more information about specifying a datatype and length for a value</p> 
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i15804"></a> 
       <div class="sect4">
        <a id="sthref3512"></a> 
        <h5 class="sect4">Stage 6: Parallelize the Statement</h5> 
        <p>Oracle can parallelize queries (<code>SELECT</code>s, <code>INSERT</code>s, <code>UPDATE</code>s, <code>MERGE</code>s, <code>DELETE</code>s), and some DDL operations such as index creation, creating a table with a subquery, and operations on partitions. Parallelization causes multiple server processes to perform the work of the SQL statement so it can complete faster.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a href="bus_intl.htm#g35689">Chapter 16, "Business Intelligence"</a>
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2208"></a> 
       <div class="sect4">
        <a id="sthref3513"></a> 
        <h5 class="sect4">Stage 7: Run the Statement</h5> 
        <p><a id="sthref3514"></a>At this point, Oracle has all necessary information and resources, so the statement is run. If the statement is a query or an <code>INSERT</code> statement, no rows need to be locked because no data is being changed. If the statement is an <code>UPDATE</code> or <code>DELETE</code> statement, however, all rows that the statement affects are locked from use by other users of the database until the next <code>COMMIT</code>, <code>ROLLBACK</code>, or <code>SAVEPOINT</code> for the transaction. This ensures data integrity.</p> 
        <p><a id="sthref3515"></a><a id="sthref3516"></a>For some statements you can specify a number of executions to be performed. This is called <span class="bold">array processing</span>. Given <span class="italic">n</span> number of executions, the bind and define locations are assumed to be the beginning of an array of size <span class="italic">n</span>.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2228"></a> 
       <div class="sect4">
        <a id="sthref3517"></a> 
        <h5 class="sect4">Stage 8: Fetch Rows of a Query</h5> 
        <p><a id="sthref3518"></a>In the fetch stage, rows are selected and ordered (if requested by the query), and each successive fetch retrieves another row of the result until the last row has been fetched.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i2214"></a> 
       <div class="sect4">
        <a id="sthref3519"></a> 
        <h5 class="sect4">Stage 9: Close the Cursor</h5> 
        <p>The final stage of processing a SQL statement is closing the cursor.</p> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i1727"></a> 
      <div class="sect3">
       <a id="sthref3520"></a> 
       <h4 class="sect3">DDL Statement Processing</h4> 
       <p><a id="sthref3521"></a><a id="sthref3522"></a>The execution of DDL statements differs from the execution of DML statements and queries, because the success of a DDL statement requires write access to the data dictionary. For these statements, parsing (Stage 2) actually includes parsing, data dictionary lookup, and execution.</p> 
       <p>Transaction management, session management, and system management SQL statements are processed using the parse and run stages. To rerun them, simply perform another execute.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i1733"></a> 
      <div class="sect3">
       <a id="sthref3523"></a> 
       <h4 class="sect3">Control of Transactions</h4> 
       <p><a id="sthref3524"></a><a id="sthref3525"></a><a id="sthref3526"></a>In general, only application designers using the programming interfaces to Oracle are concerned with the types of actions that should be grouped together as one transaction. Transactions must be defined so that work is accomplished in logical units and data is kept consistent. A transaction should consist of all of the necessary parts for one logical unit of work, no more and no less.</p> 
       <ul> 
        <li> <p><a id="sthref3527"></a>Data in all referenced tables should be in a consistent state before the transaction begins and after it ends.</p> </li> 
        <li> <p>Transactions should consist of only the SQL statements that make one consistent change to the data.</p> </li> 
       </ul> 
       <p>For example, a transfer of funds between two accounts (the transaction or logical unit of work) should include the debit to one account (one SQL statement) and the credit to another account (one SQL statement). Both actions should either fail or succeed together as a unit of work; the credit should not be committed without the debit. Other unrelated actions, such as a new deposit to one account, should not be included in the transfer of funds transaction.</p> 
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" --> 
     <a id="i8709"></a> 
     <div class="sect2">
      <a id="sthref3528"></a> 
      <h3 class="sect2"><a id="CNCPT316"></a><a id="sthref3529"></a>Overview of the Optimizer</h3> 
      <p>All SQL statements use the <span class="bold">optimizer</span>, a part of Oracle that determines the most efficient means of accessing the specified data. Oracle also provides techniques that you can use to make the optimizer perform its job better.</p> 
      <p>There are often many different ways to process a SQL DML (<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>MERGE</code>, or <code>DELETE</code>) statement; for example, by varying the order in which tables or indexes are accessed. The procedure Oracle uses to run a statement can greatly affect how quickly the statement runs. The optimizer considers many factors among alternative access paths.</p> 
      <div class="infobox-note"> 
       <p class="notep1">Note:</p> The optimizer might not make the same decisions from one version of Oracle to the next. In recent versions, the optimizer might make decisions based on better information available to it.
      </div> 
      <p>You can influence the optimizer's choices by setting the optimizer approach and goal. Objects with stale or no statistics are automatically analyzed. You can also gather statistics for the optimizer using the PL/SQL package <code>DBMS_STATS</code>.</p> 
      <p>Sometimes the application designer, who has more information about a particular application's data than is available to the optimizer, can choose a more effective way to run a SQL statement. The application designer can use hints in SQL statements to specify how the statement should be run.</p> 
      <div class="infoboxnotealso"> 
       <p class="notep1">See Also:</p> 
       <ul> 
        <li> <p><a class="olink ARPLS" href="../../appdev.102/b14258/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about using <code>DBMS_STATS</code></p> </li> 
        <li> <p><a class="olink PFGRF" href="../b14211/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about the optimizer</p> </li> 
       </ul> 
      </div> 
      <div class="sect3">
       <a id="sthref3530"></a> 
       <h4 class="sect3"><a id="sthref3531"></a>Execution Plans</h4> 
       <p>To run a DML statement, Oracle might need to perform many steps. Each of these steps either retrieves rows of data physically from the database or prepares them in some way for the user issuing the statement. The combination of the steps Oracle uses to run a statement is called an execution plan. An execution plan includes an access method for each table that the statement accesses and an ordering of the tables (the join order). The steps of the execution plan are not performed in the order in which they are numbered.</p> 
       <div class="sect4">
        <a id="sthref3532"></a> 
        <h5 class="sect4"><a id="sthref3533"></a>Stored Outlines</h5> 
        <p>Stored outlines are abstractions of an execution plan generated by the optimizer at the time the outline was created and are represented primarily as a set of hints. When the outline is subsequently used, these hints are applied at various stages of compilation. Outline data is stored in the <code>OUTLN</code> schema. You can tune execution plans by editing stored outlines.</p> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3534"></a> 
        <h5 class="sect4"><a id="sthref3535"></a><a id="sthref3536"></a>Editing Stored Outlines</h5> 
        <p>The outline is cloned into the user's schema at the onset of the outline editing session. All subsequent editing operations are performed on that clone until the user is satisfied with the edits and chooses to publicize them. In this way, any editing done by the user does not impact the rest of the user community, which would continue to use the public version of the outline until the edits are explicitly saved.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink PFGRF" href="../b14211/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for details about execution plans and using stored outlines
        </div> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" -->
    </div> 
    <!-- class="sect1" --> 
    <a id="i24650"></a> 
    <div class="sect1">
     <a id="sthref3537"></a> 
     <h2 class="sect1">Overview of Procedural Languages</h2> 
     <p>In Oracle, SQL, PL/SQL, XML, and Java all interoperate seamlessly in a way that allows developers to mix-and-match the most relevant features of each language. SQL and PL/SQL form the core of Oracle's application development stack. Not only do most enterprise back-ends run SQL, but Web applications accessing databases do so using SQL (wrappered by Java classes as JDBC), Enterprise Application Integration applications generate XML from SQL queries, and content-repositories are built on top of SQL tables. It is a simple, widely understood, unified data model. It is used standalone in many applications, but it is also invoked indirectly from Java (JDBC), Oracle Call Interface (dynamic SQL), and XML (XML SQL Utility).</p> 
     <p>This section includes the following:</p> 
     <ul> 
      <li> <p><a href="#i8536">Overview of PL/SQL</a></p> </li> 
      <li> <p><a href="#i7579">Overview of Java</a></p> </li> 
     </ul> 
     <a id="i8536"></a> 
     <div class="sect2">
      <a id="sthref3538"></a> 
      <h3 class="sect2"><a id="CNCPT416"></a>Overview of PL/SQL</h3> 
      <p><a id="sthref3539"></a><a id="sthref3540"></a><a id="sthref3541"></a><a id="sthref3542"></a><a id="sthref3543"></a>PL/SQL is Oracle's procedural language extension to SQL. It provides a server-side, stored procedural language that is easy-to-use, seamless with SQL, robust, portable, and secure. The PL/SQL compiler and interpreter are embedded in Oracle Developer, providing developers with a consistent and leveraged development model on both the client and the server side. In addition, PL/SQL stored procedures can be called from a number of Oracle clients, such as Pro*C or Oracle Call Interface, and from Oracle Reports and Oracle Forms.</p> 
      <p>PL/SQL enables you to mix SQL statements with procedural constructs. With PL/SQL, you can define and run PL/SQL program units such as procedures, functions, and packages. PL/SQL program units generally are categorized as anonymous blocks and stored procedures.</p> 
      <p><a id="sthref3544"></a><a id="sthref3545"></a><a id="sthref3546"></a>An <span class="bold">anonymous block</span> is a PL/SQL block that appears in your application and is not named or stored in the database. In many applications, PL/SQL blocks can appear wherever SQL statements can appear.</p> 
      <p><a id="sthref3547"></a><a id="sthref3548"></a><a id="sthref3549"></a><a id="sthref3550"></a>A <span class="bold">stored procedure</span> is a PL/SQL block that Oracle stores in the database and can be called by name from an application. When you create a stored procedure, Oracle parses the procedure and stores its parsed representation in the database. Oracle also lets you create and store functions (which are similar to procedures) and packages (which are groups of procedures and functions).</p> 
      <div class="infoboxnotealso"> 
       <p class="notep1">See Also:</p> 
       <p><a href="#i7579">"Overview of Java"</a></p> 
       <p><a href="triggers.htm#g22503">Chapter 22, "Triggers"</a></p> 
      </div> 
      <div class="sect3">
       <a id="sthref3551"></a> 
       <h4 class="sect3">How PL/SQL Runs</h4> 
       <p>PL/SQL can run with either interpreted execution or native execution.</p> 
       <div class="sect4">
        <a id="sthref3552"></a> 
        <h5 class="sect4">Interpreted Execution</h5> 
        <p>In versions earlier than Oracle9<span class="italic">i</span>, PL/SQL source code was always compiled into a so-called bytecode representation, which is run by a portable virtual computer implemented as part of the Oracle database server, and also in products such as Oracle Forms. Starting with Oracle9<span class="italic">i</span>, you can choose between native execution and interpreted execution</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i24244"></a> 
       <div class="sect4">
        <a id="sthref3553"></a> 
        <h5 class="sect4">Nativ<a id="sthref3554"></a>e Execution</h5> 
        <p>For best performance on computationally intensive program units, compile the source code of PL/SQL program units stored in the database directly to object code for the given platform. (This object code is linked into the Oracle database server.)</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a>
        </div> 
        <p><a id="sthref3555"></a><a id="sthref3556"></a>The <span class="bold">PL/SQL engine</span> is the tool you use to define, compile, and run PL/SQL program units. This engine is a special component of many Oracle products, including the Oracle database server.</p> 
        <p><a id="sthref3557"></a>While many Oracle products have PL/SQL components, this section specifically covers the program units that can be stored in an Oracle database and processed using the Oracle database server PL/SQL engine. The PL/SQL capabilities of each Oracle tool are described in the appropriate tool's documentation.</p> 
        <p><a href="#i1409">Figure 24-2</a> illustrates the PL/SQL engine contained in Oracle database server.</p> 
        <div class="figure"> 
         <p class="titleinfigure"><a id="i1409"></a><a id="sthref3558"></a>Figure 24-2 The PL/SQL Engine and the Oracle Database Server</p> 
         <img width="496" height="415" src="img/cncpt070.gif" alt="Description of Figure 24-2 follows" title="Description of Figure 24-2 follows">
         <br> 
         <a id="sthref3559" href="img_text/cncpt070.htm">Description of "Figure 24-2 The PL/SQL Engine and the Oracle Database Server"</a>
         <br> 
         <br>
        </div> 
        <!-- class="figure" --> 
        <p><a id="sthref3560"></a><a id="sthref3561"></a><a id="sthref3562"></a><a id="sthref3563"></a>The program unit is stored in a database. When an application calls a procedure stored in the database, Oracle loads the compiled program unit into the shared pool in the system global area (SGA). The PL/SQL and SQL statement executors work together to process the statements within the procedure.</p> 
        <p><a id="sthref3564"></a>The following Oracle products contain a PL/SQL engine:</p> 
        <ul> 
         <li> <p>Oracle database server</p> </li> 
         <li> <p><a id="sthref3565"></a>Oracle Forms (version 3 and later)</p> </li> 
         <li> <p><a id="sthref3566"></a>SQL*Menu (version 5 and later)</p> </li> 
         <li> <p>Oracle Reports (version 2 and later)</p> </li> 
         <li> <p>Oracle Graphics (version 2 and later)</p> </li> 
        </ul> 
        <p>You can call a stored procedure from another PL/SQL block, which can be either an anonymous block or another stored procedure. For example, you can call a stored procedure from Oracle Forms (version 3 or later).</p> 
        <p><a id="sthref3567"></a>Also, you can pass anonymous blocks to Oracle from applications developed with these tools:</p> 
        <ul> 
         <li> <p><a id="sthref3568"></a><a id="sthref3569"></a>Oracle precompilers (including user exits)</p> </li> 
         <li> <p><a id="sthref3570"></a>Oracle Call Interfaces (OCIs)</p> </li> 
         <li> <p><a id="sthref3571"></a>SQL*Plus</p> </li> 
         <li> <p><a id="sthref3572"></a>Oracle Enterprise Manager</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <div class="sect3">
       <a id="sthref3573"></a> 
       <h4 class="sect3">Language Constructs for PL/SQL</h4> 
       <p><a id="sthref3574"></a>PL/SQL blocks can include the following PL/SQL language constructs:</p> 
       <ul> 
        <li> <p>Variables and constants</p> </li> 
        <li> <p>Cursors</p> </li> 
        <li> <p>Exceptions</p> </li> 
       </ul> 
       <p>This section gives a general description of each construct.</p> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a>
       </div> 
       <div class="sect4">
        <a id="sthref3575"></a> 
        <h5 class="sect4">Variables and Constants<a id="sthref3576"></a><a id="sthref3577"></a></h5> 
        <p><a id="sthref3578"></a>Variables and constants can be declared within a procedure, function, or package. A variable or constant can be used in a SQL or PL/SQL statement to capture or provide a value when one is needed.</p> 
        <p>Some interactive tools, such as <a id="sthref3579"></a>SQL*Plus, let you define variables in your current session. You can use such variables just as you would variables declared within procedures or&nbsp;packages.</p> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3580"></a> 
        <h5 class="sect4">Cursors<a id="sthref3581"></a><a id="sthref3582"></a></h5> 
        <p><span class="bold">Cursors</span> can be declared explicitly within a procedure, function, or package to facilitate record-oriented processing of Oracle data. Cursors also can be declared implicitly (to support other data manipulation actions) by the PL/SQL engine.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a href="#i14803">"Scrollable Cursors"</a>
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3583"></a> 
        <h5 class="sect4">Exceptions<a id="sthref3584"></a><a id="sthref3585"></a></h5> 
        <p>PL/SQL lets you explicitly handle internal and user-defined error conditions, called <span class="bold">exceptions</span>, that arise during processing of PL/SQL code. Internal exceptions are caused by illegal operations, such as division by zero, or Oracle errors returned to the PL/SQL code. User-defined exceptions are explicitly defined and signaled within the PL/SQL block to control processing of errors specific to the application (for example, debiting an account and leaving a negative balance).</p> 
        <p><a id="sthref3586"></a>When an exception is raised, the execution of the PL/SQL code stops, and a routine called an exception handler is invoked. Specific exception handlers can be written for any internal or user-defined exception.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i4827"></a> 
       <div class="sect4">
        <a id="sthref3587"></a> 
        <h5 class="sect4">Dynamic SQL in PL/SQL</h5> 
        <p><a id="sthref3588"></a><a id="sthref3589"></a><a id="sthref3590"></a><a id="sthref3591"></a>PL/SQL can run <span class="bold">dynamic SQL</span> statements whose complete text is not known until runtime. Dynamic SQL statements are stored in character strings that are entered into, or built by, the program at runtime. This enables you to create general purpose procedures. For example, dynamic SQL lets you create a procedure that operates on a table whose name is not known until runtime.</p> 
        <p><a id="sthref3592"></a>You can write stored procedures and anonymous PL/SQL blocks that include dynamic SQL in two ways:</p> 
        <ul> 
         <li> <p><a id="sthref3593"></a>By embedding dynamic SQL statements in the PL/SQL block</p> </li> 
         <li> <p><a id="sthref3594"></a><a id="sthref3595"></a>By using the <code>DBMS_SQL</code> package</p> </li> 
        </ul> 
        <p><a id="sthref3596"></a><a id="sthref3597"></a><a id="sthref3598"></a><a id="sthref3599"></a><a id="sthref3600"></a><a id="sthref3601"></a>Additionally, you can issue DML or DDL statements using dynamic SQL. This helps solve the problem of not being able to statically embed DDL statements in PL/SQL. For example, you can choose to issue a <code>DROP</code> <code>TABLE</code> statement from within a stored procedure by using the <code>EXECUTE</code> <code>IMMEDIATE</code> statement or the <code>PARSE</code> procedure supplied with the <code>DBMS_SQL</code> package.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <ul> 
          <li> <p><a class="olink ADFNS" href="../../appdev.102/b14251/toc.htm"><span class="italic">Oracle Database Application Developer's Guide - Fundamentals</span></a> for a comparison of the two approaches to dynamic SQL</p> </li> 
          <li> <p><a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a> for details about dynamic SQL</p> </li> 
          <li> <p><a class="olink ARPLS" href="../../appdev.102/b14258/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p> </li> 
         </ul> 
        </div> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <div class="sect3">
       <a id="sthref3602"></a> 
       <h4 class="sect3">PL/SQL Program Units</h4> 
       <p><a id="sthref3603"></a><a id="sthref3604"></a><a id="sthref3605"></a><a id="sthref3606"></a><a id="sthref3607"></a>Oracle lets you access and manipulate database information using procedural schema objects called <span class="bold">PL/SQL program units</span>. Procedures, functions, and packages are all examples of PL/SQL program units.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i18617"></a> 
      <div class="sect3">
       <a id="sthref3608"></a> 
       <h4 class="sect3">Stored Procedures and Functions</h4> 
       <p><a id="sthref3609"></a><a id="sthref3610"></a><a id="sthref3611"></a><a id="sthref3612"></a><a id="sthref3613"></a>A <span class="bold">procedure</span> or <span class="bold">function</span> is a schema object that consists of a set of SQL statements and other PL/SQL constructs, grouped together, stored in the database, and run as a unit to solve a specific problem or perform a set of related tasks. Procedures and functions permit the caller to provide parameters that can be input only, output only, or input and output values. Procedures and functions let you combine the ease and flexibility of SQL with the procedural functionality of a structured programming language.</p> 
       <p><a id="sthref3614"></a><a id="sthref3615"></a>Procedures and functions are identical except that functions always return a single value to the caller, while procedures do not. For simplicity, <span class="bold">procedure</span> as used in the remainder of this chapter means <span class="bold">procedure</span> <span class="italic">or</span> <span class="bold">function</span>.</p> 
       <p><a id="sthref3616"></a><a id="sthref3617"></a>You can run a procedure or function interactively by:</p> 
       <ul> 
        <li> <p>Using an Oracle tool, such as SQL*Plus</p> </li> 
        <li> <p>Calling it explicitly in the code of a database application, such as an Oracle Forms or precompiler application</p> </li> 
        <li> <p>Calling it explicitly in the code of another procedure or trigger<a id="sthref3618"></a><a id="sthref3619"></a></p> </li> 
       </ul> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <ul> 
         <li> <p><a class="olink LNPCC" href="../../appdev.102/b14407/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> for information about how to call stored C or C++ procedures</p> </li> 
         <li> <p><a class="olink LNPCB" href="../../appdev.102/a96109/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information about how to call stored COBOL procedures</p> </li> 
         <li> <p>Other programmer's guides for information about how to call stored procedures of specific kinds of application</p> </li> 
        </ul> 
       </div> 
       <p><a href="#i18663">Figure 24-3</a> illustrates a simple procedure that is stored in the database and called by several different database applications.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i18663"></a><a id="sthref3620"></a>Figure 24-3 Stored Procedure</p> 
        <img width="462" height="446" src="img/cncpt073.gif" alt="Description of Figure 24-3 follows" title="Description of Figure 24-3 follows">
        <br> 
        <a id="sthref3621" href="img_text/cncpt073.htm">Description of "Figure 24-3 Stored Procedure"</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" --> 
       <p>The following stored procedure example inserts an employee record into the <code>employees</code> table:</p> 
       <pre>
Procedure hire_employees (last_name VARCHAR2, job_id VARCHAR2, manager_id NUMBER, hire_date DATE, salary NUMBER, commission_pct NUMBER, department_id NUMBER)
 
BEGIN
.
.
INSERT INTO employees VALUES (emp_sequence.NEXTVAL, last_name, job_id, manager_id, hire_date, salary, commission_pct, department_id);
.
.
END

</pre> 
       <p><a id="sthref3622"></a><a id="sthref3623"></a>All of the database applications in this example call the <code>hire_employees</code> procedure. Alternatively, a privileged user can use Oracle Enterprise Manager or SQL*Plus to run the <code>hire_employees</code> procedure using the following statement:</p> 
       <pre>
EXECUTE hire_employees ('TSMITH', 'CLERK', 1037, SYSDATE, 500, NULL, 20); 

</pre> 
       <p>This statement places a new employee record for <code>TSMITH</code> in the <code>employees</code> table.</p> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="variable">Oracle Database PL/SQL User's Guide and Reference</span></a>
       </div> 
       <div class="sect4">
        <a id="sthref3624"></a> 
        <h5 class="sect4">Benefits of Procedures</h5> 
        <p><a id="sthref3625"></a>Stored procedures provide advantages in the following areas:</p> 
        <a id="i18704"></a> 
        <ul> 
         <li> <p>Security with definer's rights procedures</p> <p><a id="sthref3626"></a>Stored procedures can help enforce data security. You can restrict the database operations that users can perform by allowing them to access data only through procedures and functions that run with the definer's privileges.</p> <p>For example, you can grant users access to a procedure that updates a table but not grant them access to the table itself. When a user invokes the procedure, the procedure runs with the privileges of the procedure's owner. Users who have only the privilege to run the procedure (but not the privileges to query, update, or delete from the underlying tables) can invoke the procedure, but they cannot manipulate table data in any other way.</p> 
          <div class="infoboxnotealso"> 
           <p class="notep1">See Also:</p> 
           <a href="#i18768">"Dependency Tracking for Stored Procedures"</a>
          </div> </li> 
         <li> <p><a id="i18719"></a>Inherited privileges and schema context with invoker's rights procedures</p> <p>An invoker's rights procedure inherits privileges and schema context from the procedure that calls it. In other words, an invoker's rights procedure is not tied to a particular user or schema, and each invocation of an invoker's rights procedure operates in the current user's schema with the current user's privileges. Invoker's rights procedures make it easy for application developers to centralize application logic, even when the underlying data is divided among user schemas.</p> <p>For example, a user who runs an update procedure on the <code>employees</code> table as a manager can update salary, whereas a user who runs the same procedure as a clerk can be restricted to updating address data.</p> </li> 
         <li> <p><a id="i18722"></a>Improved performance</p> 
          <ul> 
           <li> <p>The amount of information that must be sent over a network is small compared with issuing individual SQL statements or sending the text of an entire PL/SQL block to Oracle, because the information is sent only once and thereafter invoked when it is used.</p> </li> 
           <li> <p><a id="sthref3627"></a>A procedure's compiled form is readily available in the database, so no compilation is required at execution time.</p> </li> 
           <li> <p>If the procedure is already present in the shared pool of the system global area (SGA), then retrieval from disk is not required, and execution can begin immediately.</p> </li> 
          </ul> </li> 
         <li> <p><a id="i18728"></a>Memory allocation</p> <p><a id="sthref3628"></a>Because stored procedures take advantage the shared memory capabilities of Oracle, only a single copy of the procedure needs to be loaded into memory for execution by multiple users. Sharing the same code among many users results in a substantial reduction in Oracle memory requirements for applications.</p> </li> 
         <li> <p><a id="i18732"></a>Improved productivity</p> <p>Stored procedures increase development productivity. By designing applications around a common set of procedures, you can avoid redundant coding and increase your productivity.</p> <p>For example, procedures can be written to insert, update, or delete employee records from the <code>employees</code> table. These procedures can then be called by any application without rewriting the SQL statements necessary to accomplish these tasks. If the methods of data management change, only the procedures need to be modified, not all of the applications that use the procedures.</p> </li> 
         <li> <p><a id="i18735"></a>Integrity</p> <p>Stored procedures improve the integrity and consistency of your applications. By developing all of your applications around a common group of procedures, you can reduce the likelihood of committing coding errors.</p> <p>For example, you can test a procedure or function to guarantee that it returns an accurate result and, once it is verified, reuse it in any number of applications without testing it again. If the data structures referenced by the procedure are altered in any way, then only the procedure needs to be recompiled. Applications that call the procedure do not necessarily require any modifications.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3629"></a> 
        <h5 class="sect4">Procedure Guidelines</h5> 
        <p>Use the following guidelines when designing stored procedures:</p> 
        <ul> 
         <li> <p>Define procedures to complete a single, focused task. Do not define long procedures with several distinct subtasks, because subtasks common to many procedures can be duplicated unnecessarily in the code of several procedures.</p> </li> 
         <li> <p>Do not define procedures that duplicate the functionality already provided by other features of Oracle. For example, do not define procedures to enforce simple data integrity rules that you could easily enforce using declarative integrity constraints.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3630"></a> 
        <h5 class="sect4">Anonymous PL/SQL Blocks Compared with Stored Procedures</h5> 
        <p><a id="sthref3631"></a><a id="sthref3632"></a><a id="sthref3633"></a><a id="sthref3634"></a><a id="sthref3635"></a><a id="sthref3636"></a><a id="sthref3637"></a>A stored procedure is created and stored in the database as a schema object. Once created and compiled, it is a named object that can be run without recompiling. Additionally, dependency information is stored in the data dictionary to guarantee the validity of each stored procedure.</p> 
        <p><a id="sthref3638"></a>As an alternative to a stored procedure, you can create an anonymous PL/SQL block by sending an unnamed PL/SQL block to the Oracle database server from an Oracle tool or an application. Oracle compiles the PL/SQL block and places the compiled version in the shared pool of the SGA, but it does not store the source code or compiled version in the database for reuse beyond the current instance. Shared SQL allows anonymous PL/SQL blocks in the shared pool to be reused and shared until they are flushed out of the shared pool.</p> 
        <p><a id="sthref3639"></a>In either case, moving PL/SQL blocks out of a database application and into database procedures stored either in the database or in memory, you avoid unnecessary procedure recompilations by Oracle at runtime, improving the overall performance of the application and Oracle.</p> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3640"></a> 
        <h5 class="sect4">Standalone Procedures</h5> 
        <p>Stored procedures not defined within the context of a package are called <span class="bold">standalone procedures</span>. Procedures defined within a package are considered a part of the package.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a href="#i18829">"PL/SQL Packages"</a> for information about the advantages of packages
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i18768"></a> 
       <div class="sect4">
        <a id="sthref3641"></a> 
        <h5 class="sect4">Dependency Tracking for Stored Procedures</h5> 
        <p>A stored procedure depends on the objects referenced in its body. Oracle automatically tracks and manages such dependencies. For example, if you alter the definition of a table referenced by a procedure, then the procedure must be recompiled to validate that it will still work as designed. Usually, Oracle automatically administers such dependency management.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a href="depend.htm#g9236">Chapter 6, "Dependencies Among Schema Objects"</a> for more information about dependency tracking
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3642"></a> 
        <h5 class="sect4">External Procedures</h5> 
        <p><a id="sthref3643"></a><a id="sthref3644"></a><a id="sthref3645"></a>A PL/SQL procedure executing on an Oracle database server can call an external procedure or function that is written in the C programming language and stored in a shared library. The C routine runs in a separate address space from that of the Oracle database server.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink ADFNS" href="../../appdev.102/b14251/toc.htm"><span class="italic">Oracle Database Application Developer's Guide - Fundamentals</span></a> for more information about external procedures
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i18795"></a> 
       <div class="sect4">
        <a id="sthref3646"></a> 
        <h5 class="sect4"><a id="sthref3647"></a>Table Functions</h5> 
        <p><span class="glossaryterm">Table functions</span> are functions that can produce a set of rows as output. In other words, table functions return a collection type instance (nested table and <code>VARRAY</code> datatypes). You can use a table function in place of a regular table in the <code>FROM</code> clause of a SQL statement.</p> 
        <p><a id="i18800"></a><a id="sthref3648"></a><a id="sthref3649"></a>Oracle allows table functions to <span class="glossaryterm">pipeline</span> results (act like an Oracle rowsource) out of the functions. This can be achieved by either providing an implementation of the <code>ODCITable</code> interface, or using native PL/SQL instructions.</p> 
        <p>Pipelining helps to improve the performance of a number of applications, such as Oracle Warehouse Builder (OWB) and cartridges groups.</p> 
        <p>The ETL (Extraction-Transformation-Load) process in data warehouse building extracts data from an OLTP system. The extracted data passes through a sequence of transformations (written in procedural languages, such as PL/SQL) before it is loaded into a data warehouse.</p> 
        <p><a id="i18806"></a><a id="sthref3650"></a><a id="sthref3651"></a>Oracle also allows parallel execution of table and non-table functions. Parallel execution provides the following extensions:</p> 
        <ul> 
         <li> <p>Functions can directly accept a set of rows corresponding to a subquery operand.</p> </li> 
         <li> <p>A set of input rows can be partitioned among multiple instances of a parallel function. The function developer specifies how the input rows should be partitioned between parallel instances of the function.</p> </li> 
        </ul> 
        <p>Thus, table functions are similar to views. However, instead of defining the transform declaratively in SQL, you define it procedurally in PL/SQL. This is especially valuable for the arbitrarily complex transformations typically required in ETL.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <ul> 
          <li> <p><a href="bus_intl.htm#i31027">"Overview of Extraction, Transformation, and Loading (ETL)"</a></p> </li> 
          <li> <p><span class="italic"><a class="olink ADDCI012" href="../../appdev.102/b14289/dcitblfns.htm#ADDCI012">Oracle Database Data Cartridge Developer's Guide</a></span></p> </li> 
          <li> <p><a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a></p> </li> 
         </ul> 
        </div> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i18829"></a> 
      <div class="sect3">
       <a id="sthref3652"></a> 
       <h4 class="sect3">PL/SQL Packages</h4> 
       <p><a id="sthref3653"></a><a id="sthref3654"></a>A <span class="bold">package</span> is a group of related procedures and functions, along with the cursors and variables they use, stored together in the database for continued use as a unit. Similar to standalone procedures and functions, packaged procedures and functions can be called explicitly by applications or users.</p> 
       <p>Oracle supplies many PL/SQL packages with the Oracle database server to extend database functionality and provide PL/SQL access to SQL features. For example, the <code>ULT_HTTP</code> supplied package enables HTTP callouts from PL/SQL and SQL to access data on the Internet or to call Oracle Web Server Cartridges. You can use the supplied packages when creating your applications or for ideas in creating your own stored procedures.</p> 
       <p>You create a package in two parts: the specification and the body. The package <span class="bold">specification</span> declares all public constructs of the package and the <span class="bold">body</span> defines all constructs (public and private) of the package. This separation of the two parts provides the following advantages:</p> 
       <ul> 
        <li> <p>You have more flexibility in the development cycle. You can create specifications and reference public procedures without actually creating the package body.</p> </li> 
        <li> <p>You can alter procedure bodies contained within the package body separately from their publicly declared specifications in the package specification. As long as the procedure specification does not change, objects that reference the altered procedures of the package are never marked invalid. That is, they are never marked as needing recompilation.</p> </li> 
       </ul> 
       <p><a href="#i18841">Figure 24-4</a> illustrates a package that encapsulates a number of procedures used to manage an employee database.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i18841"></a><a id="sthref3655"></a>Figure 24-4 A Stored Package</p> 
        <img width="603" height="639" src="img/cncpt075.gif" alt="Description of Figure 24-4 follows" title="Description of Figure 24-4 follows">
        <br> 
        <a id="sthref3656" href="img_text/cncpt075.htm">Description of "Figure 24-4 A Stored Package"</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" --> 
       <p><a id="sthref3657"></a><a id="sthref3658"></a>Database applications explicitly call packaged procedures as necessary. After being granted the privileges for the <code>employees_management</code> package, a user can explicitly run any of the procedures contained in it. For example, Oracle Enterprise Manager or SQL*Plus can issue the following statement to run the <code>hire_employees</code> package procedure:</p> 
       <pre>
EXECUTE employees_management.hire_employees ('TSMITH', 'CLERK', 1037, SYSDATE, 500, NULL, 20); 

</pre> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <ul> 
         <li> <p><a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="variable">Oracle Database PL/SQL User's Guide and Reference</span></a></p> </li> 
         <li> <p><a class="olink ARPLS" href="../../appdev.102/b14258/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p> </li> 
        </ul> 
       </div> 
       <div class="sect4">
        <a id="sthref3659"></a> 
        <h5 class="sect4">Benefits of Packages</h5> 
        <p><a id="sthref3660"></a>Packages provide advantages in the following areas:</p> 
        <ul> 
         <li> <p>Encapsulation of related procedures and variables</p> <p>Stored packages allow you to <span class="bold">encapsulate</span> or group stored procedures, variables, datatypes, and so on in a single named, stored unit in the database. This provides better organization during the development process. Encapsulation of procedural constructs also makes privilege management easier. Granting the privilege to use a package makes all constructs of the package accessible to the grantee.</p> </li> 
         <li> <p>Declaration of public and private procedures, variables, constants, and cursors</p> <p><a id="sthref3661"></a><a id="sthref3662"></a>The methods of package definition allow you to specify which variables, cursors, and procedures are public and private. Public means that it is directly accessible to the user of a package. Private means that it is hidden from the user of a package.</p> <p>For example, a package can contain 10 procedures. You can define the package so that only three procedures are public and therefore available for execution by a user of the package. The remainder of the procedures are private and can only be accessed by the procedures within the package. Do not confuse public and private package variables with grants to <code>PUBLIC</code>.</p> 
          <div class="infoboxnotealso"> 
           <p class="notep1">See Also:</p> 
           <a href="security.htm#g24279">Chapter 20, "Database Security"</a> for more information about grants to 
           <code>PUBLIC</code>
          </div> </li> 
         <li> <p>Better performance</p> <p><a id="sthref3663"></a>An entire package is loaded into memory when a procedure within the package is called for the first time. This load is completed in one operation, as opposed to the separate loads required for standalone procedures. Therefore, when calls to related packaged procedures occur, no disk I/O is necessary to run the compiled code already in memory.</p> <p><a id="i18898"></a>A package body can be replaced and recompiled without affecting the specification. As a result, schema objects that reference a package's constructs (always through the specification) need not be recompiled unless the package specification is also replaced. By using packages, unnecessary recompilations can be minimized, resulting in less impact on overall database performance.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <div class="sect3">
       <a id="sthref3664"></a> 
       <h4 class="sect3">PL/SQL Collections and Records</h4> 
       <p>Many programming techniques use collection types such as arrays, bags, lists, nested tables, sets, and trees. To support these techniques in database applications, PL/SQL provides the datatypes <code>TABLE</code> and <code>VARRAY</code>, which allow you to declare index-by tables, nested tables, and variable-size arrays.</p> 
       <div class="sect4">
        <a id="sthref3665"></a> 
        <h5 class="sect4">Collections</h5> 
        <p>A collection is an ordered group of elements, all of the same type. Each element has a unique subscript that determines its position in the collection.</p> 
        <p>Collections work like the arrays found in most third-generation programming languages. Also, collections can be passed as parameters. So, you can use them to move columns of data into and out of database tables or between client-side applications and stored subprograms.</p> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <a id="sthref3666"></a> 
        <h5 class="sect4">Records</h5> 
        <p>You can use the <code>%ROWTYPE</code> attribute to declare a record that represents a row in a table or a row fetched from a cursor. But, with a user-defined record, you can declare fields of your own.</p> 
        <p>Records contain uniquely named fields, which can have different datatypes. Suppose you have various data about an employee such as name, salary, and hire date. These items are dissimilar in type but logically related. A record containing a field for each item lets you treat the data as a logical unit.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink LNPLS" href="../../appdev.102/b14261/toc.htm"><span class="italic">Oracle Database PL/SQL User's Guide and Reference</span></a> for detailed information on using collections and records
        </div> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <div class="sect3">
       <a id="sthref3667"></a> 
       <h4 class="sect3">PL/SQL Server <a id="sthref3668"></a>Pages</h4> 
       <p>PL/SQL Server Pages (PSP) are server-side Web pages (in HTML or XML) with embedded PL/SQL scripts marked with special tags. To produce dynamic Web pages, developers have usually written CGI programs in C or Perl that fetch data and produce the entire Web page within the same program. The development and maintenance of such dynamic pages is costly and time-consuming.</p> 
       <p>Scripting <a id="sthref3669"></a>fulfills the demand for rapid development of dynamic Web pages. Small scripts can be embedded in HTML pages without changing their basic HTML identity. The scripts contain the logic to produce the dynamic portions of HTML pages and are run when the pages are requested by the users.</p> 
       <p>The separation of HTML content from application logic makes script pages easier to develop, debug, and maintain. The simpler development model, along the fact that scripting languages usually demand less programming skill, enables Web page writers to develop dynamic Web pages.</p> 
       <p>There are two kinds of embedded scripts in HTML pages: client-side scripts and server-side scripts. <span class="bold">Client-side scripts</span> are returned as part of the HTML page and are run in the browser. They are mainly used for client-side navigation of HTML pages or data validation. <span class="italic"><a id="sthref3670"></a></span><span class="bold">Server-side scripts</span>, while also embedded in the HTML pages, are run on the server side. They fetch and manipulate data and produce HTML content that is returned as part of the page. PSP scripts are server-side scripts.</p> 
       <p>A <a id="sthref3671"></a>PL/SQL gateway receives HTTP requests from an HTTP client, invokes a PL/SQL stored procedure as specified in the URL, and returns the HTTP output to the client. A PL/SQL Server Page is processed by a PSP compiler, which compiles the page into a PL/SQL stored procedure. When the procedure is run by the gateway, it generates the Web page with dynamic content. PSP is built on one of two existing PL/SQL gateways:</p> 
       <ul> 
        <li> <p>PL/SQL cartridge of Oracle Application Server</p> </li> 
        <li> <p>WebDB</p> </li> 
       </ul> 
       <div class="infoboxnotealso"> 
        <p class="notep1">See Also:</p> 
        <a class="olink ADFNS" href="../../appdev.102/b14251/toc.htm"><span class="italic">Oracle Database Application Developer's Guide - Fundamentals</span></a> for more information about PL/SQL Server Pages
       </div> 
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" --> 
     <a id="i7579"></a> 
     <div class="sect2">
      <a id="sthref3672"></a> 
      <h3 class="sect2"><a id="CNCPT616"></a><a id="sthref3673"></a>Overview of Java</h3> 
      <p>Java is an object-oriented programming language efficient for application-level programs. It includes the following features:</p> 
      <ul> 
       <li> <p>A Java Virtual Machine (JVM), which provides the fundamental basis for platform independence</p> </li> 
       <li> <p>Automatic storage management techniques, such as gathering scattered memory into contiguous memory space</p> </li> 
       <li> <p>Language syntax that borrows from C and enforces strong typing</p> </li> 
      </ul> 
      <p>This section contains the following topics:</p> 
      <ul> 
       <li> <p><a href="#i25590">Java and Object-Oriented Programming Terminology</a></p> </li> 
       <li> <p><a href="#i25595">Class Hierarchy</a></p> </li> 
       <li> <p><a href="#i25600">Interfaces</a></p> </li> 
       <li> <p><a href="#i25612">Polymorphism</a></p> </li> 
       <li> <p><a href="#i25622">Overview of the Java Virtual Machine (JVM)</a></p> </li> 
       <li> <p><a href="#i25627">Why Use Java in Oracle?</a></p> </li> 
       <li> <p><a href="#i25632">Oracle's Java Application Strategy</a></p> </li> 
      </ul> 
      <a id="i25590"></a> 
      <div class="sect3">
       <a id="sthref3674"></a> 
       <h4 class="sect3">Java and Object-Oriented Programming Terminology</h4> 
       <p>This section covers some basic terminology of Java application development in the Oracle environment.</p> 
       <div class="sect4">
        <a id="sthref3675"></a> 
        <h5 class="sect4">Clas<a id="sthref3676"></a>ses</h5> 
        <p>All object-oriented programming languages support the concept of a class. As with a table definition, a class provides a template for objects that share common characteristics. Each class can contain the following:</p> 
        <ul> 
         <li> <p><a href="#i21402">Attributes</a>—static or instance variables that each object of a particular class possesses</p> </li> 
         <li> <p><a href="#i21406">Methods</a>—you can invoke methods defined by the class or inherited by any classes extended from the class</p> </li> 
        </ul> 
        <p>When you create an object from a class, you are creating an instance of that class. The instance contains the fields of an object, which are known as its data, or state.</p> 
        <p><a href="#i21426">Figure 24-5</a> shows an example of an <code>Employee</code> class defined with two attributes: last name (<code>lastName</code>) and employee identifier (<code>ID</code>).</p> 
        <div class="figure"> 
         <p class="titleinfigure"><a id="i21426"></a><a id="sthref3677"></a>Figure 24-5 Classes and Instances</p> 
         <img width="536" height="261" src="img/cncpt203.gif" alt="Description of Figure 24-5 follows" title="Description of Figure 24-5 follows">
         <br> 
         <a id="sthref3678" href="img_text/cncpt203.htm">Description of "Figure 24-5 Classes and Instances"</a>
         <br> 
         <br>
        </div> 
        <!-- class="figure" --> 
        <p>When you create an instance, the attributes store individual and private information relevant only to the employee. That is, the information contained within an employee instance is known only for that single employee. The example in <a href="#i21426">Figure 24-5</a> shows two instances of employee—Smith and Jones. Each instance contains information relevant to the individual employee.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i21402"></a> 
       <div class="sect4">
        <a id="sthref3679"></a> 
        <h5 class="sect4">Att<a id="sthref3680"></a>ributes</h5> 
        <p>Attributes within an instance are known as fields. Instance fields are analogous to the fields of a relational table row. The class defines the fields, as well as the type of each field. You can declare fields in Java to be static, public, private, protected, or default access.</p> 
        <ul> 
         <li> <p>Public, private, protected, or default access fields are created within each instance.</p> </li> 
         <li> <p>Static fields are like global variables in that the information is available to all instances of the employee class.</p> </li> 
        </ul> 
        <p>The language specification defines the rules of visibility of data for all fields. Rules of visibility define under what circumstances you can access the data in these fields.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i21406"></a> 
       <div class="sect4">
        <a id="sthref3681"></a> 
        <h5 class="sect4">Meth<a id="sthref3682"></a>ods</h5> 
        <p>The class also defines the methods you can invoke on an instance of that class. Methods are written in Java and define the behavior of an object. This bundling of state and behavior is the essence of encapsulation, which is a feature of all object-oriented programming languages. If you define an <code>Employee</code> class, declaring that each employee's <code>id</code> is a private field, other objects can access that private field only if a method returns the field. In this example, an object could retrieve the employee's identifier by invoking the <code>Employee</code>.<code>getId</code> method.</p> 
        <p>In addition, with encapsulation, you can declare that the <code>Employee</code>.<code>getId</code> method is private, or you can decide not to write an <code>Employee</code>.<code>getId</code> method. Encapsulation helps you write programs that are reusable and not misused. Encapsulation makes public only those features of an object that are declared public; all other fields and methods are private. Private fields and methods can be used for internal object processing.</p> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i25595"></a> 
      <div class="sect3">
       <a id="sthref3683"></a> 
       <h4 class="sect3">Class H<a id="sthref3684"></a>ierarchy</h4> 
       <p>Java defines classes within a large hierarchy of classes. At the top of the hierarchy is the Object class. All classes in Java inherit from the <code>Object</code> class at some level, as you walk up through the inheritance chain of superclasses. When we say Class B inherits from Class A, each instance of Class B contains all the fields defined in class B, as well as all the fields defined in Class A. For example, in <a href="#i21448">Figure 24-6</a>, the <code>FullTimeEmployee</code> class contains the <code>id</code> and <code>lastName</code> fields defined in the <code>Employee</code> class, because it inherits from the Employee class. In addition, the <code>FullTimeEmployee</code> class adds another field, <code>bonus</code>, which is contained only within <code>FullTimeEmployee</code>.</p> 
       <p>You can invoke any method on an instance of Class B that was defined in either Class A or B. In our employee example, the <code>FullTimeEmployee</code> instance can invoke methods defined only within its own class, or methods defined within the <code>Employee</code> class.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i21448"></a><a id="sthref3685"></a>Figure 24-6 Using Inheritance to Localize Behavior and State</p> 
        <img width="530" height="318" src="img/cncpt204.gif" alt="Description of Figure 24-6 follows" title="Description of Figure 24-6 follows">
        <br> 
        <a id="sthref3686" href="img_text/cncpt204.htm">Description of "Figure 24-6 Using Inheritance to Localize Behavior and State"</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" --> 
       <p>Instances of Class B are substitutable for instances of Class A, which makes inheritance another powerful construct of object-oriented languages for improving code reuse. You can create new classes that define behavior and state where it makes sense in the hierarchy, yet make use of pre-existing functionality in class libraries.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i25600"></a> 
      <div class="sect3">
       <a id="sthref3687"></a> 
       <h4 class="sect3">Interfa<a id="sthref3688"></a>ces</h4> 
       <p>Java supports only single inheritance; that is, each class has one and only one class from which it inherits. If you must inherit from more than one source, Java provides the equivalent of multiple inheritance, without the complications and confusion that usually accompany it, through interfaces. Interfaces are similar to classes; however, interfaces define method signatures, not implementations. The methods are implemented in classes declared to implement an interface. Multiple inheritance occurs when a single class simultaneously supports many interfaces.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i25612"></a> 
      <div class="sect3">
       <a id="sthref3689"></a> 
       <h4 class="sect3">Polymorph<a id="sthref3690"></a>ism</h4> 
       <p>Assume in our <code>Employee</code> example that the different types of employees must be able to respond with their compensation to date. Compensation is computed differently for different kinds of employees.</p> 
       <ul> 
        <li> <p><code>FullTimeEmployees</code> are eligible for a bonus</p> </li> 
        <li> <p><code>NonExemptEmployees</code> get overtime pay</p> </li> 
       </ul> 
       <p>In traditional procedural languages, you would write a long switch statement, with the different possible cases defined.</p> 
       <pre>
switch (employee.type) {
case: Employee
return employee.salaryToDate;
case: FullTimeEmployee
return employee.salaryToDate + employee.bonusToDate;
...

</pre> 
       <p>If you add a new kind of employee, then you must update your switch statement. If you modify your data structure, then you must modify all switch statements that use it.</p> 
       <p>In an object-oriented language such as Java, you implement a method, <code>compensationToDate</code>, for each subclass of <code>Employee</code> class that requires any special treatment beyond what is already defined in <code>Employee</code> class. For example, you could implement the <code>compensationToDate</code> method of <code>NonExemptEmployee</code>, as follows:</p> 
       <pre>
private float compensationToDate() {
return super.compensationToDate() + this.overtimeToDate();
}

</pre> 
       <p>Implement <code>FullTimeEmployee</code>'s method as follows:</p> 
       <pre>
private float compensationToDate() {
return super.compensationToDate() + this.bonusToDate();
}

</pre> 
       <p>The common usage of the method name <code>compensationToDate</code> lets you invoke the identical method on different classes and receive different results, without knowing the type of employee you are using. You do not have to write a special method to handle <code>FullTimeEmployees</code> and <code>PartTimeEmployees</code>. This ability for the different objects to respond to the identical message in different ways is known as polymorphism.</p> 
       <p>In addition, you could create an entirely new class that does not inherit from <code>Employee</code> at all—<code>Contractor</code>—and implement a <code>compensationToDate</code> method in it. A program that calculates total payroll to date would iterate over all people on payroll, regardless of whether they were full-time, part-time, or contractors, and add up the values returned from invoking the <code>compensationToDate</code> method on each. You can safely make changes to the individual <code>compensationToDate</code> methods with the knowledge that callers of the methods will work correctly. For example, you can safely add new fields to existing classes.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i25622"></a> 
      <div class="sect3">
       <a id="sthref3691"></a> 
       <h4 class="sect3">Overview of the Java Virtual Machine (JV<a id="sthref3692"></a>M)</h4> 
       <p>As with other high-level computer languages, Java source compiles to low-level instructions. In Java, these instructions are known as bytecodes (because their size is uniformly one byte of storage). Most other languages—such as C—compile to computer-specific instructions, such as instructions specific to an Intel or HP processor. Java source compiles to a standard, platform-independent set of bytecodes, which interacts with a Java Virtual Machine (JVM). The JVM is a separate program that is optimized for the specific platform on which you run your Java code.</p> 
       <p><a href="#i21470">Figure 24-7</a> illustrates how Java can maintain platform independence. Java source is compiled into bytecodes, which are platform independent. Each platform has installed a JVM that is specific to its operating system. The Java bytecodes from your source get interpreted through the JVM into appropriate platform dependent actions.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i21470"></a><a id="sthref3693"></a>Figure 24-7 Java Component Structure</p> 
        <img width="138" height="258" src="img/cncpt205.gif" alt="Description of Figure 24-7 follows" title="Description of Figure 24-7 follows">
        <br> 
        <a id="sthref3694" href="img_text/cncpt205.htm">Description of "Figure 24-7 Java Component Structure"</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" --> 
       <p>When you develop a Java program, you use predefined core class libraries written in the Java language. The Java core class libraries are logically divided into packages that provide commonly-used functionality, such as basic language support (<code>java</code>.<code>lang</code>), I/O (<code>java</code>.<code>io</code>), and network access (<code>java</code>.<code>net</code>). Together, the JVM and core class libraries provide a platform on which Java programmers can develop with the confidence that any hardware and operating system that supports Java will execute their program. This concept is what drives the "write once, run anywhere" idea of Java.</p> 
       <p><a href="#i21492">Figure 24-8</a> illustrates how Oracle's Java applications sit on top of the Java core class libraries, which in turn sit on top of the JVM. Because Oracle's Java support system is located within the database, the JVM interacts with the Oracle database libraries, instead of directly with the operating system.</p> 
       <div class="figure"> 
        <p class="titleinfigure"><a id="i21492"></a><a id="sthref3695"></a>Figure 24-8 Java Component Structure</p> 
        <img width="204" height="387" src="img/cncpt206.gif" alt="Description of Figure 24-8 follows" title="Description of Figure 24-8 follows">
        <br> 
        <a id="sthref3696" href="img_text/cncpt206.htm">Description of "Figure 24-8 Java Component Structure"</a>
        <br> 
        <br>
       </div> 
       <!-- class="figure" --> 
       <p>Sun Microsystems furnishes publicly available specifications for both the Java language and the JVM. The Java Language Specification (JLS) defines things such as syntax and semantics; the JVM specification defines the necessary low-level behavior for the computer that runs the bytecodes. In addition, Sun Microsystems provides a compatibility test suite for JVM implementors to determine if they have complied with the specifications. This test suite is known as the Java Compatibility Kit (JCK). Oracle's JVM implementation complies fully with JCK. Part of the overall Java strategy is that an openly specified standard, together with a simple way to verify compliance with that standard, allows vendors to offer uniform support for Java across all platforms.</p> 
      </div> 
      <!-- class="sect3" --> 
      <a id="i25627"></a> 
      <div class="sect3">
       <a id="sthref3697"></a> 
       <h4 class="sect3">Why Use Java in Oracle?</h4> 
       <p>You can write and load Java applications within the database, because it is a safe language. Java prevents anyone from tampering with the operating system that the Java code resides in. Some languages, such as C, can introduce security problems within the database; Java, because of its design, is a safe language to allow within the database.</p> 
       <p>Although Java presents many advantages to developers, providing an implementation of a JVM that supports Java server applications in a scalable manner is a challenge. This section discusses some of these challenges.</p> 
       <ul> 
        <li> <p><a href="#i20736">Multithreading</a></p> </li> 
        <li> <p><a href="#i21305">Automated Storage Management</a></p> </li> 
        <li> <p><a href="#i20773">Footprint</a></p> </li> 
        <li> <p><a href="#i20783">Performance</a></p> </li> 
        <li> <p><a href="#i20787">Dynamic Class Loading</a></p> </li> 
       </ul> 
       <a id="i20736"></a> 
       <div class="sect4">
        <a id="sthref3698"></a> 
        <h5 class="sect4">Multithreading</h5> 
        <p>Multithreading support is often cited as one of the key scalability features of Java. Certainly, the Java language and class libraries make it simpler to write shared server applications in Java than many other languages, but it is still a daunting task in any language to write reliable, scalable shared server code.</p> 
        <p>As a database server, Oracle efficiently schedules work for thousands of users. The Oracle JVM uses the facilities of the RDBMS server to concurrently schedule Java execution for thousands of users. Although Oracle supports Java language level threads required by the JLS and JCK, using threads within the scope of the database does not increase scalability. Using the embedded scalability of the database eliminates the need for writing shared server Java servers. You should use the database's facilities for scheduling users by writing single-threaded Java applications. The database takes care of the scheduling between each application; thus, you achieve scalability without having to manage threads. You can still write shared server Java applications, but multiple Java threads does not increase your server's performance.</p> 
        <p>One difficulty multithreading imposes on Java is the interaction of threads and automated storage management, or garbage collection. The garbage collector executing in a generic JVM has no knowledge of which Java language threads are executing or how the underlying operating system schedules them.</p> 
        <ul> 
         <li> <p>Non-Oracle model—A single user maps to a single Java language level thread; the same single garbage collector manages all garbage from all users. Different techniques typically deal with allocation and collection of objects of varying lifetimes and sizes. The result in a heavily shared server application is, at best, dependent upon operating system support for native threads, which can be unreliable and limited in scalability. High levels of scalability for such implementations have not been convincingly demonstrated.</p> </li> 
         <li> <p>Oracle JVM model—Even when thousands of users connect to the server and run the same Java code, each user experiences it as if he is executing his own Java code on his own Java Virtual Machine. The responsibility of the Oracle JVM is to make use of operating system processes and threads, using the scalable approach of the Oracle RDBMS. As a result of this approach, the JVM's garbage collector is more reliable and efficient because it never collects garbage from more than one user at any time.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i21305"></a> 
       <div class="sect4">
        <a id="sthref3699"></a> 
        <h5 class="sect4">Automated Storage Management</h5> 
        <p>Garbage collection is a major feature of Java's automated storage management, eliminating the need for Java developers to allocate and free memory explicitly. Consequently, this eliminates a large source of memory leaks that commonly plague C and C++ programs. There is a price for such a benefit: garbage collection contributes to the overhead of program execution speed and footprint. Although many papers have been written qualifying and quantifying the trade-off, the overall cost is reasonable, considering the alternatives.</p> 
        <p>Garbage collection imposes a challenge to the JVM developer seeking to supply a highly scalable and fast Java platform. The Oracle JVM meets these challenges in the following ways:</p> 
        <ul> 
         <li> <p>The Oracle JVM uses the Oracle scheduling facilities, which can manage multiple users efficiently.</p> </li> 
         <li> <p>Garbage collection is performs consistently for multiple users because garbage collection is focused on a single user within a single session. The Oracle JVM enjoys a huge advantage because the burden and complexity of the memory manager's job does not increase as the number of users increases. The memory manager performs the allocation and collection of objects within a single session—which typically translates to the activity of a single user.</p> </li> 
         <li> <p>The Oracle JVM uses different garbage collection techniques depending on the type of memory used. These techniques provide high efficiency and low overhead.</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i20773"></a> 
       <div class="sect4">
        <a id="sthref3700"></a> 
        <h5 class="sect4">Footprint</h5> 
        <p>The footprint of an executing Java program is affected by many factors:</p> 
        <ul> 
         <li> <p>Size of the program itself—how many classes and methods and how much code they contain.</p> </li> 
         <li> <p>Complexity of the program—the amount of core class libraries that the Oracle JVM uses as the program runs, as opposed to the program itself.</p> </li> 
         <li> <p>Amount of state the JVM uses—how many objects the JVM allocates, how large they are, and how many must be retained across calls.</p> </li> 
         <li> <p>Ability of the garbage collector and memory manager to deal with the demands of the executing program, which is often non-deterministic. The speed with which objects are allocated and the way they are held on to by other objects influences the importance of this factor.</p> </li> 
        </ul> 
        <p>From a scalability perspective, the key to supporting many concurrent clients is a minimum user session footprint. The Oracle JVM keeps the user session footprint to a minimum by placing all read-only data for users, such as Java bytecodes, in shared memory. Appropriate garbage collection algorithms are applied against call and session memories to maintain a small footprint for the user's session. The Oracle JVM uses three types of garbage collection algorithms to maintain the user's session memory:</p> 
        <ul> 
         <li> <p>Generational scavenging for short-lived objects</p> </li> 
         <li> <p>Mark and lazy sweep collection for objects that exist for the life of a single call</p> </li> 
         <li> <p>Copying collector for long-lived objects—objects that live across calls within a session</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i20783"></a> 
       <div class="sect4">
        <a id="sthref3701"></a> 
        <h5 class="sect4">Performance</h5> 
        <p>Oracle JVM performance is enhanced by implementing a native compiler. Java runs platform-independent bytecodes on top of a JVM, which in turn interacts with the specific hardware platform. Any time you add levels within software, your performance is degraded. Because Java requires going through an intermediary to interpret platform-independent bytecodes, a degree of inefficiency exists for Java applications that does not exists within a platform-dependent language, such as C. To address this issue, several JVM suppliers create native compilers. Native compilers translate Java bytecodes into platform-dependent native code, which eliminates the interpreter step and improves performance.</p> 
        <p>The following table describes two methods for native compilation.</p> 
        <div class="inftblinformal"> 
         <table class="cellalignment2313" title="Native Compilation Methods" summary="Native Compilation Methods" dir="ltr"> 
          <thead> 
           <tr class="cellalignment2307"> 
            <th class="cellalignment2314" id="r1c1-t33">Native Compilation Method</th> 
            <th class="cellalignment2314" id="r1c2-t33">Description</th> 
           </tr> 
          </thead> 
          <tbody> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r2c1-t33" headers="r1c1-t33">Just-In-Time (JIT) Compilation</td> 
            <td class="cellalignment2315" headers="r2c1-t33 r1c2-t33">JIT compilers quickly compile Java bytecodes to native (platform-specific) computer code during runtime. This does not produce an executable to be run on the platform; instead, it provides platform-dependent code from Java bytecodes that is run directly after it is translated. This should be used for Java code that is run frequently, which will be run at speeds closer to languages such as C.</td> 
           </tr> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r3c1-t33" headers="r1c1-t33">Static Compilation</td> 
            <td class="cellalignment2315" headers="r3c1-t33 r1c2-t33">Static compilation translates Java bytecodes to platform-independent C code before runtime. Then a standard C compiler compiles the C code into an executable for the target platform. This approach is more suitable for Java applications that are modified infrequently. This approach takes advantage of the mature and efficient platform-specific compilation technology found in modern C compilers.</td> 
           </tr> 
          </tbody> 
         </table> 
         <br>
        </div> 
        <!-- class="inftblinformal --> 
        <p>Oracle uses static compilation to deliver its core Java class libraries: the ORB and JDBC code in natively compiled form. It is applicable across all the platforms Oracle supports, whereas a JIT approach requires low-level, processor-dependent code to be written and maintained for each platform. You can use this native compilation technology with your own Java code.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i20787"></a> 
       <div class="sect4">
        <a id="sthref3702"></a> 
        <h5 class="sect4">Dynamic Class Loading</h5> 
        <p>Another strong feature of Java is dynamic class loading. The class loader loads classes from the disk (and places them in the JVM-specific memory structures necessary for interpretation) only as they are used during program execution. The class loader locates the classes in the <code>CLASSPATH</code> and loads them during program execution. This approach, which works well for applets, poses the following problems in a server environment:</p> 
        <div class="inftblinformal"> 
         <table class="cellalignment2313" title="Dynamic Class Loading" summary="Dynamic Class Loading" dir="ltr"> 
          <thead> 
           <tr class="cellalignment2307"> 
            <th class="cellalignment2314" id="r1c1-t34">Problem</th> 
            <th class="cellalignment2314" id="r1c2-t34">Description</th> 
            <th class="cellalignment2314" id="r1c3-t34">Solution</th> 
           </tr> 
          </thead> 
          <tbody> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r2c1-t34" headers="r1c1-t34">Predictability</td> 
            <td class="cellalignment2315" headers="r2c1-t34 r1c2-t34">The class loading operation places a severe penalty on first-time execution. A simple program can cause the Oracle JVM to load many core classes to support its needs. A programmer cannot easily predict or determine the number of classes loaded.</td> 
            <td class="cellalignment2315" headers="r2c1-t34 r1c3-t34">The Oracle JVM loads classes dynamically, just as with any other Java Virtual Machine. The same one-time class loading speed hit is encountered. However, because the classes are loaded into shared memory, no other users of those classes will cause the classes to load again—they will simply use the same pre-loaded classes.</td> 
           </tr> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r3c1-t34" headers="r1c1-t34">Reliability</td> 
            <td class="cellalignment2315" headers="r3c1-t34 r1c2-t34">A benefit of dynamic class loading is that it supports program updating. For example, you would update classes on a server, and clients who download the program and load it dynamically see the update whenever they next use the program. Server programs tend to emphasize reliability. As a developer, you must know that every client runs a specific program configuration. You do not want clients to inadvertently load some classes that you did not intend them to load.</td> 
            <td class="cellalignment2315" headers="r3c1-t34 r1c3-t34">Oracle separates the upload and resolve operation from the class loading operation at runtime. You upload Java code you developed to the server using the loadjava utility. Instead of using <code>CLASSPATH</code>, you specify a resolver at installation time. The resolver is analogous to <code>CLASSPATH</code>, but lets you specify the schemas in which the classes reside. This separation of resolution from class loading means you always know what program users run.</td> 
           </tr> 
          </tbody> 
         </table> 
         <br>
        </div> 
        <!-- class="inftblinformal -->
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" --> 
      <a id="i25632"></a> 
      <div class="sect3">
       <a id="sthref3703"></a> 
       <h4 class="sect3">Oracle's Java Application Strategy</h4> 
       <p>One appeal of Java is its ubiquity and the growing number of programmers capable of developing applications using it. Oracle furnishes enterprise application developers with an end-to-end Java solution for creating, deploying, and managing Java applications. The total solution consists of client-side and server-side programmatic interfaces, tools to support Java development, and a Java Virtual Machine integrated with the Oracle database server. All these products are compatible with Java standards.</p> 
       <p>In addition to the Oracle JVM, the Java programming environment consists of the following:</p> 
       <ul> 
        <li> <p>Java stored procedures as the Java equivalent and companion for PL/SQL. Java stored procedures are tightly integrated with PL/SQL. You can call a Java stored procedure from a PL/SQL package; you can call PL/SQL procedures from a Java stored procedure.</p> </li> 
        <li> <p>SQL data can be accessed through the JDBC programming interface.</p> </li> 
        <li> <p>Tools and scripts used in assisting in development, class loading, and class management.</p> </li> 
       </ul> 
       <p>This section contains the following topics:</p> 
       <ul> 
        <li> <p><a href="#i25662">Java Stored Procedures</a></p> </li> 
        <li> <p><a href="#i25667">PL/SQL Integration and Oracle Functionality</a></p> </li> 
        <li> <p><a href="#i21144">JDBC</a></p> </li> 
        <li> <p><a href="#i25637">JPublisher</a></p> </li> 
        <li> <p><a href="#i24799">Java Messaging Service</a></p> </li> 
       </ul> 
       <a id="i25662"></a> 
       <div class="sect4">
        <a id="sthref3704"></a> 
        <h5 class="sect4">Java Stored Procedures</h5> 
        <p>A Java stored p<a id="sthref3705"></a>rocedure is a program you write in Java to run in the server, exactly as a PL/SQL stored procedure. You invoke it directly with products like SQL*Plus, or indirectly with a trigger. You can access it from any Oracle Net client—OCI, precompiler, or JDBC.</p> 
        <p>In addition, you can use Java to develop powerful programs independently of PL/SQL. Oracle provides a fully-compliant implementation of the Java programming language and JVM.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink JJDEV" href="../../java.102/b14187/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a> explains how to write stored procedures in Java, how to access them from PL/SQL, and how to access PL/SQL functionality from Java.
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i25667"></a> 
       <div class="sect4">
        <a id="sthref3706"></a> 
        <h5 class="sect4">PL/SQL Integration and Oracle Functionality</h5> 
        <p>You can invoke existing PL/SQL programs from Java and invoke Java programs from PL/SQL. This solution protects and leverages your existing investment while opening up the advantages and opportunities of Java-based Internet computing.</p> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i21144"></a> 
       <div class="sect4">
        <a id="sthref3707"></a> 
        <h5 class="sect4">JDBC</h5> 
        <p>Java database connectivity (JDB<a id="sthref3708"></a>C) is an application programming interface (API) for Java developers to access SQL data. It is available on client and server, so you can deploy the same code in either place.</p> 
        <p>Oracle's JDBC allows access to objects and collection types defined in the database from Java programs through dynamic SQL. Dynamic SQL means that the embedded SQL statement to be run is not known before the application is run, and requires input to build the statement. It provides for translation of types defined in the database into Java classes through default or customizable mappings, and it also enables you to monitor, trace, and correlate resource consumption of Java and J2EE applications down to the database operation level.</p> 
        <p>Core Java class libraries provide only one JDBC API. JDBC is designed, however, to allow vendors to supply drivers that offer the necessary specialization for a particular database. Oracle delivers the following three distinct JDBC drivers.</p> 
        <div class="inftblinformal"> 
         <table class="cellalignment2313" title="Drivers" summary="Drivers" dir="ltr"> 
          <thead> 
           <tr class="cellalignment2307"> 
            <th class="cellalignment2314" id="r1c1-t36">Driver</th> 
            <th class="cellalignment2314" id="r1c2-t36">Description</th> 
           </tr> 
          </thead> 
          <tbody> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r2c1-t36" headers="r1c1-t36">JDBC Thin Driver</td> 
            <td class="cellalignment2315" headers="r2c1-t36 r1c2-t36">You can use the JDBC Thin driver to write 100% pure Java applications and applets that access Oracle SQL data. The JDBC Thin driver is especially well-suited to Web browser-based applications and applets, because you can dynamically download it from a Web page just like any other Java applet.</td> 
           </tr> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r3c1-t36" headers="r1c1-t36">JDBC Oracle Call Interface Driver</td> 
            <td class="cellalignment2315" headers="r3c1-t36 r1c2-t36">The JDBC Oracle Call Interface (OCI) driver accesses Oracle-specific native code (that is, non-Java) libraries on the client or middle tier, providing a richer set of functionality and some performance boost compared to the JDBC Thin driver, at the cost of significantly larger size and client-side installation.</td> 
           </tr> 
           <tr class="cellalignment2307"> 
            <td class="cellalignment2315" id="r4c1-t36" headers="r1c1-t36">JDBC Server-side Internal Driver</td> 
            <td class="cellalignment2315" headers="r4c1-t36 r1c2-t36">Oracle uses the server-side internal driver when Java code runs on the server. It allows Java applications running in the server's JVM to access locally defined data (that is, on the same computer and in the same process) with JDBC. It provides a further performance boost because of its ability to use underlying Oracle RDBMS libraries directly, without the overhead of an intervening network connection between your Java code and SQL data. By supporting the same Java-SQL interface on the server, Oracle does not require you to rework code when deploying it.</td> 
           </tr> 
          </tbody> 
         </table> 
         <br>
        </div> 
        <!-- class="inftblinformal --> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <ul> 
          <li> <p><a class="olink JJDBC" href="../../java.102/b14355/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a></p> </li> 
          <li> <p><a class="olink ADFNS" href="../../appdev.102/b14251/toc.htm"><span class="italic">Oracle Database Application Developer's Guide - Fundamentals</span></a> for examples of JDBC programs</p> </li> 
         </ul> 
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <div class="sect4">
        <!-- infolevel="all" infotype="General" -->
        <a id="sthref3709"></a> 
        <h5 class="sect4">SQLJ</h5> 
        <p>SQL<a id="sthref3710"></a>J allows developers to use object datatypes in Java programs. Developers can use JPublisher to map Oracle object and collection types into Java classes to be used in the application.</p> 
        <p>SQLJ provides access to server objects using SQL statements embedded in the Java code. SQLJ provides compile-time type checking of object types and collections in the SQL statements. The syntax is based on an ANSI standard (SQLJ Consortium).</p> 
        <p>You can specify Java classes as SQL user-defined o<a id="sthref3711"></a>bject types. You can define columns or rows of this SQLJ type. You can also query and manipulate the objects of this type as if they were SQL primitive types. Additionally, you can do the following:</p> 
        <ul> 
         <li> <p>Make the static fields of a class visible in SQL</p> </li> 
         <li> <p>Allow the user to call a Java constructor</p> </li> 
         <li> <p>Maintain the dependency between the Java class and its corresponding type</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i25637"></a> 
       <div class="sect4">
        <a id="sthref3712"></a> 
        <h5 class="sect4">JPublisher</h5> 
        <p>Java Publisher (JPublisher) is a utility, written entirely in Java, that generates Java classes to represent the following user-defined database entities in your Java program:</p> 
        <ul> 
         <li> <p>SQL object types</p> </li> 
         <li> <p>Object reference types ("REF types")</p> </li> 
         <li> <p>SQL collection types (VARRAY types or nested table types)</p> </li> 
         <li> <p>PL/SQL packages</p> </li> 
        </ul> 
        <p>JPublisher lets you to specify and customize the mapping of these entities to Java classes in a strongly typed paradigm.</p> 
        <div class="infoboxnotealso"> 
         <p class="notep1">See Also:</p> 
         <a class="olink JJPUB" href="../../java.102/b14188/toc.htm"><span class="italic">Oracle Database JPublisher User's Guide</span></a>
        </div> 
       </div> 
       <!-- class="sect4" --> 
       <a id="i24799"></a> 
       <div class="sect4">
        <a id="sthref3713"></a> 
        <h5 class="sect4">Java Messaging Service</h5> 
        <p>Java Messa<a id="sthref3714"></a>ging Service (JMS) is a messaging standard developed by Sun Microsystems along with Oracle, IBM, and other vendors. It defines a set of interfaces for JMS applications and specifies the behavior implemented by JMS providers. JMS provides a standard-based API to enable asynchronous exchange of business events within the enterprise, as well as with customers and partners. JMS facilitates reliable communication between loosely coupled components in a distributed environment, significantly simplifying the effort required for enterprise integration. The combination of Java technology with enterprise messaging enables development of portable applications.</p> 
        <p>Oracle Java Messaging Service is a Java API for Oracle Streams, based on the JMS standard. Multiple client applications can send and receive messages of any type through a central JMS provider (Oracle Streams). The JMS client consists of the Java application as well as a messaging client runtime library that implements the JMS interface and communicates with Oracle Streams.</p> 
        <p>Java Messaging Oracle JMS supports the standard JMS interfaces and has extensions to support other Streams features that are not a part of the standard. It can be used to enqueue and dequeue messages in the queue available with Oracle Streams. Oracle JMS includes the standard JMS features:</p> 
        <ul> 
         <li> <p>Point-to-point communication using queues</p> </li> 
         <li> <p>Publish-subscribe communication using topics</p> </li> 
         <li> <p>Synchronous and asynchronous message exchange</p> </li> 
         <li> <p>Subject-based routing</p> </li> 
        </ul> 
        <p>Oracle Streams also provides extensions to the standard JMS features:</p> 
        <ul> 
         <li> <p>Point-to-multipoint communication using a recipient list for specifying the applications to receive the messages</p> </li> 
         <li> <p>Administrative API to create the queue tables, queues and subjects</p> </li> 
         <li> <p>Automatic propagation of messages between queues on different databases, enabling the application to define remote subscribers</p> </li> 
         <li> <p>Transacted session support, allowing both JMS and SQL operations in one transaction</p> </li> 
         <li> <p>Message retention after message is consumed</p> </li> 
         <li> <p>Exception handling</p> </li> 
         <li> <p>Delay specification before a message is visible</p> </li> 
        </ul> 
       </div> 
       <!-- class="sect4" -->
      </div> 
      <!-- class="sect3" -->
     </div> 
     <!-- class="sect2" -->
    </div> 
    <!-- class="sect1" -->
   </div> 
   <!-- Start Footer --> 
  </div> 
  <!-- add extra wrapper close div--> 
  <footer>
   <!--
<hr />
<table class="cellalignment2306">
<tr>
<td class="cellalignment2315">
<table class="cellalignment2311">
<tr>
<td class="cellalignment2310"><a href="integrat.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2310"><a href="data_access.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1993, 2005,&nbsp;Oracle.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2318">
<table class="cellalignment2309">
<tr>
<td class="cellalignment2310"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2310"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2310"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2310"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2310"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2310"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
-->
  </footer> 
  <noscript> 
   <p>Scripting on this page enhances content navigation, but does not change the content in any way.</p> 
  </noscript>   
 </body>
</html>