<!doctype html>
<html lang="en">
 <head>
  <title>Documentation</title>
  <meta charset="utf-8">
  <meta name="author" text="Passport">
  <meta name="description" content="Simple, unobtrusive authentication for Node.js">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="canonical" href="http://passportjs.org/docs">
  <meta name="msapplication-TileColor" content="#35DF79">
  <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
  <meta name="theme-color" content="#35DF79">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@passportjs">
  <meta name="twitter:creator" content="@jaredhanson">
  <meta name="twitter:title" content="Passport">
  <meta name="twitter:description" content="Simple, unobtrusive authentication for Node.js">
  <meta name="twitter:image" content="http://passportjs.org/images/twitter-card.png">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Passport">
  <meta property="og:description" content="Simple, unobtrusive authentication for Node.js">
  <meta property="og:locale" content="en_US">
  <meta property="og:url" content="http://passportjs.org/docs">
  <meta property="og:image" content="http://passportjs.org/images/facebook-card.png">
  <meta property="og:image:type" content="image/png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <link type="text/css" rel="stylesheet" href="http://fast.fonts.net/cssapi/7527d73a-ebfe-45db-a201-ff2812df4b18.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
  <link rel="stylesheet" href="/stylesheets/app.css">
  <link rel="stylesheet" href="/stylesheets/ads.css">
  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/images/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/images/favicon/manifest.json">
 </head>
 <body>
  <div id="top" class="main-hold">
   <div class="top-site">
    <div class="search">
     <form action="#">
      <button type="submit"></button>
      <input type="text" placeholder="Search for Strategies">
     </form>
    </div>
    <div class="social">
     <ul>
      <li class="twitter"><a href="http://twitter.com/passportjs" target="_blank"></a></li>
      <li class="git"><a href="http://github.com/jaredhanson/passport" target="_blank"><span class="stat">0</span></a></li>
     </ul>
    </div>
   </div>
   <nav id="menu">
    <a id="logo" href="/" title="JH" data-pjax="/" class="logo"></a>
    <a href="http://twitter.com/jaredhanson" target="_blank" class="jared">by Jared Hanson</a>
    <div class="menu-trigger">
     <span></span>
    </div>
    <div class="menu-hold">
     <ul>
      <li><a href="/" data-pjax="/">Home</a></li>
      <li class="active"><a href="/docs" data-pjax="/docs">Documentation</a></li>
      <li><a href="/features" data-pjax="/features">Features</a></li>
      <li><a href="/" data-search="">Strategies</a></li>
     </ul>
     <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=passportjsorg" id="_carbonads_js"></script>
    </div>
    <a href="http://auth0.com" target="_blank" class="supported">Supported by<i class="auth0"></i></a>
   </nav>
   <div id="page-content" class="content">
    <div class="entry">
     <div class="sub-menu">
      <nav data-accordion-group="">
       <div data-accordion="" class="accordion">
        <h5 data-control=""><i class="icon-budicon-461"></i><a href="/docs/overview"></a>General</h5>
        <ul data-content="">
         <li><a href="/docs/overview" class="active">Overview</a></li>
         <li><a href="/docs/authenticate">Authenticate</a></li>
         <li><a href="/docs/configure">Configure</a></li>
         <li><a href="/docs/username-password">Username &amp; Password</a></li>
         <li><a href="/docs/openid">OpenID</a></li>
         <li><a href="/docs/oauth">OAuth</a></li>
         <li><a href="/docs/profile">User Profile</a></li>
        </ul>
       </div>
       <div data-accordion="" class="accordion">
        <h5 data-control=""><i class="icon-budicon-461"></i><a href="/docs/facebook"></a>Providers</h5>
        <ul data-content="">
         <li><a href="/docs/facebook">Facebook</a></li>
         <li><a href="/docs/twitter">Twitter</a></li>
         <li><a href="/docs/google">Google</a></li>
         <li><a href="/" data-search="">Other</a></li>
        </ul>
       </div>
       <div data-accordion="" class="accordion">
        <h5 data-control=""><i class="icon-budicon-461"></i><a href="/docs/basic-digest"></a>APIs</h5>
        <ul data-content="">
         <li><a href="/docs/basic-digest">Basic &amp; Digest</a></li>
         <li><a href="/docs/oauth-api">OAuth</a></li>
         <li><a href="/docs/oauth2-api">OAuth 2.0</a></li>
         <li><a href="/docs/other-api">Other</a></li>
        </ul>
       </div>
       <div data-accordion="" class="accordion">
        <h5 data-control=""><i class="icon-budicon-461"></i><a href="/docs/login"></a>Operations</h5>
        <ul data-content="">
         <li><a href="/docs/login">Log In</a></li>
         <li><a href="/docs/logout">Log Out</a></li>
         <li><a href="/docs/authorize">Authorize</a></li>
        </ul>
       </div>
      </nav>
     </div>
     <a href="#top" class="go-top"><i class="icon-budicon-462"></i></a>
     <div class="guides">
      <section id="overview">
       <h1 id="overview">Overview</h1> 
       <p>Passport is authentication middleware for <a href="http://nodejs.org/">Node</a>. It is designed to serve a singular purpose: authenticate requests. When writing modules, encapsulation is a virtue, so Passport delegates all other functionality to the application. This separation of concerns keeps code clean and maintainable, and makes Passport extremely easy to integrate into an application.</p> 
       <p>In modern web applications, authentication can take a variety of forms. Traditionally, users log in by providing a username and password. With the rise of social networking, single sign-on using an <a href="http://oauth.net/">OAuth</a> provider such as <a href="https://www.facebook.com/">Facebook</a> or <a href="https://twitter.com/">Twitter</a> has become a popular authentication method. Services that expose an API often require token-based credentials to protect access.</p> 
       <p>Passport recognizes that each application has unique authentication requirements. Authentication mechanisms, known as <em>strategies</em>, are packaged as individual modules. Applications can choose which strategies to employ, without creating unnecessary dependencies.</p> 
       <p>Despite the complexities involved in authentication, code does not have to be complicated.</p> 
       <pre><code class="lang-javascript">app.post('/login', passport.authenticate('local', { successRedirect: '/',
                                                    failureRedirect: '/login' }));
</code></pre> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport
</code></pre> 
      </section>
      <section id="authenticate">
       <h1 id="authenticate">Authenticate</h1> 
       <p>Authenticating requests is as simple as calling <code>passport.authenticate()</code> and specifying which strategy to employ. <code>authenticate()</code>'s function signature is standard <a href="http://www.senchalabs.org/connect/">Connect</a> middleware, which makes it convenient to use as route middleware in <a href="http://expressjs.com/">Express</a> applications.</p> 
       <pre><code class="lang-javascript">app.post('/login',
  passport.authenticate('local'),
  function(req, res) {
    // If this function gets called, authentication was successful.
    // `req.user` contains the authenticated user.
    res.redirect('/users/' + req.user.username);
  });
</code></pre> 
       <p>By default, if authentication fails, Passport will respond with a <code>401 Unauthorized</code> status, and any additional route handlers will not be invoked. If authentication succeeds, the next handler will be invoked and the <code>req.user</code> property will be set to the authenticated user.</p> 
       <p>Note: Strategies must be configured prior to using them in a route. Continue reading the chapter on <a href="/guide/configure/">configuration</a> for details.</p> 
       <h2 id="redirects">Redirects</h2> 
       <p>A redirect is commonly issued after authenticating a request.</p> 
       <pre><code class="lang-javascript">app.post('/login',
  passport.authenticate('local', { successRedirect: '/',
                                   failureRedirect: '/login' }));
</code></pre> 
       <p>In this case, the redirect options override the default behavior. Upon successful authentication, the user will be redirected to the home page. If authentication fails, the user will be redirected back to the login page for another attempt.</p> 
       <h2 id="flash-messages">Flash Messages</h2> 
       <p>Redirects are often combined with flash messages in order to display status information to the user.</p> 
       <pre><code class="lang-javascript">app.post('/login',
  passport.authenticate('local', { successRedirect: '/',
                                   failureRedirect: '/login',
                                   failureFlash: true })
);
</code></pre> 
       <p>Setting the <code>failureFlash</code> option to <code>true</code> instructs Passport to flash an <code>error</code> message using the message given by the strategy's verify callback, if any. This is often the best approach, because the verify callback can make the most accurate determination of why authentication failed.</p> 
       <p>Alternatively, the flash message can be set specifically.</p> 
       <pre><code class="lang-javascript">passport.authenticate('local', { failureFlash: 'Invalid username or password.' });
</code></pre> 
       <p>A <code>successFlash</code> option is available which flashes a <code>success</code> message when authentication succeeds.</p> 
       <pre><code class="lang-javascript">passport.authenticate('local', { successFlash: 'Welcome!' });
</code></pre> 
       <p>Note: Using flash messages requires a <code>req.flash()</code> function. Express 2.x provided this functionality, however it was removed from Express 3.x. Use of <a href="https://github.com/jaredhanson/connect-flash">connect-flash</a> middleware is recommended to provide this functionality when using Express 3.x.</p> 
       <h2 id="disable-sessions">Disable Sessions</h2> 
       <p>After successful authentication, Passport will establish a persistent login session. This is useful for the common scenario of users accessing a web application via a browser. However, in some cases, session support is not necessary. For example, API servers typically require credentials to be supplied with each request. When this is the case, session support can be safely disabled by setting the <code>session</code> option to <code>false</code>.</p> 
       <pre><code class="lang-javascript">app.get('/api/users/me',
  passport.authenticate('basic', { session: false }),
  function(req, res) {
    res.json({ id: req.user.id, username: req.user.username });
  });
</code></pre> 
       <h2 id="custom-callback">Custom Callback</h2> 
       <p>If the built-in options are not sufficient for handling an authentication request, a custom callback can be provided to allow the application to handle success or failure.</p> 
       <pre><code class="lang-javascript">app.get('/login', function(req, res, next) {
  passport.authenticate('local', function(err, user, info) {
    if (err) { return next(err); }
    if (!user) { return res.redirect('/login'); }
    req.logIn(user, function(err) {
      if (err) { return next(err); }
      return res.redirect('/users/' + user.username);
    });
  })(req, res, next);
});
</code></pre> 
       <p>In this example, note that <code>authenticate()</code> is called from within the route handler, rather than being used as route middleware. This gives the callback access to the <code>req</code> and <code>res</code> objects through closure.</p> 
       <p>If authentication failed, <code>user</code> will be set to <code>false</code>. If an exception occurred, <code>err</code> will be set. An optional <code>info</code> argument will be passed, containing additional details provided by the strategy's verify callback.</p> 
       <p>The callback can use the arguments supplied to handle the authentication result as desired. Note that when using a custom callback, it becomes the application's responsibility to establish a session (by calling <code>req.login()</code>) and send a response.</p> 
      </section>
      <section id="configure">
       <h1 id="configure">Configure</h1> 
       <p>Three pieces need to be configured to use Passport for authentication:</p> 
       <ol> 
        <li>Authentication strategies</li> 
        <li>Application middleware</li> 
        <li>Sessions (<em>optional</em>)</li> 
       </ol> 
       <h2 id="strategies">Strategies</h2> 
       <p>Passport uses what are termed <em>strategies</em> to authenticate requests. Strategies range from verifying a username and password, delegated authentication using <a href="http://oauth.net/">OAuth</a> or federated authentication using <a href="http://openid.net/">OpenID</a>.</p> 
       <p>Before asking Passport to authenticate a request, the strategy (or strategies) used by an application must be configured.</p> 
       <p>Strategies, and their configuration, are supplied via the <code>use()</code> function. For example, the following uses the <code>LocalStrategy</code> for username/password authentication.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , LocalStrategy = require('passport-local').Strategy;

passport.use(new LocalStrategy(
  function(username, password, done) {
    User.findOne({ username: username }, function (err, user) {
      if (err) { return done(err); }
      if (!user) {
        return done(null, false, { message: 'Incorrect username.' });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: 'Incorrect password.' });
      }
      return done(null, user);
    });
  }
));
</code></pre> 
       <h2 id="verify-callback">Verify Callback</h2> 
       <p>This example introduces an important concept. Strategies require what is known as a <em>verify callback</em>. The purpose of a verify callback is to find the user that possesses a set of credentials.</p> 
       <p>When Passport authenticates a request, it parses the credentials contained in the request. It then invokes the verify callback with those credentials as arguments, in this case <code>username</code> and <code>password</code>. If the credentials are valid, the verify callback invokes <code>done</code> to supply Passport with the user that authenticated.</p> 
       <pre><code class="lang-javascript">return done(null, user);
</code></pre> 
       <p>If the credentials are not valid (for example, if the password is incorrect), <code>done</code> should be invoked with <code>false</code> instead of a user to indicate an authentication failure.</p> 
       <pre><code class="lang-javascript">return done(null, false);
</code></pre> 
       <p>An additional info message can be supplied to indicate the reason for the failure. This is useful for displaying a flash message prompting the user to try again.</p> 
       <pre><code class="lang-javascript">return done(null, false, { message: 'Incorrect password.' });
</code></pre> 
       <p>Finally, if an exception occurred while verifying the credentials (for example, if the database is not available), <code>done</code> should be invoked with an error, in conventional Node style.</p> 
       <pre><code class="lang-javascript">return done(err);
</code></pre> 
       <p>Note that it is important to distinguish the two failure cases that can occur. The latter is a server exception, in which <code>err</code> is set to a non-<code>null</code> value. Authentication failures are natural conditions, in which the server is operating normally. Ensure that <code>err</code> remains <code>null</code>, and use the final argument to pass additional details.</p> 
       <p>By delegating in this manner, the verify callback keeps Passport database agnostic. Applications are free to choose how user information is stored, without any assumptions imposed by the authentication layer.</p> 
       <h4 id="middleware">Middleware</h4> 
       <p>In a <a href="http://senchalabs.github.com/connect/">Connect</a> or <a href="http://expressjs.com/">Express</a>-based application, <code>passport.initialize()</code> middleware is required to initialize Passport. If your application uses persistent login sessions, <code>passport.session()</code> middleware must also be used.</p> 
       <pre><code class="lang-javascript">app.configure(function() {
  app.use(express.static('public'));
  app.use(express.cookieParser());
  app.use(express.bodyParser());
  app.use(express.session({ secret: 'keyboard cat' }));
  app.use(passport.initialize());
  app.use(passport.session());
  app.use(app.router);
});
</code></pre> 
       <p>Note that enabling session support is entirely optional, though it is recommended for most applications. If enabled, be sure to use <code>session()</code> <em>before</em> <code>passport.session()</code> to ensure that the login session is restored in the correct order.</p> 
       <p>In Express 4.x, the Connect middleware is no longer included in the Express core, and the app.configure() method has been removed. The same middleware can be found in their npm module equivalents.</p> 
       <pre><code class="lang-javascript">var session = require("express-session"),
    bodyParser = require("body-parser");

app.use(express.static("public"));
app.use(session({ secret: "cats" }));
app.use(bodyParser.urlencoded({ extended: false }));
app.use(passport.initialize());
app.use(passport.session());
</code></pre> 
       <h4 id="sessions">Sessions</h4> 
       <p>In a typical web application, the credentials used to authenticate a user will only be transmitted during the login request. If authentication succeeds, a session will be established and maintained via a cookie set in the user's browser.</p> 
       <p>Each subsequent request will not contain credentials, but rather the unique cookie that identifies the session. In order to support login sessions, Passport will serialize and deserialize <code>user</code> instances to and from the session.</p> 
       <pre><code class="lang-javascript">passport.serializeUser(function(user, done) {
  done(null, user.id);
});

passport.deserializeUser(function(id, done) {
  User.findById(id, function(err, user) {
    done(err, user);
  });
});
</code></pre> 
       <p>In this example, only the user ID is serialized to the session, keeping the amount of data stored within the session small. When subsequent requests are received, this ID is used to find the user, which will be restored to <code>req.user</code>.</p> 
       <p>The serialization and deserialization logic is supplied by the application, allowing the application to choose an appropriate database and/or object mapper, without imposition by the authentication layer.</p> 
      </section>
      <section id="username-password">
       <h1 id="username-password">Username &amp; Password</h1> 
       <p>The most widely used way for websites to authenticate users is via a username and password. Support for this mechanism is provided by the <a href="https://github.com/jaredhanson/passport-local">passport-local</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-local
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , LocalStrategy = require('passport-local').Strategy;

passport.use(new LocalStrategy(
  function(username, password, done) {
    User.findOne({ username: username }, function(err, user) {
      if (err) { return done(err); }
      if (!user) {
        return done(null, false, { message: 'Incorrect username.' });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: 'Incorrect password.' });
      }
      return done(null, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for local authentication accepts <code>username</code> and <code>password</code> arguments, which are submitted to the application via a login form.</p> 
       <h2 id="form">Form</h2> 
       <p>A form is placed on a web page, allowing the user to enter their credentials and log in.</p> 
       <pre><code class="lang-xml">&lt;form action="/login" method="post"&gt;
    &lt;div&gt;
        &lt;label&gt;Username:&lt;/label&gt;
        &lt;input type="text" name="username"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;Password:&lt;/label&gt;
        &lt;input type="password" name="password"/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type="submit" value="Log In"/&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre> 
       <h2 id="route">Route</h2> 
       <p>The login form is submitted to the server via the <code>POST</code> method. Using <code>authenticate()</code> with the <code>local</code> strategy will handle the login request.</p> 
       <pre><code class="lang-javascript">app.post('/login',
  passport.authenticate('local', { successRedirect: '/',
                                   failureRedirect: '/login',
                                   failureFlash: true })
);
</code></pre> 
       <p>Setting the <code>failureFlash</code> option to <code>true</code> instructs Passport to flash an <code>error</code> message using the <code>message</code> option set by the verify callback above. This is helpful when prompting the user to try again.</p> 
       <h2 id="parameters">Parameters</h2> 
       <p>By default, <code>LocalStrategy</code> expects to find credentials in parameters named <code>username</code> and <code>password</code>. If your site prefers to name these fields differently, options are available to change the defaults.</p> 
       <pre><code>passport.use(new LocalStrategy({
    usernameField: 'email',
    passwordField: 'passwd'
  },
  function(username, password, done) {
    // ...
  }
));
</code></pre>
      </section>
      <section id="openid">
       <h1 id="openid">OpenID</h1> 
       <p><a href="http://openid.net/">OpenID</a> is an open standard for federated authentication. When visiting a website, users present their OpenID to sign in. The user then authenticates with their chosen OpenID provider, which issues an assertion to confirm the user's identity. The website verifies this assertion in order to sign the user in.</p> 
       <p>Support for OpenID is provided by the <a href="https://github.com/jaredhanson/passport-openid">passport-openid</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-openid
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <p>When using OpenID, a return URL and realm must be specified. The <code>returnURL</code> is the URL to which the user will be redirected after authenticating with their OpenID provider. <code>realm</code> indicates the part of URL-space for which authentication is valid. Typically this will be the root URL of the website.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , OpenIDStrategy = require('passport-openid').Strategy;

passport.use(new OpenIDStrategy({
    returnURL: 'http://www.example.com/auth/openid/return',
    realm: 'http://www.example.com/'
  },
  function(identifier, done) {
    User.findOrCreate({ openId: identifier }, function(err, user) {
      done(err, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for OpenID authentication accepts an <code>identifier</code> argument containing the user's claimed identifier.</p> 
       <h2 id="form">Form</h2> 
       <p>A form is placed on a web page, allowing the user to enter their OpenID and sign in.</p> 
       <pre><code class="lang-xml">&lt;form action="/auth/openid" method="post"&gt;
    &lt;div&gt;
        &lt;label&gt;OpenID:&lt;/label&gt;
        &lt;input type="text" name="openid_identifier"/&gt;&lt;br/&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;input type="submit" value="Sign In"/&gt;
    &lt;/div&gt;
&lt;/form&gt;
</code></pre> 
       <h2 id="routes">Routes</h2> 
       <p>Two routes are required for OpenID authentication. The first route accepts the form submission containing an OpenID identifier. During authentication, the user will be redirected to their OpenID provider. The second route is the URL to which the user will be returned after authenticating with their OpenID provider.</p> 
       <pre><code class="lang-javascript">// Accept the OpenID identifier and redirect the user to their OpenID
// provider for authentication.  When complete, the provider will redirect
// the user back to the application at:
//     /auth/openid/return
app.post('/auth/openid', passport.authenticate('openid'));

// The OpenID provider has redirected the user back to the application.
// Finish the authentication process by verifying the assertion.  If valid,
// the user will be logged in.  Otherwise, authentication has failed.
app.get('/auth/openid/return',
  passport.authenticate('openid', { successRedirect: '/',
                                    failureRedirect: '/login' }));
</code></pre> 
       <h2 id="profile-exchange">Profile Exchange</h2> 
       <p>OpenID can optionally be configured to retrieve profile information about the user being authenticated. Profile exchange is enabled by setting the <code>profile</code> option to <code>true</code>.</p> 
       <pre><code class="lang-javascript">passport.use(new OpenIDStrategy({
    returnURL: 'http://www.example.com/auth/openid/return',
    realm: 'http://www.example.com/',
    profile: true
  },
  function(identifier, profile, done) {
    // ...
  }
));
</code></pre> 
       <p>When profile exchange is enabled, the function signature of the verify callback accepts an additional <code>profile</code> argument containing user profile information provided by the OpenID provider; refer to <a href="/guide/profile/">User Profile</a> for further information.</p> 
      </section>
      <section id="oauth">
       <h1 id="oauth">OAuth</h1> 
       <p><a href="http://oauth.net/">OAuth</a> is a standard protocol that allows users to authorize API access to web and desktop or mobile applications. Once access has been granted, the authorized application can utilize the API on behalf of the user. OAuth has also emerged as a popular mechanism for <a href="http://hueniverse.com/2009/04/introducing-sign-in-with-twitter-oauth-style-connect/">delegated authentication</a>.</p> 
       <p>OAuth comes in two primary flavors, both of which are widely deployed.</p> 
       <p>The initial version of OAuth was developed as an open standard by a loosely organized collective of web developers. Their work resulted in <a href="http://oauth.net/core/1.0/">OAuth 1.0</a>, which was superseded by <a href="http://oauth.net/core/1.0a/">OAuth 1.0a</a>. This work has now been standardized by the <a href="http://www.ietf.org/">IETF</a> as <a href="http://tools.ietf.org/html/rfc5849">RFC 5849</a>.</p> 
       <p>Recent efforts undertaken by the <a href="http://tools.ietf.org/wg/oauth/">Web Authorization Protocol Working Group</a> have focused on defining <a href="http://tools.ietf.org/html/rfc6749">OAuth 2.0</a>. Due to the lengthy standardization effort, providers have proceeded to deploy implementations conforming to various drafts, each with slightly different semantics.</p> 
       <p>Thankfully, Passport shields an application from the complexities of dealing with OAuth variants. In many cases, a provider-specific strategy can be used instead of the generic OAuth strategies described below. This cuts down on the necessary configuration, and accommodates any provider-specific quirks. See <a href="/docs#facebook">Facebook</a>, <a href="/docs#twitter">Twitter</a> or the list of <a href="" data-search>providers</a> for preferred usage.</p> 
       <p>Support for OAuth is provided by the <a href="https://github.com/jaredhanson/passport-oauth">passport-oauth</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-oauth
</code></pre> 
       <h3 id="oauth-1-0">OAuth 1.0</h3> 
       <p>OAuth 1.0 is a delegated authentication strategy that involves multiple steps. First, a request token must be obtained. Next, the user is redirected to the service provider to authorize access. Finally, after authorization has been granted, the user is redirected back to the application and the request token can be exchanged for an access token. The application requesting access, known as a <em>consumer</em>, is identified by a consumer key and consumer secret.</p> 
       <h2 id="configuration">Configuration</h2> 
       <p>When using the generic OAuth strategy, the key, secret, and endpoints are specified as options.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , OAuthStrategy = require('passport-oauth').OAuthStrategy;

passport.use('provider', new OAuthStrategy({
    requestTokenURL: 'https://www.provider.com/oauth/request_token',
    accessTokenURL: 'https://www.provider.com/oauth/access_token',
    userAuthorizationURL: 'https://www.provider.com/oauth/authorize',
    consumerKey: '123-456-789',
    consumerSecret: 'shhh-its-a-secret'
    callbackURL: 'https://www.example.com/auth/provider/callback'
  },
  function(token, tokenSecret, profile, done) {
    User.findOrCreate(..., function(err, user) {
      done(err, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for OAuth-based strategies accepts <code>token</code>, <code>tokenSecret</code>, and <code>profile</code> arguments. <code>token</code> is the access token and <code>tokenSecret</code> is its corresponding secret. <code>profile</code> will contain user profile information provided by the service provider; refer to <a href="/guide/profile/">User Profile</a> for additional information.</p> 
       <h2 id="routes">Routes</h2> 
       <p>Two routes are required for OAuth authentication. The first route initiates an OAuth transaction and redirects the user to the service provider. The second route is the URL to which the user will be redirected after authenticating with the provider.</p> 
       <pre><code class="lang-javascript">// Redirect the user to the OAuth provider for authentication.  When
// complete, the provider will redirect the user back to the application at
//     /auth/provider/callback
app.get('/auth/provider', passport.authenticate('provider'));

// The OAuth provider has redirected the user back to the application.
// Finish the authentication process by attempting to obtain an access
// token.  If authorization was granted, the user will be logged in.
// Otherwise, authentication has failed.
app.get('/auth/provider/callback',
  passport.authenticate('provider', { successRedirect: '/',
                                      failureRedirect: '/login' }));
</code></pre> 
       <h2 id="link">Link</h2> 
       <p>A link or button can be placed on a web page, which will start the authentication process when clicked.</p> 
       <pre><code class="lang-xml">&lt;a href="/auth/provider"&gt;Log In with OAuth Provider&lt;/a&gt;
</code></pre> 
       <h3 id="oauth-2-0">OAuth 2.0</h3> 
       <p>OAuth 2.0 is the successor to OAuth 1.0, and is designed to overcome perceived shortcomings in the earlier version. The authentication flow is essentially the same. The user is first redirected to the service provider to authorize access. After authorization has been granted, the user is redirected back to the application with a code that can be exchanged for an access token. The application requesting access, known as a <em>client</em>, is identified by an ID and secret.</p> 
       <h2 id="configuration">Configuration</h2> 
       <p>When using the generic OAuth 2.0 strategy, the client ID, client secret, and endpoints are specified as options.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , OAuth2Strategy = require('passport-oauth').OAuth2Strategy;

passport.use('provider', new OAuth2Strategy({
    authorizationURL: 'https://www.provider.com/oauth2/authorize',
    tokenURL: 'https://www.provider.com/oauth2/token',
    clientID: '123-456-789',
    clientSecret: 'shhh-its-a-secret'
    callbackURL: 'https://www.example.com/auth/provider/callback'
  },
  function(accessToken, refreshToken, profile, done) {
    User.findOrCreate(..., function(err, user) {
      done(err, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for OAuth 2.0-based strategies accepts <code>accessToken</code>, <code>refreshToken</code>, and <code>profile</code> arguments. <code>refreshToken</code> can be used to obtain new access tokens, and may be <code>undefined</code> if the provider does not issue refresh tokens. <code>profile</code> will contain user profile information provided by the service provider; refer to <a href="/guide/profile/">User Profile</a> for additional information.</p> 
       <h2 id="routes">Routes</h2> 
       <p>Two routes are required for OAuth 2.0 authentication. The first route redirects the user to the service provider. The second route is the URL to which the user will be redirected after authenticating with the provider.</p> 
       <pre><code class="lang-javascript">// Redirect the user to the OAuth 2.0 provider for authentication.  When
// complete, the provider will redirect the user back to the application at
//     /auth/provider/callback
app.get('/auth/provider', passport.authenticate('provider'));

// The OAuth 2.0 provider has redirected the user back to the application.
// Finish the authentication process by attempting to obtain an access
// token.  If authorization was granted, the user will be logged in.
// Otherwise, authentication has failed.
app.get('/auth/provider/callback',
  passport.authenticate('provider', { successRedirect: '/',
                                      failureRedirect: '/login' }));
</code></pre> 
       <h2 id="scope">Scope</h2> 
       <p>When requesting access using OAuth 2.0, the scope of access is controlled by the scope option.</p> 
       <pre><code class="lang-javascript">app.get('/auth/provider',
  passport.authenticate('provider', { scope: 'email' })
);
</code></pre> 
       <p>Multiple scopes can be specified as an array.</p> 
       <pre><code class="lang-javascript">app.get('/auth/provider',
  passport.authenticate('provider', { scope: ['email', 'sms'] })
);
</code></pre> 
       <p>Values for the <code>scope</code> option are provider-specific. Consult the provider's documentation for details regarding supported scopes.</p> 
       <h2 id="link">Link</h2> 
       <p>A link or button can be placed on a web page, which will start the authentication process when clicked.</p> 
       <pre><code class="lang-xml">&lt;a href="/auth/provider"&gt;Log In with OAuth 2.0 Provider&lt;/a&gt;
</code></pre> 
      </section>
      <section id="profile">
       <h1 id="user-profile">User Profile</h1> 
       <p>When authenticating using a third-party service such as Facebook or Twitter, user profile information will often be available. Each service tends to have a different way of encoding this information. To make integration easier, Passport normalizes profile information to the extent possible.</p> 
       <p>Normalized profile information conforms to the <a href="https://tools.ietf.org/html/draft-smarr-vcarddav-portable-contacts-00">contact schema</a> established by [Joseph Smarr][schema-author]. The common fields available are outlined in the following table.</p> 
       <dl> 
        <dt>
         <code>provider</code> {String}
        </dt>
        <dt> 
        </dt>
        <dd>
         The provider with which the user authenticated (
         <code>facebook</code>, 
         <code>twitter</code>, etc.).
        </dd> 
        <dt>
         <code>id</code> {String}
        </dt>
        <dt> 
        </dt>
        <dd>
         A unique identifier for the user, as generated by the service provider.
        </dd> 
        <dt>
         <code>displayName</code> {String}
        </dt>
        <dt> 
        </dt>
        <dd>
         The name of this user, suitable for display.
        </dd> 
        <dt>
         <code>name</code> {Object}
        </dt>
        <dt> 
        </dt>
        <dd> 
         <dl> 
          <dt>
           <code>familyName</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The family name of this user, or "last name" in most Western languages.
          </dd> 
          <dt>
           <code>givenName</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The given name of this user, or "first name" in most Western languages.
          </dd> 
          <dt>
           <code>middleName</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The middle name of this user.
          </dd> 
         </dl> 
        </dd> 
        <dt>
         <code>emails</code> {Array} [n]
        </dt>
        <dt> 
        </dt>
        <dd> 
         <dl> 
          <dt>
           <code>value</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The actual email address.
          </dd> 
          <dt>
           <code>type</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The type of email address (home, work, etc.).
          </dd> 
         </dl> 
        </dd> 
        <dt>
         <code>photos</code> {Array} [n]
        </dt>
        <dt> 
        </dt>
        <dd> 
         <dl> 
          <dt>
           <code>value</code> {String}
          </dt>
          <dt> 
          </dt>
          <dd>
           The URL of the image.
          </dd> 
         </dl> 
        </dd> 
       </dl> 
       <p>Note that not all of the above fields are available from every service provider. Some providers may contain additional information not described here. Consult the provider-specific documentation for further details.</p> 
      </section>
      <section id="facebook">
       <h1 id="facebook">Facebook</h1> 
       <p>The Facebook strategy allows users to log in to a web application using their Facebook account. Internally, Facebook authentication works using OAuth 2.0.</p> 
       <p>Support for Facebook is implemented by the <a href="https://github.com/jaredhanson/passport-facebook">passport-facebook</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-facebook
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <p>In order to use Facebook authentication, you must first create an app at <a href="https://developers.facebook.com/">Facebook Developers</a>. When created, an app is assigned an App ID and App Secret. Your application must also implement a redirect URL, to which Facebook will redirect users after they have approved access for your application.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , FacebookStrategy = require('passport-facebook').Strategy;

passport.use(new FacebookStrategy({
    clientID: FACEBOOK_APP_ID,
    clientSecret: FACEBOOK_APP_SECRET,
    callbackURL: "http://www.example.com/auth/facebook/callback"
  },
  function(accessToken, refreshToken, profile, done) {
    User.findOrCreate(..., function(err, user) {
      if (err) { return done(err); }
      done(null, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for Facebook authentication accepts <code>accessToken</code>, <code>refreshToken</code>, and <code>profile</code> arguments. <code>profile</code> will contain user profile information provided by Facebook; refer to <a href="/guide/profile/">User Profile</a> for additional information.</p> 
       <p>Note: For security reasons, the redirection URL must reside on the same host that is registered with Facebook.</p> 
       <h2 id="routes">Routes</h2> 
       <p>Two routes are required for Facebook authentication. The first route redirects the user to Facebook. The second route is the URL to which Facebook will redirect the user after they have logged in.</p> 
       <pre><code class="lang-javascript">// Redirect the user to Facebook for authentication.  When complete,
// Facebook will redirect the user back to the application at
//     /auth/facebook/callback
app.get('/auth/facebook', passport.authenticate('facebook'));

// Facebook will redirect the user to this URL after approval.  Finish the
// authentication process by attempting to obtain an access token.  If
// access was granted, the user will be logged in.  Otherwise,
// authentication has failed.
app.get('/auth/facebook/callback',
  passport.authenticate('facebook', { successRedirect: '/',
                                      failureRedirect: '/login' }));
</code></pre> 
       <p>Note that the URL of the callback route matches that of the <code>callbackURL</code> option specified when configuring the strategy.</p> 
       <h2 id="permissions">Permissions</h2> 
       <p>If your application needs extended permissions, they can be requested by setting the <code>scope</code> option.</p> 
       <pre><code class="lang-javascript">app.get('/auth/facebook',
  passport.authenticate('facebook', { scope: 'read_stream' })
);
</code></pre> 
       <p>Multiple permissions can be specified as an array.</p> 
       <pre><code class="lang-javascript">app.get('/auth/facebook',
  passport.authenticate('facebook', { scope: ['read_stream', 'publish_actions'] })
);
</code></pre> 
       <h2 id="link">Link</h2> 
       <p>A link or button can be placed on a web page, allowing one-click login with Facebook.</p> 
       <pre><code class="lang-xml">&lt;a href="/auth/facebook"&gt;Login with Facebook&lt;/a&gt;
</code></pre> 
      </section>
      <section id="twitter">
       <h1 id="twitter">Twitter</h1> 
       <p>The Twitter strategy allows users to sign in to a web application using their Twitter account. Internally, Twitter authentication works using OAuth 1.0a.</p> 
       <p>Support for Twitter is implemented by the <a href="https://github.com/jaredhanson/passport-twitter">passport-twitter</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-twitter
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <p>In order to use Twitter authentication, you must first create an application at <a href="https://dev.twitter.com/">Twitter Developers</a>. When created, an application is assigned a consumer key and consumer secret. Your application must also implement a callback URL, to which Twitter will redirect users after they have approved access for your application.</p> 
       <pre><code class="lang-javascript">var passport = require('passport')
  , TwitterStrategy = require('passport-twitter').Strategy;

passport.use(new TwitterStrategy({
    consumerKey: TWITTER_CONSUMER_KEY,
    consumerSecret: TWITTER_CONSUMER_SECRET,
    callbackURL: "http://www.example.com/auth/twitter/callback"
  },
  function(token, tokenSecret, profile, done) {
    User.findOrCreate(..., function(err, user) {
      if (err) { return done(err); }
      done(null, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for Twitter authentication accepts <code>token</code>, <code>tokenSecret</code>, and <code>profile</code> arguments. <code>profile</code> will contain user profile information provided by Twitter; refer to <a href="/guide/profile/">User Profile</a> for additional information.</p> 
       <h2 id="routes">Routes</h2> 
       <p>Two routes are required for Twitter authentication. The first route initiates an OAuth transaction and redirects the user to Twitter. The second route is the URL to which Twitter will redirect the user after they have signed in.</p> 
       <pre><code class="lang-javascript">// Redirect the user to Twitter for authentication.  When complete, Twitter
// will redirect the user back to the application at
//   /auth/twitter/callback
app.get('/auth/twitter', passport.authenticate('twitter'));

// Twitter will redirect the user to this URL after approval.  Finish the
// authentication process by attempting to obtain an access token.  If
// access was granted, the user will be logged in.  Otherwise,
// authentication has failed.
app.get('/auth/twitter/callback',
  passport.authenticate('twitter', { successRedirect: '/',
                                     failureRedirect: '/login' }));
</code></pre> 
       <p>Note that the URL of the callback route matches that of the <code>callbackURL</code> option specified when configuring the strategy.</p> 
       <h2 id="link">Link</h2> 
       <p>A link or button can be placed on a web page, allowing one-click sign in with Twitter.</p> 
       <pre><code class="lang-xml">&lt;a href="/auth/twitter"&gt;Sign in with Twitter&lt;/a&gt;
</code></pre> 
      </section>
      <section id="google">
       <h1 id="google">Google</h1> 
       <p>The Google strategy allows users to sign in to a web application using their Google account. Google <a href="https://developers.google.com/identity/protocols/OpenID2Migration#shutdown-timetable">used to support OpenID internally</a>, but it now works based on <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a> and supports oAuth 1.0 and oAuth 2.0.</p> 
       <p>Support for Google is implemented by the <a href="https://github.com/jaredhanson/passport-google-oauth">passport-google-oauth</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-google-oauth
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <p>The Client Id and Client Secret needed to authenticate with Google can be set up from the <a href="https://console.developers.google.com">Google Developers Console</a>. You may also need to enable Google+ API in the developer console, otherwise user profile data may not be fetched. Google supports authentication with both oAuth 1.0 and oAuth 2.0.</p> 
       <h3 id="oauth-1-0">oAuth 1.0</h3> 
       <p>The Google OAuth 1.0 authentication strategy authenticates users using a Google account and OAuth tokens. The strategy requires a <code>verify</code> callback, which accepts these credentials and calls <code>done</code> providing a user, as well as <code>options</code> specifying a consumer key, consumer secret, and callback URL.</p> 
       <h4 id="configuration">Configuration</h4> 
       <pre><code class="lang-javascript">var passport = require('passport');
var GoogleStrategy = require('passport-google-oauth').OAuthStrategy;

// Use the GoogleStrategy within Passport.
//   Strategies in passport require a `verify` function, which accept
//   credentials (in this case, a token, tokenSecret, and Google profile), and
//   invoke a callback with a user object.
passport.use(new GoogleStrategy({
    consumerKey: GOOGLE_CONSUMER_KEY,
    consumerSecret: GOOGLE_CONSUMER_SECRET,
    callbackURL: "http://www.example.com/auth/google/callback"
  },
  function(token, tokenSecret, profile, done) {
      User.findOrCreate({ googleId: profile.id }, function (err, user) {
        return done(err, user);
      });
  }
));
</code></pre> 
       <h4 id="routes">Routes</h4> 
       <p>Use passport.authenticate(), specifying the 'google' strategy, to authenticate requests. Authentication with Google requires an extra <code>scope</code> parameter. For information, go <a href="https://developers.google.com/identity/protocols/OpenIDConnect#scope-param">here</a>.</p> 
       <pre><code class="lang-javascript">// GET /auth/google
//   Use passport.authenticate() as route middleware to authenticate the
//   request.  The first step in Google authentication will involve redirecting
//   the user to google.com.  After authorization, Google will redirect the user
//   back to this application at /auth/google/callback
app.get('/auth/google',
  passport.authenticate('google', { scope: 'https://www.google.com/m8/feeds' });

// GET /auth/google/callback
//   Use passport.authenticate() as route middleware to authenticate the
//   request.  If authentication fails, the user will be redirected back to the
//   login page.  Otherwise, the primary route function function will be called,
//   which, in this example, will redirect the user to the home page.
app.get('/auth/google/callback', 
  passport.authenticate('google', { failureRedirect: '/login' }),
  function(req, res) {
    res.redirect('/');
  });
</code></pre> 
       <h3 id="oauth-2-0">oAuth 2.0</h3> 
       <p>The Google OAuth 2.0 authentication strategy authenticates users using a Google account and OAuth 2.0 tokens. The strategy requires a <code>verify</code> callback, which accepts these credentials and calls <code>done</code> providing a user, as well as <code>options</code> specifying a client ID, client secret, and callback URL.</p> 
       <h4 id="configuration">Configuration</h4> 
       <pre><code class="lang-javascript">var passport = require('passport');
var GoogleStrategy = require('passport-google-oauth').OAuth2Strategy;

// Use the GoogleStrategy within Passport.
//   Strategies in Passport require a `verify` function, which accept
//   credentials (in this case, an accessToken, refreshToken, and Google
//   profile), and invoke a callback with a user object.
passport.use(new GoogleStrategy({
    clientID: GOOGLE_CLIENT_ID,
    clientSecret: GOOGLE_CLIENT_SECRET,
    callbackURL: "http://www.example.com/auth/google/callback"
  },
  function(accessToken, refreshToken, profile, done) {
       User.findOrCreate({ googleId: profile.id }, function (err, user) {
         return done(err, user);
       });
  }
));
</code></pre> 
       <h4 id="routes">Routes</h4> 
       <p>Use <code>passport.authenticate()</code>, specifying the 'google' strategy, to authenticate requests. Authentication with Google requires an extra <code>scope</code> parameter. For information, go <a href="https://developers.google.com/identity/protocols/OpenIDConnect#scope-param">here</a>.</p> 
       <pre><code class="lang-javascript">// GET /auth/google
//   Use passport.authenticate() as route middleware to authenticate the
//   request.  The first step in Google authentication will involve
//   redirecting the user to google.com.  After authorization, Google
//   will redirect the user back to this application at /auth/google/callback
app.get('/auth/google',
  passport.authenticate('google', { scope: ['https://www.googleapis.com/auth/plus.login'] }));

// GET /auth/google/callback
//   Use passport.authenticate() as route middleware to authenticate the
//   request.  If authentication fails, the user will be redirected back to the
//   login page.  Otherwise, the primary route function function will be called,
//   which, in this example, will redirect the user to the home page.
app.get('/auth/google/callback', 
  passport.authenticate('google', { failureRedirect: '/login' }),
  function(req, res) {
    res.redirect('/');
  });
</code></pre> 
       <h2 id="link">Link</h2> 
       <p>A link or button can be placed on a web page, allowing one-click sign in with Google.</p> 
       <pre><code class="lang-xml">&lt;a href="/auth/google"&gt;Sign In with Google&lt;/a&gt;
</code></pre> 
      </section>
      <section id="basic-digest">
       <h1 id="basic-digest">Basic &amp; Digest</h1> 
       <p>Along with defining HTTP's authentication framework, <a href="http://tools.ietf.org/html/rfc2617">RFC 2617</a> also defined the Basic and Digest authentications schemes. These two schemes both use usernames and passwords as credentials to authenticate users, and are often used to protect API endpoints.</p> 
       <p>It should be noted that relying on username and password creditials can have adverse security impacts, especially in scenarios where there is not a high degree of trust between the server and client. In these situations, it is recommended to use an authorization framework such as <a href="/guide/oauth2-api/">OAuth 2.0</a>.</p> 
       <p>Support for Basic and Digest schemes is provided by the <a href="https://github.com/jaredhanson/passport-http">passport-http</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-http
</code></pre> 
       <h3 id="basic">Basic</h3> 
       <p>The Basic scheme uses a username and password to authenticate a user. These credentials are transported in plain text, so it is advised to use HTTPS when implementing this scheme.</p> 
       <h2 id="configuration">Configuration</h2> 
       <pre><code class="lang-javascript">passport.use(new BasicStrategy(
  function(username, password, done) {
    User.findOne({ username: username }, function (err, user) {
      if (err) { return done(err); }
      if (!user) { return done(null, false); }
      if (!user.validPassword(password)) { return done(null, false); }
      return done(null, user);
    });
  }
));
</code></pre> 
       <p>The verify callback for Basic authentication accepts <code>username</code> and <code>password</code> arguments.</p> 
       <h2 id="protect-endpoints">Protect Endpoints</h2> 
       <pre><code class="lang-javascript">app.get('/api/me',
  passport.authenticate('basic', { session: false }),
  function(req, res) {
    res.json(req.user);
  });
</code></pre> 
       <p>Specify <code>passport.authenticate()</code> with the <code>basic</code> strategy to protect API endpoints. Sessions are not typically needed by APIs, so they can be disabled.</p> 
       <h3 id="digest">Digest</h3> 
       <p>The Digest scheme uses a username and password to authenticate a user. Its primary benefit over Basic is that it uses a challenge-response paradigm to avoid sending the password in the clear.</p> 
       <h2 id="configuration">Configuration</h2> 
       <pre><code class="lang-javascript">passport.use(new DigestStrategy({ qop: 'auth' },
  function(username, done) {
    User.findOne({ username: username }, function (err, user) {
      if (err) { return done(err); }
      if (!user) { return done(null, false); }
      return done(null, user, user.password);
    });
  },
  function(params, done) {
    // validate nonces as necessary
    done(null, true)
  }
));
</code></pre> 
       <p>The Digest strategy utilizes two callbacks, the second of which is optional.</p> 
       <p>The first callback, known as the "secret callback" accepts the username and calls <code>done</code> supplying a user and the corresponding secret password. The password is used to compute a hash, and authentication fails if it does not match that contained in the request.</p> 
       <p>The second "validate callback" accepts nonce related params, which can be checked to avoid replay attacks.</p> 
       <h2 id="protect-endpoints">Protect Endpoints</h2> 
       <pre><code class="lang-javascript">app.get('/api/me',
  passport.authenticate('digest', { session: false }),
  function(req, res) {
    res.json(req.user);
  });
</code></pre> 
       <p>Specify <code>passport.authenticate()</code> with the <code>digest</code> strategy to protect API endpoints. Sessions are not typically needed by APIs, so they can be disabled.</p> 
      </section>
      <section id="oauth-api">
       <h1 id="oauth">OAuth</h1> 
       <p><a href="http://oauth.net/">OAuth</a> (formally specified by <a href="http://tools.ietf.org/html/rfc5849">RFC 5849</a>) provides a means for users to grant third-party applications access to their data without exposing their password to those applications.</p> 
       <p>The protocol greatly improves the security of web applications, in particular, and OAuth has been important in bringing attention to the potential dangers of exposing passwords to external services.</p> 
       <p>While OAuth 1.0 is still widely used, it has been superseded by <a href="/guide/oauth2-api/">OAuth 2.0</a>. It is recommended to base new implementations on OAuth 2.0.</p> 
       <p>When using OAuth to protect API endpoints, there are three distinct steps that that must be performed:</p> 
       <ol> 
        <li>The application requests permission from the user for access to protected resources.</li> 
        <li>A token is issued to the application, if permission is granted by the user.</li> 
        <li>The application authenticates using the token to access protected resources.</li> 
       </ol> 
       <h2 id="issuing-tokens">Issuing Tokens</h2> 
       <p><a href="https://github.com/jaredhanson/oauthorize">OAuthorize</a>, a sibling project to Passport, provides a toolkit for implementing OAuth service providers.</p> 
       <p>The authorization process is a complex sequence that involves authenticating both the requesting application and the user, as well as prompting the user for permission, ensuring that enough detail is provided for the user to make an informed decision.</p> 
       <p>Additionally, it is up to the implementor to determine what limits can be placed on the application regarding scope of access, as well as subsequently enforcing those limits.</p> 
       <p>As a toolkit, OAuthorize does not attempt to make implementation decisions. This guide does not cover these issues, but does highly recommend that services deploying OAuth have a complete understanding of the security considerations involved.</p> 
       <h2 id="authenticating-tokens">Authenticating Tokens</h2> 
       <p>Once issued, OAuth tokens can be authenticated using the <a href="https://github.com/jaredhanson/passport-http-oauth">passport-http-oauth</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-http-oauth
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <pre><code class="lang-javascript">passport.use('token', new TokenStrategy(
  function(consumerKey, done) {
    Consumer.findOne({ key: consumerKey }, function (err, consumer) {
      if (err) { return done(err); }
      if (!consumer) { return done(null, false); }
      return done(null, consumer, consumer.secret);
    });
  },
  function(accessToken, done) {
    AccessToken.findOne({ token: accessToken }, function (err, token) {
      if (err) { return done(err); }
      if (!token) { return done(null, false); }
      Users.findById(token.userId, function(err, user) {
        if (err) { return done(err); }
        if (!user) { return done(null, false); }
        // fourth argument is optional info.  typically used to pass
        // details needed to authorize the request (ex: `scope`)
        return done(null, user, token.secret, { scope: token.scope });
      });
    });
  },
  function(timestamp, nonce, done) {
    // validate the timestamp and nonce as necessary
    done(null, true)
  }
));
</code></pre> 
       <p>In contrast to other strategies, there are two callbacks required by OAuth. In OAuth, both an identifier for the requesting application and the user-specific token are encoded as credentials.</p> 
       <p>The first callback is known as the "consumer callback", and is used to find the application making the request, including the secret assigned to it. The second callback is the "token callback", which is used to indentify the user as well as the token's corresponding secret. The secrets supplied by the consumer and token callbacks are used to compute a signature, and authentication fails if it does not match the request signature.</p> 
       <p>A final "validate callback" is optional, which can be used to prevent replay attacks by checking the timestamp and nonce used in the request.</p> 
       <h2 id="protect-endpoints">Protect Endpoints</h2> 
       <pre><code class="lang-javascript">app.get('/api/me',
  passport.authenticate('token', { session: false }),
  function(req, res) {
    res.json(req.user);
  });
</code></pre> 
       <p>Specify <code>passport.authenticate()</code> with the <code>token</code> strategy to protect API endpoints. Sessions are not typically needed by APIs, so they can be disabled.</p> 
      </section>
      <section id="oauth2-api">
       <h1 id="oauth-2-0">OAuth 2.0</h1> 
       <p>OAuth 2.0 (formally specified by <a href="http://tools.ietf.org/html/rfc6749">RFC 6749</a>) provides an authorization framework which allows users to authorize access to third-party applications. When authorized, the application is issued a token to use as an authentication credential. This has two primary security benefits:</p> 
       <ol> 
        <li>The application does not need to store the user's username and password.</li> 
        <li>The token can have a restricted scope (for example: read-only access).</li> 
       </ol> 
       <p>These benefits are particularly important for ensuring the security of web applications, making OAuth 2.0 the predominant standard for API authentication.</p> 
       <p>When using OAuth 2.0 to protect API endpoints, there are three distinct steps that must be performed:</p> 
       <ol> 
        <li>The application requests permission from the user for access to protected resources.</li> 
        <li>A token is issued to the application, if permission is granted by the user.</li> 
        <li>The application authenticates using the token to access protected resources.</li> 
       </ol> 
       <h2 id="issuing-tokens">Issuing Tokens</h2> 
       <p><a href="https://github.com/jaredhanson/oauth2orize">OAuth2orize</a>, a sibling project to Passport, provides a toolkit for implementing OAuth 2.0 authorization servers.</p> 
       <p>The authorization process is a complex sequence that involves authenticating both the requesting application and the user, as well as prompting the user for permission, ensuring that enough detail is provided for the user to make an informed decision.</p> 
       <p>Additionally, it is up to the implementor to determine what limits can be placed on the application regarding scope of access, as well as subsequently enforcing those limits.</p> 
       <p>As a toolkit, OAuth2orize does not attempt to make implementation decisions. This guide does not cover these issues, but does highly recommend that services deploying OAuth 2.0 have a complete understanding of the security considerations involved.</p> 
       <h2 id="authenticating-tokens">Authenticating Tokens</h2> 
       <p>OAuth 2.0 provides a framework, in which an arbitrarily extensible set of token types can be issued. In practice, only specific token types have gained widespread use.</p> 
       <h2 id="bearer-tokens">Bearer Tokens</h2> 
       <p>Bearer tokens are the most widely issued type of token in OAuth 2.0. So much so, in fact, that many implementations assume that bearer tokens are the only type of token issued.</p> 
       <p>Bearer tokens can be authenticated using the <a href="https://github.com/jaredhanson/passport-http-bearer">passport-http-bearer</a> module.</p> 
       <h2 id="install">Install</h2> 
       <pre><code class="lang-bash">$ npm install passport-http-bearer
</code></pre> 
       <h2 id="configuration">Configuration</h2> 
       <pre><code class="lang-javascript">passport.use(new BearerStrategy(
  function(token, done) {
    User.findOne({ token: token }, function (err, user) {
      if (err) { return done(err); }
      if (!user) { return done(null, false); }
      return done(null, user, { scope: 'read' });
    });
  }
));
</code></pre> 
       <p>The verify callback for bearer tokens accepts the <code>token</code> as an argument. When invoking <code>done</code>, optional <code>info</code> can be passed, which will be set by Passport at <code>req.authInfo</code>. This is typically used to convey the scope of the token, and can be used when making access control checks.</p> 
       <h2 id="protect-endpoints">Protect Endpoints</h2> 
       <pre><code class="lang-javascript">app.get('/api/me',
  passport.authenticate('bearer', { session: false }),
  function(req, res) {
    res.json(req.user);
  });
</code></pre> 
       <p>Specify <code>passport.authenticate()</code> with the <code>bearer</code> strategy to protect API endpoints. Sessions are not typically needed by APIs, so they can be disabled.</p> 
      </section>
      <section id="other-api">
       <h1 id="api-schemes">API Schemes</h1> 
       <p>The following is a list of strategies that implement authentication schemes used when protecting API endpoints.</p> 
       <table class="table table-condensed table-striped"> 
        <thead> 
         <tr> 
          <th>Scheme</th> 
          <th>Specification</th> 
          <th>Developer</th> 
         </tr> 
        </thead> 
        <tbody> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-anonymous">Anonymous</a></td> 
          <td>N/A</td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-http-bearer">Bearer</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc6750">RFC 6750</a></td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-http">Basic</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc2617">RFC 2617</a></td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-http">Digest</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc2617">RFC 2617</a></td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/yuri-karadzhov/passport-hash">Hash</a></td> 
          <td>N/A</td> 
          <td><a href="https://github.com/yuri-karadzhov">Yuri Karadzhov</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jfromaniello/passport-hawk">Hawk</a></td> 
          <td><a href="https://github.com/hueniverse/hawk">hueniverse/hawk</a></td> 
          <td><a href="https://github.com/jfromaniello">Jos F. Romaniello</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/cholalabs/passport-localapikey">Local API Key</a></td> 
          <td>N/A</td> 
          <td><a href="https://github.com/cholalabs">Sudhakar Mani</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-http-oauth">OAuth</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc5849">RFC 5849</a></td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/jaredhanson/passport-oauth2-client-password">OAuth 2.0 Client Password</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc6749#section-2.3.1">RFC 6749</a></td> 
          <td><a href="https://github.com/jaredhanson">Jared Hanson</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/xtuple/passport-oauth2-jwt-bearer">OAuth 2.0 JWT Client Assertion</a></td> 
          <td><a href="http://tools.ietf.org/html/draft-jones-oauth-jwt-bearer">draft-jones-oauth-jwt-bearer</a></td> 
          <td><a href="https://github.com/xtuple">xTuple</a></td> 
         </tr> 
         <tr> 
          <td><a href="https://github.com/timshadel/passport-oauth2-public-client">OAuth 2.0 Public Client</a></td> 
          <td><a href="http://tools.ietf.org/html/rfc6749">RFC 6749</a></td> 
          <td><a href="https://github.com/timshadel">Tim Shadel</a></td> 
         </tr> 
        </tbody> 
       </table> 
      </section>
      <section id="login">
       <h1 id="log-in">Log In</h1> 
       <p>Passport exposes a <code>login()</code> function on <code>req</code> (also aliased as <code>logIn()</code>) that can be used to establish a login session.</p> 
       <pre><code class="lang-javascript">req.login(user, function(err) {
  if (err) { return next(err); }
  return res.redirect('/users/' + req.user.username);
});
</code></pre> 
       <p>When the login operation completes, <code>user</code> will be assigned to <code>req.user</code>.</p> 
       <p>Note: <code>passport.authenticate()</code> middleware invokes <code>req.login()</code> automatically. This function is primarily used when users sign up, during which <code>req.login()</code> can be invoked to automatically log in the newly registered user.</p> 
      </section>
      <section id="logout">
       <h1 id="log-out">Log Out</h1> 
       <p>Passport exposes a <code>logout()</code> function on <code>req</code> (also aliased as <code>logOut()</code>) that can be called from any route handler which needs to terminate a login session. Invoking <code>logout()</code> will remove the <code>req.user</code> property and clear the login session (if any).</p> 
       <pre><code class="lang-javascript">app.get('/logout', function(req, res){
  req.logout();
  res.redirect('/');
});
</code></pre> 
      </section>
      <section id="authorize">
       <h1 id="authorize">Authorize</h1> 
       <p>An application may need to incorporate information from multiple third-party services. In this case, the application will request the user to "connect", for example, both their Facebook and Twitter accounts.</p> 
       <p>When this occurs, a user will already be authenticated with the application, and any subsequent third-party accounts merely need to be authorized and associated with the user. Because authentication and authorization in this situation are similar, Passport provides a means to accommodate both.</p> 
       <p>Authorization is performed by calling <code>passport.authorize()</code>. If authorization is granted, the result provided by the strategy's verify callback will be assigned to <code>req.account</code>. The existing login session and <code>req.user</code> will be unaffected.</p> 
       <pre><code class="lang-javascript">app.get('/connect/twitter',
  passport.authorize('twitter-authz', { failureRedirect: '/account' })
);

app.get('/connect/twitter/callback',
  passport.authorize('twitter-authz', { failureRedirect: '/account' }),
  function(req, res) {
    var user = req.user;
    var account = req.account;

    // Associate the Twitter account with the logged-in user.
    account.userId = user.id;
    account.save(function(err) {
      if (err) { return self.error(err); }
      self.redirect('/');
    });
  }
);
</code></pre> 
       <p>In the callback route, you can see the use of both <code>req.user</code> and <code>req.account</code>. The newly connected account is associated with the logged-in user and saved to the database.</p> 
       <h2 id="configuration">Configuration</h2> 
       <p>Strategies used for authorization are the same as those used for authentication. However, an application may want to offer both authentication and authorization with the same third-party service. In this case, a <em>named strategy</em> can be used, by overriding the strategy's default name in the call to <code>use()</code>.</p> 
       <pre><code class="lang-javascript">passport.use('twitter-authz', new TwitterStrategy({
    consumerKey: TWITTER_CONSUMER_KEY,
    consumerSecret: TWITTER_CONSUMER_SECRET,
    callbackURL: "http://www.example.com/connect/twitter/callback"
  },
  function(token, tokenSecret, profile, done) {
    Account.findOne({ domain: 'twitter.com', uid: profile.id }, function(err, account) {
      if (err) { return done(err); }
      if (account) { return done(null, account); }

      var account = new Account();
      account.domain = 'twitter.com';
      account.uid = profile.id;
      var t = { kind: 'oauth', token: token, attributes: { tokenSecret: tokenSecret } };
      account.tokens.push(t);
      return done(null, account);
    });
  }
));
</code></pre> 
       <p>In the above example, you can see that the <code>twitter-authz</code> strategy is finding or creating an <code>Account</code> instance to store Twitter account information. The result will be assigned to <code>req.account</code>, allowing the route handler to associate the account with the authenticated user.</p> 
       <h3 id="association-in-verify-callback">Association in Verify Callback</h3> 
       <p>One downside to the approach described above is that it requires two instances of the same strategy and supporting routes.</p> 
       <p>To avoid this, set the strategy's <code>passReqToCallback</code> option to <code>true</code>. With this option enabled, <code>req</code> will be passed as the <em>first</em> argument to the verify callback.</p> 
       <pre><code class="lang-javascript">passport.use(new TwitterStrategy({
    consumerKey: TWITTER_CONSUMER_KEY,
    consumerSecret: TWITTER_CONSUMER_SECRET,
    callbackURL: "http://www.example.com/auth/twitter/callback",
    passReqToCallback: true
  },
  function(req, token, tokenSecret, profile, done) {
    if (!req.user) {
      // Not logged-in. Authenticate based on Twitter account.
    } else {
      // Logged in. Associate Twitter account with user.  Preserve the login
      // state by supplying the existing user after association.
      // return done(null, req.user);
    }
  }
));
</code></pre> 
       <p>With <code>req</code> passed as an argument, the verify callback can use the state of the request to tailor the authentication process, handling both authentication and authorization using a single strategy instance and set of routes. For example, if a user is already logged in, the newly "connected" account can be associated. Any additional application-specific properties set on <code>req</code>, including <code>req.session</code>, can be used as well.</p> 
      </section>
     </div>
    </div>
    <a href="http://auth0.com" target="_blank" class="supported">Supported by<i class="auth0"></i></a>
   </div>
  </div>
  <div class="search-con">
   <div class="head">
    <span class="close-ico"></span>
    <div class="hold">
     <h2>SEARCH FOR STRATEGIES</h2>
     <form action="/">
      <input value="" type="text" name="strategy" placeholder="Start typing">
     </form>
     <p class="info-line"><span>0</span>STRATEGIES</p>
    </div>
   </div>
   <div class="results">
    <section></section>
   </div>
  </div>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
  <script src="/javascripts/plugins.js"></script>
  <script src="/javascripts/helpers.js"></script>
  <script src="/javascripts/main.js"></script>
  <script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-104798-10']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
  <!-- Google Tag Manager-->
  <noscript>
   iframe(src='//www.googletagmanager.com/ns.html?id=GTM-M5S3PH', height='0', width='0', style='display:none;visibility:hidden')
  </noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-M5S3PH');</script>
  <!-- End Google Tag Manager-->
 </body>
</html>