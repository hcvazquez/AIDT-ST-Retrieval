<!doctype html>
<html>
 <head> 
  <title>Exploring Elasticsearch</title> 
  <meta charset="utf-8"> 
  <script src="/cdn-cgi/apps/head/7oxTjhRTl_q1tMdoJ8iZd5X3tnQ.js"></script>
  <link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Inconsolata:400,700|PT+Serif:400,700,400italic,700italic"> 
  <link type="text/css" rel="stylesheet" media="screen" href="stylesheets/pygments.css"> 
  <link type="text/css" rel="stylesheet" media="screen" href="stylesheets/softcover.css"> 
  <link type="text/css" rel="stylesheet" media="screen" href="stylesheets/custom.css"> 
  <link href="/book.css" type="text/css" rel="stylesheet"> 
  <style type="text/css">
      article.chapter ol.latex {
      counter-reset: chapter 4;
      }

      article.chapter ol.latex ol.latex {
      counter-reset: chapter 9;
      }
    </style> 
  <script type="text/javascript">
      function trackOutboundLink(link, category, action) {
        try {
          _gaq.push(['_trackEvent', category , action]);
        } catch(err){}

        setTimeout(function() {
          document.location.href = link.href;
        }, 100);
      }
    </script> 
 </head> 
 <body> 
  <header> 
   <div style="width: 100%; background-color: #FFCACA; border: 1px solid red; padding: 30px;">
     Unfortunately, I no longer have the time to maintain this book which is growing increasingly out of date (esp. with the upcoming Elasticsearch 2.0). I highly recommend checking out 
    <a href="https://www.elastic.co/guide/en/elasticsearch/guide/master/index.html">Elasticsearch, the Definitive Guide</a> instead. This site will remain up indefinitely to prevent link rot. 
   </div> 
   <div id="book-heading" class="aligned-content"> 
    <h1> <a href="/"> Exploring Elasticsearch </a> </h1> 
    <div id="about"> 
     <div id="summary">
       A human-friendly tutorial for elasticsearch. 
     </div> 
     <div id="attribution">
       by 
      <a href="http://blog.andrewvc.com">Andrew Cholakian</a> 
     </div> 
    </div> 
   </div>
  </header> 
  <nav id="toc"> 
   <div id="toc-button">
     Table of Contents 
    <span class="icon">?</span>
   </div> 
   <ol id="chapters">
    <div id="table_of_contents">
     <ul>
      <li class="chapter-star"><a class="heading hyperref" href="/#about_this_book">About this Book</a></li>
      <li class="chapter-star"><a class="heading hyperref" href="/#about_me">About Me</a></li>
      <li class="chapter"><a class="heading hyperref" href="/overview.html#ch-overview">An Overview</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/overview.html#sec-over-what-is-elasticsearch"><span class="number">1.1 </span>What is Elasticsearch?</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/overview.html#sec-over-up-and-running"><span class="number">1.2 </span>Up and Running</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/modeling_data.html#ch-modeling-data">Modeling Data</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/modeling_data.html#sec-modeling-document-and-field-basics"><span class="number">2.1 </span>Documents and Field Basics</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/modeling_data.html#sec-modeling-type-basics"><span class="number">2.2 </span>Type Basics</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/modeling_data.html#sec-modeling-index-basics"><span class="number">2.3 </span>Index Basics</a></li>
        <li class="section"><a class="heading hyperref" href="/modeling_data.html#sec-modeling-basic-crud"><span class="number">2.4 </span>Basic CRUD</a></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/searching_data.html#ch-searching-data">Searching Data</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/searching_data.html#sec-search-query-dsl"><span class="number">3.1 </span>The Search API</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/searching_data.html#sec-searching-analysis"><span class="number">3.2 </span>Analysis</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/searching_data.html#sec-searching-similarity"><span class="number">3.3 </span>Ranking Based on Similarity</a></li>
        <li class="section"><a class="heading hyperref" href="/searching_data.html#sec-searching-faceting"><span class="number">3.4 </span>Faceting</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/searching_data.html#sec-searching-filtering"><span class="number">3.5 </span>Filtering</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/searching_a_book.html#ch-booksearch">Searching a Book</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/searching_a_book.html#cid16"><span class="number">4.1 </span>Getting Started</a></li>
        <li class="section"><a class="heading hyperref" href="/searching_a_book.html#sec-booksearch-moreprecisely"><span class="number">4.2 </span>Searching More Precisely</a></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/searching_usernames_and_tokenish_text.html#ch-strangetext">Searching Usernames and Strange Text</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/searching_usernames_and_tokenish_text.html#sec-strangetext-approach"><span class="number">5.1 </span>Formulating an Approach</a></li>
        <li class="section"><a class="heading hyperref" href="/searching_usernames_and_tokenish_text.html#sec-strangetext-username-ngrams"><span class="number">5.2 </span>A Simple Username Search Using Ngrams</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/searching_wikipedia.html#ch-wikipedia">Searching the Wikipedia Dataset</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/searching_wikipedia.html#sec-wiki-working"><span class="number">6.1 </span>Working With the Wikipedia Schema</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/searching_wikipedia.html#sec-wiki-simple-search"><span class="number">6.2 </span>A Simple Search of Wikipedia Data</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/searching_products_with_drilldown.html#ch-productsearch">Product Search with Drilldown</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/searching_products_with_drilldown.html#sec-drilldown"><span class="number">7.1 </span>Drilling Down One Level</a></li>
        <li class="section"><a class="heading hyperref" href="/searching_products_with_drilldown.html#sec-drilldownmulti"><span class="number">7.2 </span>Drilling Down Multiple Levels</a></li>
        <li class="section"><a class="heading hyperref" href="/searching_products_with_drilldown.html#sec-drilldownfacet"><span class="number">7.3 </span>Searching and Faceting Tags</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/advanced_techniques.html#ch-advanced">Advanced Topics</a></li>
      <li>
       <ul>
        <li class="section"><a class="heading hyperref" href="/advanced_techniques.html#advanced-routing"><span class="number">8.1 </span>Routing</a></li>
        <li>
         <ul></ul></li>
        <li class="section"><a class="heading hyperref" href="/advanced_techniques.html#advanced-internals"><span class="number">8.2 </span>Clustering and Index Internals</a></li>
        <li>
         <ul></ul></li>
       </ul></li>
      <li class="chapter"><a class="heading hyperref" href="/github_interview.html#ch-githubinterview">Interview: Elasticsearch at Github</a></li>
      <li class="chapter"><a class="heading hyperref" href="/nick_interview.html#ch-nickinterview">Interview: Bonsai.io</a></li>
      <li class="chapter"><a class="heading hyperref" href="/mahesh_interview.html#ch-ubiquitiinterview">Interview: Ubiquiti</a></li>
     </ul>
    </div>
   </ol> 
  </nav> 
  <article class="chapter"> 
   <div class="aligned-content"> 
    <ol id="content" class="latex">
     <div data-chapter="searching_data" data-number="3" class="chapter" data-tralics-id="cid9" id="ch-searching-data">
      <h1><a class="heading hyperref" href="/searching_data.html#ch-searching-data"><span class="number">Chapter 3 </span>Searching Data</a></h1> 
     </div>
     <div data-number="3.1" class="section" data-tralics-id="cid10" id="sec-search-query-dsl">
      <h2><a class="heading hyperref" href="/searching_data.html#sec-search-query-dsl"><span class="number">3.1 </span>The Search API</a></h2> 
      <p>The Search API is provided by the <code>_search</code> endpoint available both on <code>/index</code> and <code>/index/type</code> paths.<span class="intersentencespace"></span> An index search would be at <code>/myidx/_search</code> while a search scoped to a specific document type would be at <code>/myidx/mytype/_search</code>.<span class="intersentencespace"></span> The job of the Search API is to invoke a query with various parameters such as maximum result set size, result offset location, and a number of performance tuning options.<span class="intersentencespace"></span> The Search API also provides for both <em>Faceting</em> and <em>Filtering</em>, topics covered in subsequent chapters.</p> 
      <p><a class="hyperref" href="searching_data_fragment.html#fig-simpleq">Figure <span class="ref">3.1</span></a> shows a bare bones invocation of the Search API. In the example only the <code>size</code> and <code>query</code> parameters are set, no facets or filters are applied.<span class="intersentencespace"></span> The query itself is quite simple as well, simply looking for matches for the term “skateboard” in the “hobbies” field.<span class="intersentencespace"></span> The <code>_search</code> endpoint works with both the <code>GET</code> and <code>POST</code> HTTP methods.</p> 
      <div data-number="3.1" data-tralics-id="uid37" id="fig-simpleq" class="codelisting">
       <div class="heading">
        <span class="number">F 3.1</span> 
        <span class="description">Simple Query</span> 
       </div> 
       <div class="code">
        <div class="highlight">
         <pre><span class="p">{</span>
  <span class="s2">"size"</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"hobbies"</span><span class="o">:</span> <span class="s2">"skateboard"</span><span class="p">}</span>
     <span class="p">}}</span>
</pre>
        </div>
       </div>
      </div>
      <p>The Query DSL is used to determine which documents match given criteria.<span class="intersentencespace"></span> It also ranks documents in order of their <em>similarity</em>, the proper technical term for describing how close a document matches a query in Lucene.<span class="intersentencespace"></span> The similarity’s value is usually known as the document’s <em>score</em>.<span class="intersentencespace"></span> The Query DSL is employed as the contents of either the <code>query</code> key in JSON posted to the <code>_search</code> endpoint as in the example above.</p> 
      <p>Let’s try this out by firing up our HTTP client and issuing the request from <a class="hyperref" href="searching_data_fragment.html#fig-simpleq">figure <span class="ref">3.1</span></a>.<span class="intersentencespace"></span> The search should return the document for <code>"gondry"</code>, the only person in our hacker database who skateboards.<span class="intersentencespace"></span> The results should look something like <a class="hyperref" href="searching_data_fragment.html#fig-simpleqres">figure <span class="ref">3.2</span></a>.<span class="intersentencespace"></span> Note that the document appears with an attached <code>_score</code> field, indicating on an arbitrary scale how well the query determined that document matched.<span class="intersentencespace"></span> Since none of the search terms appeared in our other documents, they are not present, and were not scored.</p> 
      <div data-number="3.2" data-tralics-id="uid38" id="fig-simpleqres" class="codelisting">
       <div class="heading">
        <span class="number">F 3.2</span> 
        <span class="description">Result of a Simple Query</span> 
       </div> 
       <div class="code">
        <div class="highlight">
         <pre><span class="p">{</span>
  <span class="s2">"took"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"timed_out"</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="s2">"_shards"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"total"</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">"successful"</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">"failed"</span><span class="o">:</span> <span class="mi">0</span><span class="p">},</span>
  <span class="s2">"hits"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"total"</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"max_score"</span><span class="o">:</span> <span class="mf">0.15342641</span><span class="p">,</span>
    <span class="s2">"hits"</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="s2">"_index"</span><span class="o">:</span> <span class="s2">"planet"</span><span class="p">,</span> <span class="s2">"_type"</span><span class="o">:</span> <span class="s2">"hacker"</span><span class="p">,</span>
        <span class="s2">"_id"</span><span class="o">:</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"_score"</span><span class="o">:</span> <span class="mf">0.15342641</span><span class="p">,</span>
        <span class="s2">"_source"</span><span class="o">:</span> <span class="p">{</span>
          <span class="s2">"handle"</span><span class="o">:</span> <span class="s2">"gondry"</span><span class="p">,</span>
          <span class="s2">"hobbies"</span><span class="o">:</span> <span class="p">[</span><span class="s2">"writing reddit comments"</span><span class="p">,</span> <span class="s2">"skateboarding"</span><span class="p">]}}]}}</span>
</pre>
        </div>
       </div>
      </div>
      <p>In the previous example the <code>match</code> query is about as simple as it gets in elasticsearch.<span class="intersentencespace"></span> Query types, however, are configurable.<span class="intersentencespace"></span> The match query, for instance, supports a number of options.<span class="intersentencespace"></span> It can for instance, be configured to search whole phrases by using a more verbose syntax like <a class="hyperref" href="searching_data_fragment.html#fig-searchspecific">figure <span class="ref">3.3</span></a>.</p> 
      <div data-number="3.3" data-tralics-id="uid39" id="fig-searchspecific" class="codelisting">
       <div class="heading">
        <span class="number">F 3.3</span> 
        <span class="description">Using a Match Query to Search for a Phrase</span> 
       </div> 
       <div class="code">
        <div class="highlight">
         <pre><span class="c1">// Load Dataset: hacker_planet.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">planet</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span><span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"hobbies"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"query"</span><span class="o">:</span> <span class="s2">"writing reddit comments"</span><span class="p">,</span> <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"phrase"</span><span class="p">}}}}</span>
<span class="c1">// Matches gondry who does indeed like to write reddit comments</span>
</pre>
        </div>
       </div>
      </div>
      <p>Another type of query, quite different from the <code>match</code> query is the <code>fuzzy</code> query.<span class="intersentencespace"></span> This query ranks results according to their <a target="_blank" href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>.<span class="intersentencespace"></span> Let’s perform a search with the <code>fuzzy</code> query per <a class="hyperref" href="searching_data_fragment.html#fig-fuzzysearch">figure <span class="ref">3.4</span></a> and see what we get.<span class="intersentencespace"></span> We’ll search for the improperly spelled string <code>"skateboarig"</code> this time, to see how well the fuzzy query matches text that isn’t an exact token match.</p> 
      <div data-number="3.4" data-tralics-id="uid40" id="fig-fuzzysearch" class="codelisting">
       <div class="heading">
        <span class="number">F 3.4</span> 
        <span class="description">A Fuzzy Search</span> 
       </div> 
       <div class="code">
        <div class="highlight">
         <pre><span class="c1">// Load Dataset: hacker_planet.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">planet</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span><span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"fuzzy"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"hobbies"</span><span class="o">:</span> <span class="s2">"skateboarig"</span><span class="p">}}}</span>
<span class="c1">// Matches gondry who has "skateboarding" listed as a hobby.</span>
</pre>
        </div>
       </div>
      </div>
      <p>The queries illustrated in this section only begin to cover the options available for querying within elasticsearch, which has, at the time of writing, 36 different <code>Query</code> types, and 25 different <code>Filter</code> types comprising the <a target="_blank" href="http://www.elasticsearch.org/guide/reference/query-dsl/">Query DSL</a>.</p> 
      <div data-number="3.1.1" class="subsection" data-tralics-id="uid41" id="uid41">
       <h3><a class="heading hyperref" href="/searching_data.html#uid41"><span class="number">3.1.1 </span>Mixing Queries, Filters, and Facets</a></h3> 
       <p>The Search API supports more than just the queries we’ve seen.<span class="intersentencespace"></span> It also supports filters, facets, sorting, routing to specific shards, and much more.<span class="intersentencespace"></span> A baroque example of the full Search API might look something like <a class="hyperref" href="searching_data_fragment.html#fig-baroquesearch">figure <span class="ref">3.5</span></a>.<span class="intersentencespace"></span> Don’t worry if you don’t understand everything going on in this example, as most of its content is covered in later chapters.<span class="intersentencespace"></span> The important thing is to understand that the Search API broadly encompasses a range of features designed to get data out of elasticsearch.<span class="intersentencespace"></span> We’ll cover the particulars of their use in our later chapters on Faceting and Filtering.</p> 
       <div data-number="3.5" data-tralics-id="uid42" id="fig-baroquesearch" class="codelisting">
        <div class="heading">
         <span class="number">F 3.5</span> 
         <span class="description">An Complex Search’s Skeleton</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="c1">// Load Dataset: hacker_planet.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">planet</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"from"</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s2">"size"</span><span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match_all"</span><span class="o">:</span> <span class="p">{}},</span>
  <span class="s2">"sort"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"handle"</span><span class="o">:</span> <span class="s2">"desc"</span><span class="p">},</span>
  <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"_all"</span><span class="o">:</span> <span class="s2">"coding"</span><span class="p">}},</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"hobbies"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"field"</span><span class="o">:</span> <span class="s2">"hobbies"</span><span class="p">}}}}</span>
</pre>
         </div>
        </div>
       </div>
       <p>We’re going to take a little break from our study of pulling data out to discuss analysis, the key to breaking down human language.</p> 
      </div>
     </div>
     <div data-number="3.2" class="section" data-tralics-id="cid11" id="sec-searching-analysis">
      <h2><a class="heading hyperref" href="/searching_data.html#sec-searching-analysis"><span class="number">3.2 </span>Analysis</a></h2> 
      <div data-number="3.2.1" class="subsection" data-tralics-id="uid43" id="uid43">
       <h3><a class="heading hyperref" href="/searching_data.html#uid43"><span class="number">3.2.1 </span>What is Text Analysis?</a></h3> 
       <p>Analysis is the secret sauce in elasticsearch’s ability to deal with natural language and other complex data.<span class="intersentencespace"></span> Elasticsearch has a large toolbox with which we can slice and dice words in order to efficiently searched.<span class="intersentencespace"></span> Utilizing these tools we can narrow our search space, and find common ground between linguistically similar terms.</p> 
       <p>To understand analysis we first must understand that an elasticsearch index is much like a relational one in that efficient lookup is contingent on being able to traverse a tree-like structure looking for a precise match.</p> 
       <p>Let’s start by looking at analyzing english language text with the snowball analyzer.<span class="intersentencespace"></span> The Snowball analyzer is great at figuring out what the <em>stems</em> of english words are.<span class="intersentencespace"></span> The stem of a word is its root.<span class="intersentencespace"></span> Let’s see what happens to forms of the word ‘rollerblading’ when run through the snowball analyzer.</p> 
       <div class="graphics image">
        <img alt="images/figures/analysis" src="images/figures/analysis.png">
       </div> 
       <p>It can be seen that “rollerblading” has been cut down to its stem, “rollerblad”, and that the same has happened to its cohorts “rollerblader” and “rollerbladed”.<span class="intersentencespace"></span> The Snowball analyzer is an example of a stemming analyzer, one where words are transformed into their root.</p> 
       <p>When a search is performed on an analyzed field, the query itself is analyzed, matching it up to the documents which are analyzed when added to the database.<span class="intersentencespace"></span> Reducing words to these short tokens normalizes the text allowing for fast efficient lookups.<span class="intersentencespace"></span> Whether you’re searching for “rollerblading” in any form, internally we’re just looking for “rollerblad‘”.</p> 
       <p>The next question that occurs, is wondering where and when analysis occurs once when the data is stored on the documents, and then a second time on each query as it comes in, according to the analysis rules of the fields it is matching against.<span class="intersentencespace"></span> The process by which documents are analyzed is as follows:</p> 
       <ol> 
        <li>A document update or create is received via a <code>PUT</code> or <code>POST</code> </li> 
        <li>The field values in the document are each run through an <em>analyzer</em> which converts each value to zero, one, or more indexable tokens.<span class="intersentencespace"></span> </li> 
        <li>The tokenized values are stored in an <em>index</em>, pointing back to the full version of the document.<span class="intersentencespace"></span> </li>
       </ol> 
       <p>In this way an efficient inverted index is built up, allowing for exact matches to a query.<span class="intersentencespace"></span> Since all words are reduced to stemmed tokens, efficient exact and prefix matches can be made against an identically stemmed query.<span class="intersentencespace"></span> The reason both prefix and exact matches are efficient is identical to the reason those queries are efficient in SQL indexes; traversing values stored in trees is efficient for prefixes and exact matches only.</p> 
      </div> 
      <div data-number="3.2.2" class="subsection" data-tralics-id="uid47" id="uid47">
       <h3><a class="heading hyperref" href="/searching_data.html#uid47"><span class="number">3.2.2 </span>The Analyze API</a></h3> 
       <p>The easiest way to see analysis in action is with the <a target="_blank" href="http://www.elasticsearch.org/guide/reference/api/admin-indices-analyze/">Analyze API</a>, which lets you test pieces of text against any analyzer.<span class="intersentencespace"></span> To test the words “candles” and “candle” for instance, against a snowball analyzer, you would issue the query in <a class="hyperref" href="searching_data_fragment.html#fig-snowballanalyze">Figure <span class="ref">3.6</span></a>.</p> 
       <div data-number="3.6" data-tralics-id="uid48" id="fig-snowballanalyze" class="codelisting">
        <div class="heading">
         <span class="number">F 3.6</span> 
         <span class="description">Using the Analyze API</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="nx">GET</span> <span class="s1">'/_analyze?analyzer=snowball&amp;text=candles%20candle&amp;pretty=true'</span>
</pre>
         </div>
        </div>
       </div>
       <p>In this case we’ll be analyzing the string “candles candle” to illustrate how two similar words are analyzed.<span class="intersentencespace"></span> You should get the result in <a class="hyperref" href="searching_data_fragment.html#fig-snowballanalyzeout">Figure <span class="ref">3.7</span></a>.</p> 
       <div data-number="3.7" data-tralics-id="uid49" id="fig-snowballanalyzeout" class="codelisting">
        <div class="heading">
         <span class="number">F 3.7</span> 
         <span class="description">Analysis API Output</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="p">{</span>
  <span class="s2">"tokens"</span> <span class="o">:</span> <span class="p">[</span> <span class="p">{</span>
    <span class="s2">"token"</span> <span class="o">:</span> <span class="s2">"candl"</span><span class="p">,</span>
    <span class="s2">"start_offset"</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s2">"end_offset"</span> <span class="o">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="s2">"type"</span> <span class="o">:</span> <span class="s2">"&lt;ALPHANUM&gt;"</span><span class="p">,</span>
    <span class="s2">"position"</span> <span class="o">:</span> <span class="mi">1</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="s2">"token"</span> <span class="o">:</span> <span class="s2">"candl"</span><span class="p">,</span>
    <span class="s2">"start_offset"</span> <span class="o">:</span> <span class="mi">8</span><span class="p">,</span>
    <span class="s2">"end_offset"</span> <span class="o">:</span> <span class="mi">14</span><span class="p">,</span>
    <span class="s2">"type"</span> <span class="o">:</span> <span class="s2">"&lt;ALPHANUM&gt;"</span><span class="p">,</span>
    <span class="s2">"position"</span> <span class="o">:</span> <span class="mi">2</span>
  <span class="p">}</span> <span class="p">]</span>
<span class="p">}</span>
</pre>
         </div>
        </div>
       </div>
       <p>Note that both terms have been stemmed to the same root “candl”, and that metadata about offsets, type, and position has been generated.<span class="intersentencespace"></span> All of this information is encoded within the Lucene index for use while querying.<span class="intersentencespace"></span> The position offsets in particular are important, as they are used by <code>phrase</code> queries to determine word distances.</p> 
       <p>The Analyze API is invaluable when trying to discern why some words tokenize identically and others don’t.<span class="intersentencespace"></span> If you’re stumped trying to fix a query that just won’t match, make sure you run some of the text through the Analyze API.</p> 
      </div> 
      <div data-number="3.2.3" class="subsection" data-tralics-id="uid50" id="uid50">
       <h3><a class="heading hyperref" href="/searching_data.html#uid50"><span class="number">3.2.3 </span>About Custom Analyzers</a></h3> 
       <p>There may come a time where the default analyzers provided by elasticsearch are not sufficient for your data.<span class="intersentencespace"></span> Custom analyzers allow the slicing and dicing of text into specific token streams.<span class="intersentencespace"></span> They are called for in two situations: 1.)<span class="intersentencespace"></span> When an analyzer is configurable, and non-default options are needed 2.)<span class="intersentencespace"></span> When alternate combinations of tokenizers and filters are needed.<span class="intersentencespace"></span> Before we dive in and build our analyzers, let’s look at what analyzers are made of.<span class="intersentencespace"></span> An analyzer is really a three stage pipeline comprised of the following execution steps.</p> 
       <ul> 
        <li><strong>Character Filtering:</strong> Turns the input string into a different string </li> 
        <li><strong>Tokenization:</strong> Turns the char-filtered string into an array of tokens </li> 
        <li><strong>Token Filtering:</strong> Post-processes the filtered tokens into a mutated token array </li>
       </ul> 
       <p>It should be noted that the filtering steps are optional, an analyzer is only required to turn a string into a list of tokens.<span class="intersentencespace"></span> The simplest form of analysis would be the keyword analyzer which essential is the identity function of analyzers, it simply turns a single string into a single token.<span class="intersentencespace"></span> This is functionally equivalent to marking a field <code>not_analyzed</code>.</p> 
      </div> 
      <div data-number="3.2.4" class="subsection" data-tralics-id="uid54" id="uid54">
       <h3><a class="heading hyperref" href="/searching_data.html#uid54"><span class="number">3.2.4 </span>Building a CSV Analyzer</a></h3> 
       <p>Let’s dive in by building a custom analyzer for tokenizing CSV data.<span class="intersentencespace"></span> Our goal will be to turn a string of the form “Chicken, Salt, Pepper, Bay Leaves” into the the tokens <code>["chicken", "salt", "bay leaves"]</code>.<span class="intersentencespace"></span> Our analyzer will consist of a tokenizer that splits up the string on comma boundaries, followed by a token filter that removes whitespace on the end of the tokens, followed by a final token filter that lower-cases the tokens.<span class="intersentencespace"></span> The pipeline for this custom analyzer is illustrated in <a class="hyperref" href="#fig-analyzepipelinecsv">figure <span class="undefined_ref">fig:analyzepipelinecsv</span></a>.</p> 
       <div class="graphics image">
        <img alt="images/figures/recipecustomanalyzer" src="images/figures/recipecustomanalyzer.png">
       </div> 
       <p>Custom analyzers can be stored at the index level either during or after index creation.<span class="intersentencespace"></span> If defined after creation the index must first be closed before creating the analyzer.<span class="intersentencespace"></span> Let’s create a “recipes” index, close it, update the analysis settings, and reopen it in order to experiment with a custom analyzer.<span class="intersentencespace"></span> Follow the steps in <a class="hyperref" href="searching_data_fragment.html#fig-recipeanalyzertutorial">figure <span class="ref">3.8</span></a>.</p> 
       <div data-number="3.8" data-tralics-id="uid55" id="fig-recipeanalyzertutorial" class="codelisting">
        <div class="heading">
         <span class="number">F 3.8</span> 
         <span class="description">CSV Recipe Analyzer Tutorial</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="c1">// Create the index</span>
<span class="nx">PUT</span> <span class="o">/</span><span class="nx">recipes</span>

<span class="c1">// Close the index for settings update</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">_close</span>

<span class="c1">// Create the analyzer</span>
<span class="nx">PUT</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">_settings</span>
<span class="p">{</span>
  <span class="s2">"index"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"analysis"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"tokenizer"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"comma"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"pattern"</span><span class="p">,</span> <span class="s2">"pattern"</span><span class="o">:</span> <span class="s2">","</span><span class="p">}</span>
      <span class="p">},</span>
      <span class="s2">"analyzer"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"recipe_csv"</span><span class="o">:</span> <span class="p">{</span>
         <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"custom"</span><span class="p">,</span>
         <span class="s2">"tokenizer"</span><span class="o">:</span> <span class="s2">"comma"</span><span class="p">,</span>
         <span class="s2">"filter"</span><span class="o">:</span> <span class="p">[</span><span class="s2">"trim"</span><span class="p">,</span> <span class="s2">"lowercase"</span><span class="p">]}}}}}</span>

<span class="c1">// Reopen the index</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">_open</span>
</pre>
         </div>
        </div>
       </div>
       <p>Now that the index and analyzer have been created, we can test its operation by using the <code>_analyze</code> API endpoint.<span class="intersentencespace"></span> By issuing the request in <a class="hyperref" href="searching_data_fragment.html#fig-recipeanalyzertest">figure <span class="ref">3.9</span></a> the analyzer’s operation can be validated.<span class="intersentencespace"></span> The output should include four tokens, one for each word, just as <a class="hyperref" href="#fig-analyzepipelinecsv">figure <span class="undefined_ref">fig:analyzepipelinecsv</span></a> depicts.</p> 
       <div data-number="3.9" data-tralics-id="uid56" id="fig-recipeanalyzertest" class="codelisting">
        <div class="heading">
         <span class="number">F 3.9</span> 
         <span class="description">Checking the CSV Analyzer</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">_analyze</span><span class="o">?</span><span class="nx">analyzer</span><span class="o">=</span><span class="nx">recipe_csv</span>
<span class="nx">Chicken</span><span class="p">,</span> <span class="nx">Salt</span><span class="p">,</span> <span class="nx">Pepper</span><span class="p">,</span> <span class="nx">Bay</span> <span class="nx">Leaves</span>
</pre>
         </div>
        </div>
       </div>
       <p>Now that we have our custom analyzer, we can test it on real documents.<span class="intersentencespace"></span> First, a mapping using the analyzer must be defined.<span class="intersentencespace"></span> Let’s define one per <a class="hyperref" href="searching_data_fragment.html#fig-recipeanalyzermapping">figure <span class="ref">3.10</span></a>.<span class="intersentencespace"></span> Note that the custom analyzer has been referenced by name in the <code>analyzer</code> setting for the <code>ingredients</code> field.</p> 
       <div data-number="3.10" data-tralics-id="uid57" id="fig-recipeanalyzermapping" class="codelisting">
        <div class="heading">
         <span class="number">F 3.10</span> 
         <span class="description">CSV Recipe Analyzer Mapping</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="nx">PUT</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">recipe</span><span class="o">/</span><span class="nx">_mapping</span>
<span class="p">{</span>
    <span class="s2">"recipe"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"properties"</span><span class="o">:</span> <span class="p">{</span>
         <span class="s2">"name"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"analyzer"</span><span class="o">:</span> <span class="s2">"default"</span><span class="p">},</span>
         <span class="s2">"ingredients"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"analyzer"</span><span class="o">:</span> <span class="s2">"recipe_csv"</span><span class="p">}}}}</span>
</pre>
         </div>
        </div>
       </div>
       <p>Next, we’ll index some documents per <a class="hyperref" href="searching_data_fragment.html#fig-recipeanalyzerdocs">figure <span class="ref">3.11</span></a>, over which we’ll be able to run queries using our new analyzer.</p> 
       <div data-number="3.11" data-tralics-id="uid58" id="fig-recipeanalyzerdocs" class="codelisting">
        <div class="heading">
         <span class="number">F 3.11</span> 
         <span class="description">CSV Recipe Analyzer Documents</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">recipe</span><span class="o">/</span><span class="mi">1</span>
<span class="p">{</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Chicken Picatta"</span><span class="p">,</span> <span class="s2">"ingredients"</span><span class="o">:</span> <span class="s2">"Chicken, Flour, Capers, Lemon, Parsely"</span><span class="p">}</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">recipe</span><span class="o">/</span><span class="mi">2</span>
<span class="p">{</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Bolognese Saurce"</span><span class="p">,</span> <span class="s2">"ingredients"</span><span class="o">:</span> <span class="s2">"Pork, Beef, Tomatoes, Carrots, Celery, Onions, Bay Leaves"</span><span class="p">}</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">recipe</span><span class="o">/</span><span class="mi">3</span>
<span class="p">{</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"Caprese Salad"</span><span class="p">,</span> <span class="s2">"ingredients"</span><span class="o">:</span> <span class="s2">"Mozzarella, Basil, Tomatoes"</span><span class="p">}</span>
</pre>
         </div>
        </div>
       </div>
       <p>Now that our documents are indexed, we can run a search over them per <a class="hyperref" href="searching_data_fragment.html#fig-recipeanalyzersearch">figure <span class="ref">3.12</span></a>.<span class="intersentencespace"></span> Note that the results included documents for recipes that contained either “tomatoes” <em>or</em> “mozzarella”.<span class="intersentencespace"></span> The match query by default executes an <code>or</code> of tokens.<span class="intersentencespace"></span> Since elasticsearch queries are tokenized using the same analyzer as the field they’re searching, this results in a query that looks for either term.<span class="intersentencespace"></span> The document scores are generally highest for when both terms are present.<span class="intersentencespace"></span> Accordingly, the caprese salad should be the first result, as it is the only recipe with both tomatoes and mozzarella.</p> 
       <div data-number="3.12" data-tralics-id="uid59" id="fig-recipeanalyzersearch" class="codelisting">
        <div class="heading">
         <span class="number">F 3.12</span> 
         <span class="description">CSV Recipe Analyzer Search</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="nx">POST</span> <span class="o">/</span><span class="nx">recipes</span><span class="o">/</span><span class="nx">recipe</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span><span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"ingredients"</span><span class="o">:</span> <span class="s2">"Tomatoes, mozzarella"</span><span class="p">}}}</span>
</pre>
         </div>
        </div>
       </div>
      </div>
     </div>
     <div data-number="3.3" class="section" data-tralics-id="cid12" id="sec-searching-similarity">
      <h2><a class="heading hyperref" href="/searching_data.html#sec-searching-similarity"><span class="number">3.3 </span>Ranking Based on Similarity</a></h2> 
      <p>Now we get to the crux of the biscuit, what makes elasticsearch, you know… search?<span class="intersentencespace"></span> Let’s start by thinking of search as two distinct steps.<span class="intersentencespace"></span> The first step is matching all documents that meet the given criteria.<span class="intersentencespace"></span> This is known as <em>boolean search</em> in the field of Information Retrieval, because it only specifies which documents are in the result set, and which are excluded.<span class="intersentencespace"></span> The second step is scoring the documents based on similarity to the query in order to return the documents sorted by descending score.<span class="intersentencespace"></span> These two steps are the essence of search.</p> 
      <p>Elasticsearch queries can be quite complex, especially when combined using the <code>bool</code> query type, or with filters (described later in this book).<span class="intersentencespace"></span> Multiple query types can be combined into a single query.<span class="intersentencespace"></span> These subqueries can have their scoring tuned as well, to better balance the scores of the various subqueries.<span class="intersentencespace"></span> While Elasticsearch queries are quite powerful, and can be rather complex, at the end of the day, executing a query boils down to the task of restricting the result set, scoring each document, then sorting based on that score.</p> 
      <p>The main algorithm governing the scoring of documents is what this section seeks to cover in broad strokes.<span class="intersentencespace"></span> There are multiple, configurable similarity algorithms available.<span class="intersentencespace"></span> This section seeks to describe the default TFIDF Similarity class.<span class="intersentencespace"></span> This is the most popular of the scoring algorithms, implemented in Lucene’s <code>TFIDFSimilarity</code> class.</p> 
      <p>A full accounting of the algorithm is beyond the scope of this book.<span class="intersentencespace"></span> If, however, you’re more interested in the workings of the ranking algorithm, the Lucene documentation for <a target="_blank" href="http://lucene.apache.org/core/4_2_0/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html">TFIDFSimilarity</a> is a good starting point.<span class="intersentencespace"></span> Is beyond the scope of this book.<span class="intersentencespace"></span> Understanding the algorithm in concept, however, is not too hard.<span class="intersentencespace"></span> From an execution standpoint Lucene’s general strategy is to first exclude all documents with no matches for search terms, then rank the documents that do match.<span class="intersentencespace"></span> A document’s score will be higher when:</p> 
      <ul> 
       <li>The matched term is ‘rare’, which is to say that it is found in fewer documents than other terms </li> 
       <li>The term appears in the document at a greater frequency than other terms within the document </li> 
       <li>If multiple terms are in the query and the document contains more of the query’s terms than other documents </li> 
       <li>The field or document had a boost factor specified at index-time or query time </li>
      </ul> 
      <p>The preceding list is an extreme simplification of how similarity is calculated.<span class="intersentencespace"></span> Please keep in mind that not all relationships between scoring factors are linear, and that there are a number of subtleties.<span class="intersentencespace"></span> Most of the time, however, Lucene does what you want, without requiring developers to the guts of TF/IDF. Additionally, Elasticsearch supports configurable similarity algorithms, such as the bm25 algorithm.<span class="intersentencespace"></span> If the prepackaged algorithms aren’t working for you, you can either write a <code>script</code> query, which dynamically scores documents according to whatever code you like, or even write a Java plugin implementing your own scoring algorithm.</p> 
      <p>Generally, however, TF/IDF, explicit sort orders (like date descending), and script queries, will get you to where you need to go.</p> 
     </div>
     <div data-number="3.4" class="section" data-tralics-id="cid13" id="sec-searching-faceting">
      <h2><a class="heading hyperref" href="/searching_data.html#sec-searching-faceting"><span class="number">3.4 </span>Faceting</a></h2> 
      <div data-number="3.4.1" class="subsection" data-tralics-id="uid64" id="uid64">
       <h3><a class="heading hyperref" href="/searching_data.html#uid64"><span class="number">3.4.1 </span>What is Faceting</a></h3> 
       <p>Aggregate statistics are a core part of elasticsearch, and are exposed through the Search API. Facets are always attached to a query, letting you return aggregate statistics alongside regular query results.<span class="intersentencespace"></span> Consider a user searching for movies by title.<span class="intersentencespace"></span> Using facets, you could provide aggregate counts of distinct genres within the result-set.<span class="intersentencespace"></span> If you’ve ever performed a search on an e-commerce site you’ve probably seen these exposed as drill-down options on a sidebar.</p> 
       <p>Facets are highly configurable and are somewhat composable.<span class="intersentencespace"></span> In addition to counting distinct field values, facets can count by more complex groupings, such as spans of time, nest filters, and even include full, nested, elasticsearch queries!</p> 
      </div> 
      <div data-number="3.4.2" class="subsection" data-tralics-id="uid65" id="uid65">
       <h3><a class="heading hyperref" href="/searching_data.html#uid65"><span class="number">3.4.2 </span>A Simple Faceting Example</a></h3> 
       <p>Let’s take a look at a simple faceting query.<span class="intersentencespace"></span> We’ll create a database of movies and return facets based on the movies genres alongside standard query results.<span class="intersentencespace"></span> To run these examples please load the <code>movie_db.eloader</code> data-set into your elasticsearch server.</p> 
       <p>The schema we’ll use for our movies index is illustrated in <a class="hyperref" href="searching_data_fragment.html#fig-moviedbmapping">figure <span class="ref">3.13</span></a>.<span class="intersentencespace"></span> Since we’ll be faceting the genre field, we have disabled analysis via the <code>"index": "not_analyzed"</code> setting.<span class="intersentencespace"></span> Disabling analysis ensures the entire genre field is aggregated as a single token.<span class="intersentencespace"></span> We wouldn’t want the genre “Romance” transformed into “romanc”, for instance, or “Science Fiction” to be aggregated as two separate categories “science” and “fiction”.</p> 
       <div data-number="3.13" data-tralics-id="uid66" id="fig-moviedbmapping" class="codelisting">
        <div class="heading">
         <span class="number">F 3.13</span> 
         <span class="description">Simple Movie Mapping</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="c1">// Load Dataset: movie_db.eloader</span>
<span class="nx">GET</span> <span class="o">/</span><span class="nx">movie_db</span><span class="o">/</span><span class="nx">movie</span><span class="o">/</span><span class="nx">_mapping</span><span class="o">?</span><span class="nx">pretty</span><span class="o">=</span><span class="kc">true</span>
<span class="p">{</span>
  <span class="s2">"movie"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"properties"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"actors"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"analyzer"</span><span class="o">:</span> <span class="s2">"standard"</span><span class="p">,</span>
                 <span class="s2">"position_offset_gap"</span><span class="o">:</span> <span class="mi">100</span><span class="p">},</span>
      <span class="s2">"genre"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"index"</span><span class="o">:</span> <span class="s2">"not_analyzed"</span><span class="p">},</span>
      <span class="s2">"release_year"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"integer"</span><span class="p">,</span> <span class="s2">"index"</span><span class="o">:</span> <span class="s2">"not_analyzed"</span><span class="p">},</span>
      <span class="s2">"title"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"analyzer"</span><span class="o">:</span> <span class="s2">"snowball"</span><span class="p">}</span> <span class="p">}}},</span>
      <span class="s2">"description"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"type"</span><span class="o">:</span> <span class="s2">"string"</span><span class="p">,</span> <span class="s2">"analyzer"</span><span class="o">:</span> <span class="s2">"snowball"</span><span class="p">}</span> <span class="p">}}}</span>
</pre>
         </div>
        </div>
       </div>
       <p>Let’s take a look at faceting in action by running <a class="hyperref" href="searching_data_fragment.html#fig-simpletermsfacet">figure <span class="ref">3.14</span></a>.<span class="intersentencespace"></span> This query searches for movies with a description containing “hacking”.<span class="intersentencespace"></span> In addition to returning a list of movies matching those criteria, the query returns a list of facets showing which genres have descriptions containing the term “hacking”, and how often films are in that genre with a matching description.</p> 
       <div data-number="3.14" data-tralics-id="uid67" id="fig-simpletermsfacet" class="codelisting">
        <div class="heading">
         <span class="number">F 3.14</span> 
         <span class="description">Simple Terms Faceting</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="c1">// Load Dataset: movie_db.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">movie_db</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span><span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"description"</span><span class="o">:</span> <span class="s2">"hacking"</span><span class="p">}},</span>
 <span class="s2">"aggs"</span><span class="o">:</span> <span class="p">{</span>
   <span class="s2">"genre"</span><span class="o">:</span> <span class="p">{</span>
     <span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"genre"</span><span class="p">}}}}</span>
</pre>
         </div>
        </div>
       </div>
       <p>After running the query, you should see that the standard results, under <code>hits</code> contain the movies “Hackers” and “Swordfish”.<span class="intersentencespace"></span> You should also see, under the <code>facets</code> section, data similar to <a class="hyperref" href="searching_data_fragment.html#fig-simpletermsfacetresults">figure <span class="ref">3.15</span></a>.</p> 
       <div data-number="3.15" data-tralics-id="uid68" id="fig-simpletermsfacetresults" class="codelisting">
        <div class="heading">
         <span class="number">F 3.15</span> 
         <span class="description">Simple Terms Facet Results</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="p">{</span>
  <span class="s2">"took"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="s2">"timed_out"</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="s2">"_shards"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"total"</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s2">"successful"</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s2">"failed"</span><span class="o">:</span> <span class="mi">0</span>
  <span class="p">},</span>
  <span class="s2">"hits"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"total"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s2">"max_score"</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s2">"hits"</span><span class="o">:</span> <span class="p">[]</span>
  <span class="p">},</span>
  <span class="s2">"aggregations"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"genre"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"doc_count_error_upper_bound"</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s2">"sum_other_doc_count"</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s2">"buckets"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="s2">"key"</span><span class="o">:</span> <span class="s2">"Action"</span><span class="p">,</span>
          <span class="s2">"doc_count"</span><span class="o">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s2">"key"</span><span class="o">:</span> <span class="s2">"Crime"</span><span class="p">,</span>
          <span class="s2">"doc_count"</span><span class="o">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="s2">"key"</span><span class="o">:</span> <span class="s2">"Drama"</span><span class="p">,</span>
          <span class="s2">"doc_count"</span><span class="o">:</span> <span class="mi">1</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
         </div>
        </div>
       </div>
       <p>Notice how the counts for each genre are equal to the number of times those genres appear in the result-set.<span class="intersentencespace"></span> Additionally, you can see that the facets are sorted by frequency, the top facets come first.<span class="intersentencespace"></span> In a scenario where the facet list is very long you can control how many are returned with the <code>size</code> option for the <code>Terms</code> facet.</p> 
      </div>
     </div>
     <div data-number="3.5" class="section" data-tralics-id="cid14" id="sec-searching-filtering">
      <h2><a class="heading hyperref" href="/searching_data.html#sec-searching-filtering"><span class="number">3.5 </span>Filtering</a></h2> 
      <p>Using filters effectively is every bit as important as using queries effectively in elasticsearch.<span class="intersentencespace"></span> They deserve special attention, in-fact, because they have a drastic effect on the execution path of a search.<span class="intersentencespace"></span> While queries describe which documents appear in results and how they are to be scored, filters only describe which documents appear in results.<span class="intersentencespace"></span> This can result in a significantly faster query.<span class="intersentencespace"></span> Additionally, some criteria can only be specified via a filter, no query equivalent exists.<span class="intersentencespace"></span> Filters can be used to optimize a query by efficiently cutting down the result set without executing relatively expensive scoring calculations.<span class="intersentencespace"></span> Filters may also be used in the case where a term must be matched against, but contribution to the document’s overall score should be be a fixed amount regardless of the TF/IDF score.<span class="intersentencespace"></span> Additionally, unlike queries, filters may be cached, leading to significant performance gains when repeatedly invoked.</p> 
      <p>Elasticsearch exposes filters in three different ways, which can be somewhat confusing.<span class="intersentencespace"></span> The three different types control whether the filter is applied to either the query and facets, a query or subquery, or a facet.<span class="intersentencespace"></span> A disambiguating list is presented below.</p> 
      <ul> 
       <li><strong>Queries of the <code>filtered</code>/<code>constant_score</code> type:</strong> These are both nested in the <code>query</code> field.<span class="intersentencespace"></span> Filters here will affect both query results and facet counts.<span class="intersentencespace"></span> </li> 
       <li><strong>The top-level <code>filter</code> element:</strong> Specifying a <code>filter</code> at the root of the search, alongside the <code>query</code> and <code>facet</code> elements, will filter only the query, but not affect facets.<span class="intersentencespace"></span> </li> 
       <li><strong>Facets with the <code>facet_filter</code> option:</strong> Adding each facet supports an optional <code>facet_filter</code> element, which can be used to pre-filter data before being aggregated.<span class="intersentencespace"></span> This filtering will only affect the facet it is defined in, and will not affect query results.<span class="intersentencespace"></span> </li>
      </ul> 
      <p>The next section of this book will explain each type in detail.</p> 
      <div data-number="3.5.1" class="subsection" data-tralics-id="uid72" id="uid72">
       <h3><a class="heading hyperref" href="/searching_data.html#uid72"><span class="number">3.5.1 </span>The Three Different Stages of Filtering</a></h3> 
       <div data-number="3.5.1.1" class="subsubsection" data-tralics-id="uid73" id="uid73">
        <h4><a class="heading" href="#uid73">Using the filtered and constant_score queries</a></h4> 
        <p>Most use cases call for a filter of both facets and query results.<span class="intersentencespace"></span> For these use cases one must construct a search using either the <code>filtered</code> or <code>constant_score</code> queries.<span class="intersentencespace"></span> Both types allow for a regular query to be nested inside.<span class="intersentencespace"></span> The filter runs first, followed by the query and any facets, potentially providing a healthy speed boost if the filters restrict the result-set enough.<span class="intersentencespace"></span> An example of this can be seen in <a class="hyperref" href="searching_data_fragment.html#fig-filtersimple">figure <span class="ref">3.16</span></a>.</p> 
        <div data-number="3.16" data-tralics-id="uid74" id="fig-filtersimple" class="codelisting">
         <div class="heading">
          <span class="number">F 3.16</span> 
          <span class="description">Using a filtered Query</span> 
         </div> 
         <div class="code">
          <div class="highlight">
           <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"department_name"</span><span class="p">}}},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"filtered"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"fake"</span><span class="p">}},</span>
      <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Books"</span><span class="p">}}}}}</span>
</pre>
          </div>
         </div>
        </div>
        <p>The <code>filtered</code> query takes two arguments, a <code>query</code>, which is an arbitrary nested query, and a <code>filter</code> to apply before the query part executes.<span class="intersentencespace"></span> The filter executes first, reducing the result-set significantly before the query executes.</p> 
        <p>The <code>constant_score</code> filter is similar to the <code>filter</code> query, except that it takes no nested <code>query</code> argument.<span class="intersentencespace"></span> Instead, a <code>constant_score</code> query takes a <code>boost</code> argument that is set as the score for every returned document when combined with other queries.<span class="intersentencespace"></span> The score will always be set as <code>1</code> when executing a simple <code>constant_score</code> query as in <a class="hyperref" href="searching_data_fragment.html#fig-filterconstantscore">figure <span class="ref">3.17</span></a>, as there is no utility in assigning a different score if the numbers stay the same.<span class="intersentencespace"></span> If, however, a <code>constant_score</code> query is combined with another query, the boost will be activated and used to determine the document’s score.<span class="intersentencespace"></span> An example of setting the boost to weight two different constant score queries can be seen in <a class="hyperref" href="searching_data_fragment.html#fig-filterconstantscorecombo">figure <span class="ref">3.18</span></a>.</p> 
        <div data-number="3.17" data-tralics-id="uid75" id="fig-filterconstantscore" class="codelisting">
         <div class="heading">
          <span class="number">F 3.17</span> 
          <span class="description">Using a constant_score Query</span> 
         </div> 
         <div class="code">
          <div class="highlight">
           <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"department_name"</span><span class="p">}}},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"constant_score"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"boost"</span><span class="o">:</span> <span class="mf">1.5</span><span class="p">,</span>
      <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Books"</span><span class="p">}}}}}</span>
</pre>
          </div>
         </div>
        </div>
        <div data-number="3.18" data-tralics-id="uid76" id="fig-filterconstantscorecombo" class="codelisting">
         <div class="heading">
          <span class="number">F 3.18</span> 
          <span class="description">Combining constant_score Queries</span> 
         </div> 
         <div class="code">
          <div class="highlight">
           <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"department_name"</span><span class="p">}}},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"bool"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"should"</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="s2">"constant_score"</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"boost"</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="nx">filter</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Housewares"</span><span class="p">}}}},</span>
        <span class="p">{</span>
          <span class="s2">"constant_score"</span><span class="o">:</span> <span class="p">{</span>
          <span class="s2">"boost"</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
          <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Books"</span><span class="p">}}}}]}}}</span>
</pre>
          </div>
         </div>
        </div>
        <p>The <code>constant_score</code> query’s exclusive use of filters makes for a very fast query since there is no secondary <code>query</code> phase.<span class="intersentencespace"></span> The catch here is that there’s no way to actually determine a score for the documents, hence the assignation of a fixed score to each document returned via the <code>constant_score</code> query’s <code>boost</code> field.<span class="intersentencespace"></span> An example can be seen in <a class="hyperref" href="searching_data_fragment.html#fig-filterconstantscore">figure <span class="ref">3.17</span></a>.</p> 
        <p>It should also be noted that a <code>constant_score</code> query can take a <code>query</code> as an argument, in which case the scoring portion of the query will be ignored, and the query is used only as a filter.</p> 
       </div>
      </div> 
      <div data-number="3.5.2" class="subsection" data-tralics-id="uid77" id="uid77">
       <h3><a class="heading hyperref" href="/searching_data.html#uid77"><span class="number">3.5.2 </span>Using the <code>filter</code> element</a></h3> 
       <p>The <code>filter</code> element is perhaps the most confusing API in elasticsearch.<span class="intersentencespace"></span> This confusion arises due to the fact that <code>constant_score</code> and <code>filtered</code> queries are nested inside the top-level <code>query</code> element, yet affect both queries and facets, while the <code>filter</code> element is located at the root of a search, as a sibling to <code>query</code> and <code>facets</code>, yet only affects the query.<span class="intersentencespace"></span> It is important to keep this in mind, as filtering only the query can cause a large number of documents to be faceted mistakenly with dire performance consequences.</p> 
       <p>The content of the <code>filter</code> field is identical to the <code>filter</code> field of the previously seen <code>constant_score</code> and <code>filtered</code> queries, it simply lives at the root of the request’s JSON. An illustration of this can be seen in <a class="hyperref" href="searching_data_fragment.html#fig-filterelement">figure <span class="ref">3.19</span></a>.<span class="intersentencespace"></span> Notice how the facets in the results indicate that the there are a total of two documents matching, one in “Electronics”, the other in “Books”, yet the <code>hits</code> field only shows results from the “Books” department as specified by the filter.</p> 
       <div data-number="3.19" data-tralics-id="uid78" id="fig-filterelement" class="codelisting">
        <div class="heading">
         <span class="number">F 3.19</span> 
         <span class="description">Using the filter Element</span> 
        </div> 
        <div class="code">
         <div class="highlight">
          <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"department_name"</span><span class="p">}}},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"description"</span><span class="o">:</span> <span class="s2">"tcp"</span><span class="p">}},</span>
  <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Books"</span><span class="p">}}}</span>
</pre>
         </div>
        </div>
       </div> 
       <div data-number="3.5.2.1" class="subsubsection" data-tralics-id="uid79" id="uid79">
        <h4><a class="heading" href="#uid79">Filtering Facets with a <code>facet_filter</code></a></h4> 
        <p>Facet filters are the opposite of the <code>filter</code> element, they only filter for a single facet, and do not affect query results at all.<span class="intersentencespace"></span> Note, this is quite different from a filter facet, which is discussed in the next section.<span class="intersentencespace"></span> A <code>facet_filter</code> facets like a normal facet; it simply ignores documents that don’t match the filter.<span class="intersentencespace"></span> An example of a facet filter can be seen in <a class="hyperref" href="searching_data_fragment.html#fig-filterfacetfilter">figure <span class="ref">3.20</span></a>.</p> 
        <div data-number="3.20" data-tralics-id="uid80" id="fig-filterfacetfilter" class="codelisting">
         <div class="heading">
          <span class="number">F 3.20</span> 
          <span class="description">Using a facet_filter</span> 
         </div> 
         <div class="code">
          <div class="highlight">
           <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"department"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"field"</span><span class="o">:</span> <span class="s2">"department_name"</span><span class="p">},</span>
       <span class="s2">"facet_filter"</span><span class="o">:</span> <span class="p">{</span>
         <span class="s2">"term"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="s2">"Books"</span><span class="p">}}}</span>
  <span class="p">},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match_all"</span><span class="o">:</span> <span class="p">{}}}</span>
</pre>
          </div>
         </div>
        </div>
        <p>The same performance warnings go for a <code>facet_filter</code> as for the top-level <code>filter</code> element.<span class="intersentencespace"></span> By only filtering facets, there is potential for the <code>query</code> to match a very large number of documents, making for a potentially expensive search.</p> 
       </div> 
       <div data-number="3.5.2.2" class="subsubsection" data-tralics-id="uid81" id="uid81">
        <h4><a class="heading" href="#uid81">Filter Facets</a></h4> 
        <p>Once again, the filter API proves confusing.<span class="intersentencespace"></span> The previous section discussed the use of a <code>facet_filter</code>.<span class="intersentencespace"></span> In this section, we will cover the use of filter facets, which are entirely different.<span class="intersentencespace"></span> A filter facet is used to count the number of documents matching both the search <code>query</code> and an optional filter.<span class="intersentencespace"></span> An example can be in <a class="hyperref" href="searching_data_fragment.html#fig-filterfacet">figure <span class="ref">3.21</span></a>.<span class="intersentencespace"></span> An easy way to remember when to use filter facets vs facet filters is to remember that filter facets always return a single count, whereas a <code>facet_filter</code> can return multiple counts for different terms matching a filter.</p> 
        <div data-number="3.21" data-tralics-id="uid82" id="fig-filterfacet" class="codelisting">
         <div class="heading">
          <span class="number">F 3.21</span> 
          <span class="description">Using a Filter Facet</span> 
         </div> 
         <div class="code">
          <div class="highlight">
           <pre><span class="c1">// Load Dataset: products.eloader</span>
<span class="nx">POST</span> <span class="o">/</span><span class="nx">products</span><span class="o">/</span><span class="nx">_search</span>
<span class="p">{</span>
  <span class="s2">"facets"</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">"books_and_housewares"</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">"filter"</span><span class="o">:</span> <span class="p">{</span>
        <span class="s2">"terms"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"department_name"</span><span class="o">:</span> <span class="p">[</span><span class="s2">"Books"</span><span class="p">,</span> <span class="s2">"Housewares"</span><span class="p">]}}}},</span>
  <span class="s2">"query"</span><span class="o">:</span> <span class="p">{</span><span class="s2">"match_all"</span><span class="o">:</span> <span class="p">{}}}</span>
</pre>
          </div>
         </div>
        </div>
       </div>
      </div> 
      <div data-number="3.5.3" class="subsection" data-tralics-id="uid83" id="uid83">
       <h3><a class="heading hyperref" href="/searching_data.html#uid83"><span class="number">3.5.3 </span>Building Filters</a></h3> 
       <p>Up to this point, we’ve only used the simplest of the filters, the <code>terms</code> filter, which is essentially identical in concept to the <code>match</code> query, with the notable difference that the analysis phase is skipped.<span class="intersentencespace"></span> Filters can operate on many different criteria, including such operations as numerical range, inclusion in a geographic area, matching various textual criteria, and compositions of other filters.<span class="intersentencespace"></span> Filters can be combined using boolean expressions just like queries.</p> 
       <p>Subsequent chapters in this book model world problems, and in them there will be examples of more complex filter usage.</p> 
      </div>
     </div>
    </ol> 
    <div class="prev-next"> 
     <a href="searching_a_book.html" class="next">Chapter 4 Searching a Book</a> 
    </div>  
    <div id="disqus_thread"></div> 
    <script type="text/javascript">
  var disqus_shortname = 'exploringelasticsearch';

  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> 
    <noscript>
     Please enable JavaScript to view the 
     <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript> 
    <a class="dsq-brlink" href="http://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a> 
   </div> 
  </article> 
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script> 
  <script type="text/javascript">
$(function () {
  $('.codelisting:contains(Load Dataset:)').
    closest('.codelisting').
    prepend("<div class='dataset-explain'><span class='icon'>&#9881;</span> This example requires you to load a dataset. <a href='/book/an-overview/up-and-running.html#sec14'>Learn how</a></div.")});</script>   
 </body>
</html>