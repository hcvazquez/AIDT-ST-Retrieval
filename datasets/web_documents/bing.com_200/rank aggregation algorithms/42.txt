<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en">
 <head> 
  <link rel="apple-touch-icon" href="http://introcs.cs.princeton.edu/apple-touch-icon.png"> 
  <link rel="shortcut icon" href="http://introcs.cs.princeton.edu/favicon.ico"> 
  <link rel="stylesheet" href="http://introcs.cs.princeton.edu/introcs.css" type="text/css" media="screen"> 
  <meta name="google-site-verification" content="nYspbl5bNBQrNZKguiAAFTMVM7sq2P1WQYc8Oi6Okl0"> 
  <meta name="msvalidate.01" content="D4B7F6DF793EFF34DE96F611C2A367A5"> 
  <!-- IE HACKS --> 
  <!--[if IE]>
<style type="text/css" media="screen">
 #menu ul li {float: left; width: 100%;}
</style>
<![endif]--> 
  <!--[if lt IE 7]>
<style type="text/css" media="screen">
body {
behavior: url(/csshover.htc);
} 
#menu ul li {float: left; width: 100%;}
#menu ul li a {height: 1%;} 

#menu a, #menu h2 {
font: bold 0.9em/1.5em arial, helvetica, sans-serif;
} 

</style>
<![endif]--> 
  <!--  use // instead of https:// or http:// to let it use whatever was used to access the page initially --> 
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> 
  <!-- scale font size for MathJax --> 
  <script type="text/x-mathjax-config"> 
    MathJax.Hub.Config({ 
        "HTML-CSS": { scale: 90, linebreaks: { automatic: true } }, 
        SVG: { linebreaks: { automatic:true } }, 
        displayAlign: "left" });
</script> 
  <title>
Monte Carlo Simulation</title> 
  <script type="text/javascript" src="http://algs4.cs.princeton.edu/media/swfobject.js"></script> 
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-10811519-1', 'auto');
  ga('send', 'pageview');

</script> 
  <meta HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1"> 
  <meta NAME="AUTHOR" CONTENT="Robert Sedgewick and Kevin Wayne"> 
  <meta NAME="KEYWORDS" CONTENT="Monte Carlo Simulation,Java,Programming,interdisciplinary,Computer science,cs,intro,introduction,sedgewick,wayne"> 
  <meta NAME="DESCRIPTION" CONTENT="This textbook provides an interdisciplinary approach to the CS 1 curriculum. We teach the classic elements of programming, using an " objects-in-the-middle" approach that emphasizes data abstraction. A key feature of the book is manner in which we motivate each programming concept by examining its impact on specific applications, taken from science, engineering, and commerce."> 
  <meta NAME="TITLE" CONTENT="Monte Carlo Simulation. Introduction to Programming in Java by Sedgewick and Wayne"> 
  <meta NAME="ROBOTS" CONTENT="INDEX,FOLLOW"> 
  <meta name="verify-v1" content="D4o9ikkHbNKapHncCP8ZmiD9Z2DBbrJyaSV0lyce+3w="> 
 </head> 
 <body> 
  <div id="menu"> 
   <div align="center"> 
    <a class="picture" href="/home"> <img src="../cover.png" width="190" height="235" border="0" alt="Introduction to Programming in Java"> </a> 
   </div> 
   <ul> 
    <li><a class="title" href="/java/home">Intro to Programming</a> 
     <ul> 
      <li> <a href="http://introcs.cs.princeton.edu/java/10elements">1.&nbsp;&nbsp;Elements of Programming</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/11hello">1.1&nbsp;&nbsp;Your First Program</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/12types">1.2&nbsp;&nbsp;Built-in Types of Data</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/13flow">1.3&nbsp;&nbsp;Conditionals and Loops</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/14array">1.4&nbsp;&nbsp;Arrays</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/15inout">1.5&nbsp;&nbsp;Input and Output</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/16pagerank">1.6&nbsp;&nbsp;Case Study: PageRank</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/20functions">2.&nbsp;&nbsp;Functions</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/21function">2.1&nbsp;&nbsp;Static Methods</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/22library">2.2&nbsp;&nbsp;Libraries and Clients</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/23recursion">2.3&nbsp;&nbsp;Recursion</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/24percolation">2.4&nbsp;&nbsp;Case Study: Percolation</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/30oop">3.&nbsp;&nbsp;OOP</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/31datatype">3.1&nbsp;&nbsp;Using Data Types</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/32class">3.2&nbsp;&nbsp;Creating Data Types</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/33design">3.3&nbsp;&nbsp;Designing Data Types</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/34nbody">3.4&nbsp;&nbsp;Case Study: N-Body</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/40algorithms">4.&nbsp;&nbsp;Data Structures</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/41analysis">4.1&nbsp;&nbsp;Performance</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/42sort">4.2&nbsp;&nbsp;Sorting and Searching</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/43stack">4.3&nbsp;&nbsp;Stacks and Queues</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/44st">4.4&nbsp;&nbsp;Symbol Tables</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/45graph">4.5&nbsp;&nbsp;Case Study: Small World</a> </li>
       </ul> </li>
     </ul> </li>
   </ul> 
   <ul> 
    <li><a class="title" href="/java/cs">Computer Science</a> 
     <ul> 
      <li> <a href="http://introcs.cs.princeton.edu/java/50theory">5.&nbsp;&nbsp;Theory of Computing</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/51language">5.1&nbsp;&nbsp;Formal Languages</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/52turing">5.2&nbsp;&nbsp;Turing Machines</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/53universality">5.3&nbsp;&nbsp;Universality</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/54computability">5.4&nbsp;&nbsp;Computability</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/55intractability">5.5&nbsp;&nbsp;Intractability</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/99crypto">9.9&nbsp;&nbsp;Cryptography</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/60machine">6.&nbsp;&nbsp;A Computing Machine</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/61data">6.1&nbsp;&nbsp;Representing Info</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/62toy">6.2&nbsp;&nbsp;TOY Machine</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/63programming">6.3&nbsp;&nbsp;TOY Programming</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/64simulator">6.4&nbsp;&nbsp;TOY Virtual Machine</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/70circuits">7.&nbsp;&nbsp;Building a Computer</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/71boolean">7.1&nbsp;&nbsp;Boolean Logic</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/72circuit">7.2&nbsp;&nbsp;Basic Circuit Model</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/73combinational">7.3&nbsp;&nbsp;Combinational Circuits</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/74sequential">7.4&nbsp;&nbsp;Sequential Circuits</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/75architecture">7.5&nbsp;&nbsp;Digital Devices</a> </li>
       </ul> </li>
     </ul> </li>
   </ul> 
   <ul> 
    <li><a class="title" href="/java/home">Beyond</a> 
     <ul> 
      <li> <a href="http://introcs.cs.princeton.edu/java/80systems">8.&nbsp;&nbsp;Systems</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/81library">8.1&nbsp;&nbsp;Library Programming</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/82compiler">8.2&nbsp;&nbsp;Compilers</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/83os">8.3&nbsp;&nbsp;Operating Systems</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/84network">8.4&nbsp;&nbsp;Networking</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/85application">8.5&nbsp;&nbsp;Applications Systems</a> </li>
       </ul> </li>
      <li> <a href="http://introcs.cs.princeton.edu/java/90scientific">9.&nbsp;&nbsp;Scientific Computation</a> 
       <ul> 
        <li> <a href="http://introcs.cs.princeton.edu/java/91float">9.1&nbsp;&nbsp;Floating Point</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/92symbolic">9.2&nbsp;&nbsp;Symbolic Methods</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/93integration">9.3&nbsp;&nbsp;Numerical Integration</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/94diffeq">9.4&nbsp;&nbsp;Differential Equations</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/95linear">9.5&nbsp;&nbsp;Linear Algebra</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/96optimization">9.6&nbsp;&nbsp;Optimization</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/97data">9.7&nbsp;&nbsp;Data Analysis</a> </li>
        <li> <a href="http://introcs.cs.princeton.edu/java/98simulation">9.8&nbsp;&nbsp;Simulation</a> </li>
       </ul> </li>
     </ul> </li>
   </ul> 
   <ul> 
    <li><a class="title"> Related Booksites</a> 
     <table width="100%" border="0" cellspacing="0" cellpadding="0"> 
      <tbody>
       <tr> 
        <td align="center"> <a class="booksite" href="http://introcs.cs.princeton.edu/python"> <img src="http://introcs.cs.princeton.edu/java/cover-python.png" width="73" height="91" border="0" alt="Introduction to Programming in Python
               by Robert Sedgewick, Kevin Wayne, and Robert Dondero"> </a> </td>
        <td align="center"> <a class="booksite" href="http://algs4.cs.princeton.edu"> <img src="http://algs4.cs.princeton.edu/cover.png" width="73" height="91" border="0" alt="Algorihtms, 4th Edition by Robert Sedgewick and Kevin Wayne"> </a> </td>
       </tr> 
      </tbody>
     </table> </li>
    <li><a class="title" href="/home">Web Resources</a> 
     <ul> 
      <li> <a href="/java/faq">FAQ</a> </li>
      <li> <a href="/java/data">Data</a> </li>
      <li> <a href="/java/code">Code</a> </li>
      <li> <a href="/java/errata">Errata</a> </li>
      <li> <a href="/java/11appendix">Appendices</a> 
       <ul> 
        <li> <a href="/java/11precedence">A. &nbsp; Operator Precedence</a> </li>
        <li> <a href="/java/11style">B. &nbsp; Writing Clear Code</a> </li>
        <li> <a href="/java/11glossary">C. &nbsp; Glossary</a> </li>
        <li> <a href="/java/11cheatsheet">D. &nbsp; Java Cheatsheet</a> </li>
        <li> <a href="/java/11matlab">E. &nbsp; Matlab</a> </li>
       </ul> </li>
      <li> <a href="/java/lectures">Lecture Slides</a> </li>
      <li> <a href="/java/assignments">Programming Assignments</a> </li>
     </ul> </li>
   </ul> 
   <p><br> <script>
  (function() {
    var cx = '005649317310637734940:_d158dlngnk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script> 
    <gcse:searchbox-only></gcse:searchbox-only> </p>
   <p><br> </p>
  </div> 
  <div id="content"> 
   <h1>9.8 &nbsp; Monte Carlo Simulation</h1> 
   <p><br> <font color="red"> This section under major construction. </font> </p>
   <p> In 1953 Enrico Fermi, John Pasta, and Stanslaw Ulam created the first "computer experiment" to study a vibrarting atomic lattice. Nonlinear system couldn't be analyzed by classical mathematics. </p>
   <p> Simulation = analytic method that imitates a physical system. Monte Carlo simulation = use randomly generated values for uncertain variables. Named after famous casino in Monaco. At essentially each step in the evolution of the calculation, Repeat several times to generate range of possible scenarios, and average results. Widely applicable brute force solution. Computationally intensive, so use when other techniques fail. Typically, accuracy is proportional to square root of number of repetitions. Such techniques are widely applied in various domains including: designing nuclear reactors, predicting the evolution of stars, forecasting the stock market, etc. </p>
   <p><b>Generating random numbers.</b> The math library function <tt>Math.random</tt> generate a pseudo-random number greater than or equal to 0.0 and less than 1.0. If you want to generate random integers or booleans, the best way is to use the library <tt>Random</tt>. Program <a href="RandomDemo.java.html">RandomDemo.java</a> illustrates how to use it. </p>
   <blockquote> 
    <table> 
     <tbody>
      <tr>
       <td><pre>
Random random = new Random();
boolean a = random.nextBoolean();   // true or false
int     b = random.nextInt();       // between -2^31 and 2^31 - 1
int     c = random.nextInt(100);    // between 0 and 99
double  d = random.nextDouble();    // between 0.0 and 1.0
double  e = random.nextGaussian();  // Gaussian with mean 0 and stddev = 1
</pre></td>
      </tr> 
     </tbody>
    </table> 
   </blockquote> 
   <p> Note that you should only create a new <tt>Random</tt> object once per program. You will not get more "random" results by creating more than one. For debugging, you may wish to produce the same sequence of pseudo-random number each time your program executes. To do this, invoke the constructor with a <tt>long</tt> argument. </p>
   <blockquote> 
    <table> 
     <tbody>
      <tr>
       <td><pre>
Random random = new Random(1234567L);
</pre></td>
      </tr> 
     </tbody>
    </table> 
   </blockquote> 
   <p> The pseudo-random number generator will use 1234567 as the seed. Use <tt>SecureRandom</tt> for cryptographically secure pseudo-random numbers, e.g., for cryptography or slot machines. </p>
   <p><b>Linear congruential random number generator.</b> With integer types we must be cognizant of overflow. Consider a * b (mod m) as an example (either in context of a^b (mod m) or linear congruential random number generator: Given constants a, c, m, and a seed x[0], iterate: x = (a * x + c) mod m. Park and Miller suggest a = 16807, m = 2147483647, c = 0 for 32-bit signed integers. To avoid overflow, use Schrage's method. </p>
   <blockquote> 
    <table> 
     <tbody>
      <tr>
       <td><pre>
Precompute:  q = m / a, r = m % a
Iterate:     x = a * (x - x/ q) * q) - r * (x / q)
</pre></td>
      </tr> 
     </tbody>
    </table> 
   </blockquote> 
   <p> Exercise: compute cycle length. </p>
   <p><b>Library of probability functions.</b> OR-Objects contains many classic <a href="http://opsresearch.com/OR-Objects/api/drasys/or/prob/package-summary.html"> probability distributions and random number generators</a>, including Normal, F, Chi Square, Gamma, Binomial, Poisson. You can download the <a href="http://opsresearch.com/cgi-bin/freeware.cgi/or124.jar">jar file</a> here. Program <a href="ProbDemo.java.html">ProbDemo.java</a> illustrates how to use it. It generate one random value from the gamma distribution and 5 from the binomial distribution. Note that the method is called <tt>getRandomScaler</tt> and not <tt>getRandomScalar</tt>. </p>
   <blockquote> 
    <table> 
     <tbody>
      <tr>
       <td><pre>
GammaDistribution x = new GammaDistribution(2, 3);
System.out.println(x.getRandomScaler());

BinomialDistribution y = new BinomialDistribution(0.1, 100);
System.out.println(y.getRandomVector(5));
</pre></td>
      </tr> 
     </tbody>
    </table> 
   </blockquote> 
   <p><b>Queuing models.</b> M/M/1, etc. A manufacturing facility has M identical machines. Each machine fails after a time that is exponentially distributed with mean 1 / ?. A single repair person is responsible for maintaining all the machines, and the time to fix a machine is exponentially distributed with mean 1 / ?. Simulate the fraction of time in which no machines are operational. </p>
   <p></p>
   <h2>Diffusion-limited aggregation.</h2> Diffuse = undergo random walk. The physical process 
   <em>diffusion-limited aggregation</em> (DLA) models the formation of an aggregate on a surface, including lichen growth, the generation of polymers out of solutions, carbon deposits on the walls of a cylinder of a Diesel engine, path of electric discharge, and urban settlement. 
   <p> The modeled aggregate forms when particles are released one at a time into a volume of space and, influenced by random thermal motion, they diffuse throughout the volume. There is a finite probability that the short-range attraction between particles will influence the motion. Two particles which come into contact with each other will stick together and form a larger unit. The probability of sticking increases as clusters of occupied sites form in the aggregate, stimulating further growth. Simulate this process in 2D using Monte Carlo methods: Create a 2D grid and introduce particles to the lattice through a launching zone one at a time. After a particle is launched, it wanders throughout with a random walk until it either sticks to the aggregate or wanders off the lattice into the <em>kill zone</em>. If a wandering particle enters an empty site next to an occupied site, then the particle's current location automatically becomes part of the aggregate. Otherwise, the random walk continues. Repeat this process until the aggregate contains some pre-determined number of particles. <em>Reference:</em> Wong, Samuel, Computational Methods in Physics and Engineering, 1992. </p>
   <p> Program <a href="DLA.java.html">DLA.java</a> simulates the growth of a DLA with the following properties. It uses the helper data type <a href="Picture.java.html">Picture.java</a>. Set the initial aggregate to be the bottom row of the N-by-N lattice. Launch the particles from a random cell in top row. Assume that the particle goes up with probability 0.15, down with probability 0.35, and left or right with probability 1/4 each. Continue until the particles stick to a neighboring cell (above, below, left, right, or one of the four diagonals) or leaves the N-by-N lattice. The preferred downward direction is analogous to the effect of a temperature gradient on Brownian motion, or like how when a crystal is formed, the bottom of the aggregate is cooled more than the top; or like the influence of a gravitational force. For effect, we color the particles in the order they are released according to the rainbow from red to violet. Below are three simulations with N = 176; here is an image with <a href="dla-big.png">N = 600</a>. </p>
   <center> 
    <table border="0" cellpadding="2" cellspacing="0" width="95%"> 
     <tbody>
      <tr> 
       <td><img SRC="dla1.png" alt="Diffusion Limited Aggregation 1"> </td>
       <td><img SRC="dla2.png" alt="Diffusion Limited Aggregation 2"> </td>
       <td><img SRC="dla3.png" alt="Diffusion Limited Aggregation 3"> </td>
      </tr> 
     </tbody>
    </table> 
   </center> 
   <br> 
   <p><b>Brownian motion.</b> Brownian motion is a random process used to model a wide variety of physical phenomenon including the dispersion of ink flowing in water, and the behavior of atomic particles predicted by quantum physics. (<a href="http://www.doc.ic.ac.uk/~nd/surprise_95/journal/vol4/ykl/report.html">more applications</a>). Fundamental random process in the universe. It is the limit of a discrete random walk and the stochastic analog of the Gaussian distribution. It is now widely used in computational finance, economics, queuing theory, engineering, robotics, medical imaging, biology, and flexible manufacturing systems. First studied by a Scottish botanist Robert Brown in 1828 and analyzed mathematically by Albert Einstein in 1905. Jean-Baptiste Perrin performed experiments to confirm Einstein's predictions and won a Nobel Prize for his work. 
    <!--
Simulate by starting at (0, 0) and taking a step in direction
(dx, dy) where dx and dy are uniform random numbers between -1 and 1.
Square of distance from origin at time t is 2t/3.
(Or should we fix step size, and compute random direction?)
--> An <a href="http://www.phy.ntnu.edu.tw/java/gas2D/gas2D.html">applet</a> to illustrate physical process that may govern cause of Brownian motion. </p>
   <p><b>Simulating a Brownian motion.</b> Since Brownian motion is a continuous and stochastic process, we can only hope to plot one path on a finite interval, sampled at a finite number of points. We can interpolate linearly between these points (i.e., connect the dots). For simplicitly, we'll assume the interval is from 0 to 1 and the sample points t<sub>0</sub>, t<sub>1</sub>, ..., t<sub>N</sub> are equally spaced in this interval. To simulate a standard Brownian motion, repeatedly generate independent Gaussian random variables with mean 0 and standard deviation sqrt(1/N). The value of the Brownian motion at time i is the sum of the first i increments. </p>
   <p> </p>
   <center> 
    <table border="0" cellpadding="2" cellspacing="0" width="500"> 
     <tbody>
      <tr> 
       <td><img SRC="brown1.png" alt="Brownian motion"> </td>
       <td><img SRC="brown2.png" alt="Brownian motion"> </td>
       <td><img SRC="brown3.png" alt="Brownian motion"> </td>
      </tr> 
     </tbody>
    </table> 
   </center> 
   <p><b>Geometric Brownian motion.</b> A variant of Brownian motion is widely used to model stock prices, and the Nobel-prize winning Black-Scholes model is centered on this stochastic process. 
    <!-- If X(t) is a standard Brownian motion, then 
&mu;t + &sigma;X(t) is a <em>generalized Wiener process</em> with 
with drift &mu; and volatility &sigma;.
--> A geometric Brownian motion with drift ? and volatility ? is a stochastic process that can model the price of a stock. The parameter ? models the percentage drift. If ? = 0.10, then we expect the stock to increase by 10% each year. The parameter ? models the percentage volatility. If ? = 0.20, then the standard deviation of the stock price over one year is roughly 20% of the current stock price. To simulate a geometric Brownian motion from time t = 0 to t = T, we follow the same procedure for standard Brownian motion, but multiply the increments, instead of adding them, and incorporate the drift and volatility parameters. Specifically, we multiply the current price by by (1 + ??t + ?sqrt(?t)Z), where Z is a standard Gaussian and ?t = T/N Start with X(0) = 100, ? = 0.04. </p>
   <p> <a href="http://www.cse.ucsc.edu/~chang/203/bm.pdf">construction of BM</a>. </p>
   <p><em>Black-Scholes formula.</em> Move to here? </p>
   <p><b>Ising model.</b> The motions of electrons around a nucleus produce a magnetic field associated with the atom. These <em>atomic magnets</em> act much like conventional magnets. Typically, the magnets point in random directions, and all of the forces cancel out leaving no overall magnetic field in a macroscopic clump of matter. However, in some materials (e.g., iron), the magnets can line up producing a measurable magnetic field. A major achievement of 19th century physics was to describe and understand the equations governing atomic magnets. The probability that state S occurs is given by the Boltzmann probability density function P(S) = e<sup>-E(S)/kT</sup> / Z, where Z is the normalizing constant (<em>partition function</em>) sum e<sup>-E(A)/kT</sup> over all states A, k is Boltzmann's constant, T is the absolute temperature (in degrees Kelvin), and E(S) is the energy of the system in state S. </p>
   <p> Ising model proposed to describe magnetism in crystalline materials. Also models other naturally occurring phenomena including: freezing and evaporation of liquids, protein folding, and behavior of glassy substances. </p>
   <p><em>Ising model.</em> The Boltzmann probability function is an elegant model of magnetism. However, it is not practical to apply it for calculating the magnetic properties of a real iron magnet because any macroscopic chunk of iron contains an enormous number atoms and they interact in complicated ways. The <a href="http://oscar.cacr.caltech.edu/Hrothgar/Ising/">Ising model</a> is a simplified model for magnets that captures many of their important properties, including phase transitions at a critical temperature. (Above this temperature, no macroscopic magnetism, below it, systems exhibits magnetism. For example, iron loses its magnetization around 770 degrees Celsius. Remarkable thing is that transition is sudden.) <a href="http://www.npac.syr.edu/users/gcf/cps713montecarlo/p_montecarlo.html">reference</a> </p>
   <p> First introduced by Lenz and Ising in the 1920s. In the Ising model, the iron magnet is divided into an N-by-N grid of cells. (Vertex = atom in crystal, edge = bond between adjacent atoms.) Each cell contains an abstract entity known as <em>spin</em>. The spin s<sub>i</sub> of cell i is in one of two states: pointing up (+1) or pointing down (-1). The interactions between cells is limited to <em>nearest neighbors</em>. The total magnetism of the system M = sum of s<sub>i</sub>. The total energy of the system E = sum of - J s<sub>i</sub> s<sub>j</sub>, where the sum is taken over all nearest neighbors i and j. The constant J measures the strength of the spin-spin interactions (in units of energy, say ergs). [The model can be extended to allow interaction with an external magnetic field, in which case we add the term -B sum of s<sub>k</sub> over all sites k.] If J &gt; 0, the energy is minimized when the spins are aligned (both +1 or both -1) - this models <em>ferromagnetism</em>. if J &lt; 0, the energy is minimized when the spins are oppositely aligned - this models <em>antiferromagnetism</em>. </p>
   <p> Given this model, a classic problem in statistical mechanics is to compute the expected magenetism. A <em>state</em> is the specification of the spin for each of the N^2 lattice cells. The expected magnetism of the system E[M] = sum of M(S) P(S) over all states S, where M(S) is the magnetism of state S, and P(S) is the probability of state S occurring according to the Boltzmann probability function. Unfortunately, this equation is not amenable to a direct computational because the number of states S is 2<sup>N*N</sup> for an N-by-N lattice. Straightforward Monte Carlo integration won't work because random points will not contribute much to sum. Need selective sampling, ideally sample points proportional to e<sup>-E/kT</sup>. (In 1925, Ising solved the problem in one dimension - no phase transition. In a 1944 tour de force, Onsager solved the 2D Ising problem exactly. His solution showed that it has a phase transition. Not likely to be solved in 3D - see intractability section.) </p>
   <p><em>Metropolis algorithm.</em> Widespread usage of Monte Carlo methods began with Metropolis algorithm for calculation of rigid-sphere system. Published in 1953 after dinner conversation between Metropolis, Rosenbluth, Rosenbluth, Teller, and Teller. Widely used to study equilibrium properties of a system of atoms. Sample using Markov chain using Metropolis' rule: transition from A to B with probability 1 if ? E &lt;= 0, and with probability e<sup>-?E/kT</sup> if ? E &gt; 0. When applied to the Ising model, this Markov chain is ergodic (similar to Google PageRank requirement) so the theory underlying the Metropolis algorithm applies. Converges to stationary distribution. </p>
   <p> Program <a href="Cell.java.html">Cell.java</a>, <a href="State.java.html">State.java</a>, and <a href="Metropolis.java.html">Metropolis.java</a> implements the Metropolis algorithm for a 2D lattice. <a href="Ising.java.html">Ising.java</a> is a procedural programming version. "Doing physics by tossing dice." Simulate complicated physical system by a sequence of simple random steps. </p>
   <p> Measuring physical quantities. Measure magnetism, energy, specific heat when system has thermalized (the system has reached a thermal equilibrium with its surrounding environment at a common temperature T). Compute the average energy 
    <e>
      and the average magenetization 
     <m>
       over time. Also interesting to compute the variance of the energy or 
      <em>specific heat</em> &lt;c&gt; = &lt;E
      <sup>2</sup>&gt; - &lt;E&gt;
      <sup>2</sup>, and the variance of the magnetization or 
      <em>susceptibility</em> &lt;?&gt; = &lt;M
      <sup>2</sup>&gt; - &lt;M&gt;
      <sup>2</sup>. Determining when system has thermalized is a challenging problem - in practice, many scientists use ad hoc methods. 
     </m>
    </e></p>
   <p><em>Phase transition.</em> Phase transition occurs when temperature T<sub>c</sub> is 2 / ln(1 + sqrt(2)) = 2.26918). T<sub>c</sub> is known as the Curie temperature. Plot magnetization M (average of all spins) vs. temperature (kT = 1 to 4). Discontinuity of slope is signature of <em>second order phase transition</em>. Slope approaches infinity. Plot energy (average of all spin-spin interactions) vs. temperature (kT = 1 to 4). Smooth curve through phase transition. Compare against <a href="http://www.nyu.edu/classes/tuckerman/stat.mech/lectures/lecture_26/node2.html"> exact solution</a>. Critical temperature for which algorithm dramatically slows down. Below are the 5000th sample trajectory for J/kT = 0.4 (hot / disorder) and 0.47 (cold / order). The system becomes magnetic as temperature decreases; moreover, as temperature decreases the probability that neighboring sites have the same spin increasing (more clumping). </p>
   <p> Experiments. </p>
   <ul> 
    <li>Start will above critical temperature. State converges to nearly uniform regardless of initial state (all up, all down, random) and fluctuates rapidly. Zero magnetization. </li>
    <li> Start well below critical temperature. Start all spins with equal value (all up or all down). A few small clusters of opposite spin form. </li>
    <li> Start well below critical temperature. Start with random spins. Large clusters of each spin form; eventually simulation makes up its mind. Equally likely to have large clusters in up or down spin. </li>
    <li> Start close to critical temperature. Large clusters form, but fluctuate very slowly. </li>
   </ul> 
   <p> </p>
   <center> 
    <table border="0" cellpadding="2" cellspacing="0"> 
     <tbody>
      <tr> 
       <td><img SRC="ising-0.40.png" alt="Ising with J/kT = 0.40"> </td>
       <td> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; </td>
       <td><img SRC="ising-0.47.png" alt="Ising with J/kT = 0.47"> </td>
      </tr> 
     </tbody>
    </table> 
   </center> 
   <br> 
   <p> Exact solution for Ising model known for 1D and 2D; NP-hard for 3d and nonplanar graphs. </p>
   <p> Models phase changes in binary alloys and spin glasses. Also models neural networks, flocking birds, and beating heart cells. Over 10,000+ papers published using the Ising model. </p>
   <p> </p>
   <h4>Q + A</h4> 
   <p> </p>
   <h4>Exercises</h4> 
   <ol> 
    <li> <b>Print a random word.</b> Read in a list of words (of unknown length) from standard input, and print out one of the N words uniformly at random. Do not store the word list. Instead, use Knuth's method: when reading in the ith word, select it with probability 1/i to be the new champion. Print out the word that survives after reading in all of the data. </li>
    <li><b>Random subset of a linked list.</b> Given an array of N elements and an integer k ? N, construct a new array containing a random subset of k elements. <em>Hint</em>: traverse the array, either accepting each element with probability a/b, where a is the number of elements left to select, and b is the number of elements remaining. </li>
   </ol> 
   <p> </p>
   <h4>Creative Exercises</h4> 
   <ol> 
    <li><b>Random number generation.</b> Can the following for computing a pseudo-random integer between 0 and N-1 fail? <tt>Math.random</tt> is guaranteed to return a floating point number greater than or equal to 0.0 and strictly less than 1.0. 
     <blockquote> 
      <table> 
       <tbody>
        <tr>
         <td><pre>
double x = Math.random();
int r = (int) (x * N);
</pre></td>
        </tr> 
       </tbody>
      </table> 
     </blockquote> <p> That is, can you find a real number <tt>x</tt> and an integer <tt>N</tt> for which r equals N? </p><p> <em>Solution:</em> No, it can't happen in IEEE floating point arithmetic. The roundoff error will not cause the result to be N, even if <tt>Math.random</tt> returns 0.9999999999.... However, this method does not produce integers <em>uniformly</em> at random because floating point numbers are not evenly distributed. Also, it involves casting and multiplying, which are excessive. </p></li>
    <li><b>Random number test.</b> Write a program to plot the outcome of a boolean pseudo-random number generator. For simplicity, use <tt>(Math.random() &lt; 0.5)</tt> and plot in a 128-by-128 grid like the following <a href="http://www.alife.co.uk/nonrandom/">pseudorandom applet</a>. Perhaps use LFSR or <tt>Random.nextLong() % 2</tt>. </li>
    <li><b>Sampling from a discrete probability distribution.</b> Suppose that there are N events and event <em>i</em> occurs with probability p<sub>i</sub>, where p<sub>0</sub> + p<sub>1</sub> + ... + p<sub>N-1</sub> = 1. Write a program <tt>Sample.java</tt> that prints out 1,000 sample events according to the probability distribution. <em>Hint</em>: choose a random number r between 0 and 1 and iterate from i = 0 to N-1 until p<sub>0</sub> + p<sub>1</sub> + ... + p<sub>i</sub> &gt; r. (Be careful about floating point precision.) </li>
    <li><b>Sampling from a discrete probability distribution.</b> Improve the algorithm from the previous problem so that it takes time proportional to log N to generate a new sample. <em>Hint</em>: binary search on the cumulative sums. <em>Note</em>: see <a href="http://citeseer.nj.nec.com/591481.html">this paper</a> for a very clever alternative that generates random samples in a constant amount of time. <a href="Discrete.java.html">Discrete.java</a> is a Java version of Warren D. Smith's WDSsampler.c program. </li>
    <li><b>Sampling from a discrete probability distribution.</b> Repeat the previous question but make it dynamic. That is, after each sample, the probabilities of some events might change, or there may be new events. Used in <em>n-fold way algorithm</em>, which is method of choice for <em>kinetic Monte Carlo methods</em> where one wants to simulate the kinetic evolution process. Typical application: simulating gas reacting with surface of a substrate where chemical reaction occur at different rates. <em>Hint</em>: use a binary search tree. </li>
    <li><b>Zipf distribution.</b> Use the result of the previous exercise(s) to sample from the <a href="http://en.wikipedia.org/wiki/Zipf's_law">Zipfian distribution</a> with parameter s and N. The distribution can take on integer values from 1 to N, and takes on value k with probability 1/k^s / sum_(i = 1 to N) 1/i^s. Example: words in Shakespeare's play Hamlet with s approximately equal to 1. </li>
    <li><b>Simulating a Markov chain.</b> Write a program <a href="MarkovChain.java.html">MarkovChain.java</a> that simulates a Markov chain. Hint: you will need to sample from a discrete distribution. </li>
    <li><b>DLA with non-unity sticking probability</b> Modify <a href="DLA.java.html">DLA.java</a> so that the initial aggregate consists of several randomly spaced cells along the bottom of the lattice. This simulates string-like bacterial growth. </li>
    <li><b>DLA with non-unity sticking probability</b> Modify <a href="DLA.java.html">DLA.java</a> to allow a sticking probability less than one. That is, if a particle has a neighbor, then it sticks with probability p &lt; 1.0; otherwise, it moves at random to a neighboring cell which is unoccupied. This results in a gives more clustered structure, simulating higher bond affinity between atoms. </li>
    <li><b>Symmetric DLA</b>. Initialize the aggregate to be a single particle in the center of the lattice. Launch particles uniformly from a circle centered at the initial particle. Increase the size of the launch circle as the size of the aggregate increases. Name your program <a href="SymmetricDLA.java.html">SymmetricDLA.java</a>. This simulates the growth of an aggregate where the particles wander in randomly from infinity. Here are some tricks for <a href="http://www.oche.de/~ecotopia/dla/improvements.html"> speeding up the process</a>. 
     <center> 
      <table border="0" cellpadding="2" cellspacing="0" width="95%"> 
       <tbody>
        <tr> 
         <td><img SRC="dla-symmetric1.png" alt="Symmetric Diffusion Limited Aggregation 1"> </td>
         <td><img SRC="dla-symmetric2.png" alt="Symmetric Diffusion Limited Aggregation 2"> </td>
         <td><img SRC="dla-symmetric3.png" alt="Symmetric Diffusion Limited Aggregation 3"> </td>
        </tr> 
       </tbody>
      </table> 
     </center> <br> </li>
    <li><b>Variable sticking probability</b>. A wandering particle which enters an empty site next to an occupied site is assigned a random number, indicating a potential direction in which the particle can move (up, down, left or right). If an occupied site exists on the new site indicated by the random number, then the particle sticks to the aggregate by occupying its current lattice site. If not, it moves to that site and the random walk continues. This simulates snowflake growth. </li>
    <li><b>Random walk solution of Laplace's equation.</b> Numerically solve Laplace's equation to determine the electric potential given the positions of the charges on the boundary. Laplace's equation says that the gradient of the potential is the sum of the second partial derivatives with respect to x and y. <em>See Gould and Tobochnik, 10.2</em>. Your goal is to find the function V(x, y) that satisfies Laplace's equation at specified boundary conditions. Assume the charge-free region is a square and that the potential is 10 along the vertical boundaries and 5 along the horizontal ones. To solve Laplace's equation, divide the square up into an N-by-N grid of points. The potential V(x, y) of cell (x, y) is the average of the potentials at the four neighboring cells. To estimate V(x, y), simulate 1 million random walkers starting at cell (x, y) and continuing until they reach the boundary. An estimate of V(x, y) is the average potential at the 1 million boundary cells reached. Write a program <a href="Laplace.java.html">Laplace.java</a> that takes three command line parameters N, x, and y and estimates V(x, y) over an N-by-N grid of cells where the potential at column 0 and N is 10 and the potential at row 0 and N is 5. <p> Remark: although the boundary value problem above can be solved analytically, numerical simulations like the one above are useful when the region has a more complicated shape or needs to be repeated for different boundary conditions. </p><p>simulated annealing </p></li>
    <li><b>Simulating a geometric random variable.</b> If some event occurs with probability p, a geometric random variable with parameter p models the number N of independent trials needed between occurrence of the event. To generate a variable with the geometric distribution, use the following formula 
     <blockquote>
       N = ceil(ln U / ln (1 - p)) 
     </blockquote> where U is a variable with the uniform distribution. Use the Math library methods <tt>Math.ceil</tt>, <tt>Math.log</tt>, and <tt>Math.random</tt>. </li>
    <li><b>Simulating an exponential random variable.</b> The exponential distribution is widely used to model the the inter-arrival time between city buses, the time between failure of light bulbs, etc. The probability that an exponential random variable with parameter ? is less than <em>x</em> is <em>F(x) = 1 - e<sup>? x</sup></em> for <em>x &gt;= 0</em>. To generate a random deviate from the distribution, use the inverse function method: output -ln(U) / ? where U is a uniform random number between 0 and 1. </li>
    <li><b>Poisson distribution.</b> The Poisson distribution is useful in describing the fluctuations in the number of nuclei that decay in any particular small time interval. 
     <blockquote> 
      <table> 
       <tbody>
        <tr>
         <td><pre>
public static int poisson(double c) {
   double t = 0.0;
   for (int x = 0; true; x++) {
      t = t - Math.log(Math.random()) / c;  // sum exponential deviates
      if (t &gt; 1.0) return x;
   }
}
</pre></td>
        </tr> 
       </tbody>
      </table> 
     </blockquote> </li>
    <li><b>Simulating a Pareto random variable.</b> The Pareto distribution is often used to model insurance claims damages, financial option holding times, and Internet traffic activity. The probability that a Pareto random variable with parameter <em>a</em> is less than <em>x</em> is <em>F(x) = 1 - (1 + x)<sup>-a</sup></em> for <em>x &gt;= 0</em>. To generate a random deviate from the distribution, use the inverse function method: output (1-U)<sup>-1/a</sup> - 1, where U is a uniform random number between 0 and 1. </li>
    <li><b>Simulating a Cauchy random variable.</b> The density function of a Cauchy random variable is f(x) = 1/(?(1 + x<sup>2</sup>)). The probability that a Cauchy random variable is less than <em>x</em> is <em>F(x) = 1/? (?/2 + arctan(x))</em>. To generate a random deviate from the distribution, use the inverse function method: output tan(?(U - 1/2)), where U is a uniform random number between 0 and 1. </li>
    <li><b>Generate random point inside unit disc.</b> Incorrect to choose set <em>r</em> uniformly between 0 and 1, ? uniformly between 0.0 and 2?, and use (x, y) = (r cos?, r sin?). If you do this, more points close to center of disc. Instead, set (x, y) = (?r cos&amp;theta, ?r sin?) Alternatively, generate x and y uniformly between -1 and 1 and accept if x<sup>2</sup> + y<sup>2</sup> ? 1. Plot a random sequence of points using both methods and see the bias. </li>
    <li><b>Flipping bits.</b> As part of a genetic algorithm, suppose you need to flip N bits independently, each with probability p, where p is some very small constant. 
     <ul> 
      <li>Method 1: loop through N bits, generate a Bernouilli(p) random variable for each one and flip accordingly. Takes time proportional to N. </li>
      <li>Method 2: generate a Geometric(p) random variable X_0 and flip bit X_0; genereate another Geometric(p) random variable an flip bit X_0 + X_1, and so on. Takes time proportional to Np. </li>
      <li>Method 3: the number of bits to flip in Binomial(N, p). Determine how many bits to flip by approximating with a Gaussian(Np, sigma) random variable. Then flip Z bits, taking care not to avoid duplicates. Takes time proportional to Np, but less calls to transcendental functions. </li>
     </ul> </li>
    <li><b>Random point inside N-dimensional sphere.</b> Write a program <tt>InsideSphere.java</tt> that takes a command line parameter N and computes a random point inside an N-dimensional sphere with radius 1. Generate N uniform random variables deviates x<sub>1</sub>, ..., x<sub>N</sub> and use this point if <p> </p>
     <table> 
      <tbody>
       <tr>
        <td><pre>
(x<sub>1</sub>)<sup>2</sup> + ... + (x<sub>N</sub>)<sup>2</sup> ? 1
</pre></td>
       </tr> 
      </tbody>
     </table> <p> Otherwise repeat. </p></li>
    <li><b>Random point on surface of an N-dimensional sphere.</b> Write a program <a href="Sphere.java.html">Sphere.java</a> that takes a command line parameter N and computes a random point on the surface of an N-dimensional sphere with radius 1 using Brown's method. Brown's method is to compute N independent standard normal deviates x<sub>1</sub>, x<sub>N</sub>. Then <p> </p>
     <table> 
      <tbody>
       <tr>
        <td><pre>
( x<sub>1</sub>/r, x<sub>2</sub>/r, ..., x<sub>N</sub>/r ), where r = sqrt((x<sub>1</sub>)<sup>2</sup> + ... + (x<sub>N</sub>)<sup>2</sup>)
</pre></td>
       </tr> 
      </tbody>
     </table> <p> has the desired distribution. Use Exercise xyz from Section 3 to compute standard normal deviates. </p></li>
    <li><b>Potts model.</b> The <em>Potts model</em> is a variant of the Ising model where each site has q possible directions. (q = 2 corresponds to Ising) The total energy of the system E = sum of - J sigma(s<sub>i</sub>, s<sub>j</sub>) over all neighbors. The <a href="http://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a> function ?(x, y) = 1 if x = y and 0 otherwise. </li>
    <li><b>2D Brownian motion.</b> Simulate diffusion of particles in a fluid. Write a data type <a href="BrownianParticle.java.html">BrownianParticle.java</a> that represents a particle undergoing a Brownian motion in two dimensions. To do this, simulate two indepedent Brownian motions X(t) and Y(t), and plot (X(t), Y(t)). Create a client program that takes a command line integer N, creates N particles at the origin, and simulates a Brownian motion for the N particles. </li>
    <li><b>Brownian bridge.</b> A <em>Browian bridge</em> is a constratined Brownian motion, which is required to begin at the origin at time 0, and end at the origin at time T. If X(t) is a Brownian motion then Z(t) = X(t) - (t/T)X(T) is such a process. To plot, store the intermediate values X(t) and plot after you've computed X(T). </li>
    <li><b>Rainbow.</b> In 1637 Rene Descartes discovered the first scientific explanation for the formation of rainbows. His method involved tracing the internal reflections when a light ray is sent through a a spherical raindrop. Simulate the <a href="http://astro.temple.edu/~dhill001/MCRain/MCRain.html">generation of a rainbow</a> according to model of large number of parallel rays hitting a spherical raindrop. When a light ray hit a raindrop, the ray is reflected and refracted. We use the HSB color format, and choose the hue h at random between 0 (red) and 1 (violet). We use 1.33 + 0.06 * h for the refraction index of hue h. For each ray, we plot a single point of light, according to physical laws of refraction and reflection. Each point of light is then plotted in a random color that the observer will see, either in the primary or secondary rainbow. To perform the simulation, we choose one of the 7 colors uniformly at random. Then, we choose a point (x, y) in the unit circle, centered at (0, 0) and set the impact parameter r = sqrt(x<sup>2</sup> + y<sup>2</sup>). The angle of incidence ?<sub>i</sub> = arcsin(r) and, by Snell's law, the angle of refraction ?<sub>r</sub> = arcsin (r / n), where <em>n</em> is the refraction index. If the light ray is totally reflected only once, it emerges at an angle of ?<sub>p</sub> = 4?<sub>r</sub> - 2?<sub>i</sub>, contributing to the primary rainbow. If the light ray is totally reflected a second time, it emerges at an angle of ?<sub>p</sub> = 6?<sub>r</sub> - 2?<sub>i</sub> - ?, contributing to the secondary rainbow. The intensities I<sub>p</sub> and I<sub>s</sub> of the primary and secondary rays are calculated according to the following transmission and reflection formulas for electromagnetic waves across the boundary of two media. 
     <blockquote> 
      <table> 
       <tbody>
        <tr>
         <td><pre>
I<sub>p</sub> = 1/2 (s(1-s)<sup>2</sup> + p(1-p)<sup>2</sup>)
I<sub>s</sub> = 1/2 (s<sup>2</sup>(1-s)<sup>2</sup> + p<sup>2</sup>(1-p)<sup>2</sup>)
p = (sin(?<sub>i</sub>-?<sub>r</sub>)/sin(?<sub>i</sub>+?<sub>r</sub>))<sup>2</sup>
r = (tan(?<sub>i</sub>-?<sub>r</sub>)/tan(?<sub>i</sub>+?<sub>r</sub>))<sup>2</sup>
</pre></td>
        </tr> 
       </tbody>
      </table> 
     </blockquote> <p> The color intensities I<sub>p</sub> and I<sub>s</sub> are used to determine the saturation in the HSB color format. Program <a href="Rainbow.java.html">Rainbow.java</a> simulates this process. </p><p> </p>
     <center>
      <img src="rainbow.png" alt="Rainbow">
     </center> <p> </p><p> <a href="http://www.rebeccapaton.net/rainbows/index.htm">Rainbow site</a>. </p></li>
   </ol> 
   <br>
   <br> 
   <p class="footer"> <em>Last modified on January 31, 2009.</em><br><br> Copyright © 2000–2016 <a href="http://www.cs.princeton.edu/~rs" class="footer">Robert Sedgewick</a> and <a href="http://www.cs.princeton.edu/~wayne" class="footer">Kevin Wayne</a>. All rights reserved. </p>
  </div> 
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> 
  <script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10811519-1");
pageTracker._trackPageview();
} catch(err) {}</script>   
 </body>
</html>